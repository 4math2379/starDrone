<!DOCTYPE html>
<html>
<head>
  <title>nan_persistent_pre_12_inl.h</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/nan/nan_persistent_pre_12_inl.h";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>nan_persistent_pre_12_inl.h</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<div class="dox">
<div class="summary">
<hr>
<p>NAN - Native Abstractions for Node.js</p>
</div>
<div class="body">
<p>Copyright (c) 2016 NAN contributors</p>
<p>MIT License <a href="https://github.com/nodejs/nan/blob/master/LICENSE.md">https://github.com/nodejs/nan/blob/master/LICENSE.md</a></p>
<hr>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
#ifndef NAN_PERSISTENT_PRE_12_INL_H_
#define NAN_PERSISTENT_PRE_12_INL_H_

template&lt;typename T&gt;
class PersistentBase {
  v8::Persistent&lt;T&gt; persistent;
  template&lt;typename U&gt;
  friend v8::Local&lt;U&gt; New(const PersistentBase&lt;U&gt; &amp;p);
  template&lt;typename U, typename M&gt;
  friend v8::Local&lt;U&gt; New(const Persistent&lt;U, M&gt; &amp;p);
  template&lt;typename U&gt;
  friend v8::Local&lt;U&gt; New(const Global&lt;U&gt; &amp;p);
  template&lt;typename S&gt; friend class ReturnValue;

 public:
  NAN_INLINE PersistentBase() :
      persistent() {}

  NAN_INLINE void Reset() {
    persistent.Dispose();
    persistent.Clear();
  }

  template&lt;typename S&gt;
  NAN_INLINE void Reset(const v8::Local&lt;S&gt; &amp;other) {
    TYPE_CHECK(T, S);

    if (!persistent.IsEmpty()) {
      persistent.Dispose();
    }

    if (other.IsEmpty()) {
      persistent.Clear();
    } else {
      persistent = v8::Persistent&lt;T&gt;::New(other);
    }
  }

  template&lt;typename S&gt;
  NAN_INLINE void Reset(const PersistentBase&lt;S&gt; &amp;other) {
    TYPE_CHECK(T, S);

    if (!persistent.IsEmpty()) {
      persistent.Dispose();
    }

    if (other.IsEmpty()) {
      persistent.Clear();
    } else {
      persistent = v8::Persistent&lt;T&gt;::New(other.persistent);
    }
  }

  NAN_INLINE bool IsEmpty() const { return persistent.IsEmpty(); }

  NAN_INLINE void Empty() { persistent.Clear(); }

  template&lt;typename S&gt;
  NAN_INLINE bool operator==(const PersistentBase&lt;S&gt; &amp;that) {
    return this-&gt;persistent == that.persistent;
  }

  template&lt;typename S&gt;
  NAN_INLINE bool operator==(const v8::Local&lt;S&gt; &amp;that) {
    return this-&gt;persistent == that;
  }

  template&lt;typename S&gt;
  NAN_INLINE bool operator!=(const PersistentBase&lt;S&gt; &amp;that) {
    return !operator==(that);
  }

  template&lt;typename S&gt;
  NAN_INLINE bool operator!=(const v8::Local&lt;S&gt; &amp;that) {
    return !operator==(that);
  }

  template&lt;typename P&gt;
  NAN_INLINE void SetWeak(
    P *parameter
    , typename WeakCallbackInfo&lt;P&gt;::Callback callback
    , WeakCallbackType type);

  NAN_INLINE void ClearWeak() { persistent.ClearWeak(); }

  NAN_INLINE void MarkIndependent() { persistent.MarkIndependent(); }

  NAN_INLINE bool IsIndependent() const { return persistent.IsIndependent(); }

  NAN_INLINE bool IsNearDeath() const { return persistent.IsNearDeath(); }

  NAN_INLINE bool IsWeak() const { return persistent.IsWeak(); }

 private:
  NAN_INLINE explicit PersistentBase(v8::Persistent&lt;T&gt; that) :
      persistent(that) { }
  NAN_INLINE explicit PersistentBase(T *val) : persistent(val) {}
  template&lt;typename S, typename M&gt; friend class Persistent;
  template&lt;typename S&gt; friend class Global;
  friend class ObjectWrap;
};

template&lt;typename T&gt;
class NonCopyablePersistentTraits {
 public:
  typedef Persistent&lt;T, NonCopyablePersistentTraits&lt;T&gt; &gt;
      NonCopyablePersistent;
  static const bool kResetInDestructor = false;
  template&lt;typename S, typename M&gt;
  NAN_INLINE static void Copy(const Persistent&lt;S, M&gt; &amp;source,
                             NonCopyablePersistent *dest) {
    Uncompilable&lt;v8::Object&gt;();
  }

  template&lt;typename O&gt; NAN_INLINE static void Uncompilable() {
    TYPE_CHECK(O, v8::Primitive);
  }
};

template&lt;typename T&gt;
struct CopyablePersistentTraits {
  typedef Persistent&lt;T, CopyablePersistentTraits&lt;T&gt; &gt; CopyablePersistent;
  static const bool kResetInDestructor = true;
  template&lt;typename S, typename M&gt;
  static NAN_INLINE void Copy(const Persistent&lt;S, M&gt; &amp;source,
                             CopyablePersistent *dest) {}
};

template&lt;typename T, typename M&gt; class Persistent :
    public PersistentBase&lt;T&gt; {
 public:
  NAN_INLINE Persistent() {}

  template&lt;typename S&gt; NAN_INLINE Persistent(v8::Handle&lt;S&gt; that)
      : PersistentBase&lt;T&gt;(v8::Persistent&lt;T&gt;::New(that)) {
    TYPE_CHECK(T, S);
  }

  NAN_INLINE Persistent(const Persistent &amp;that) : PersistentBase&lt;T&gt;() {
    Copy(that);
  }

  template&lt;typename S, typename M2&gt;
  NAN_INLINE Persistent(const Persistent&lt;S, M2&gt; &amp;that) :
      PersistentBase&lt;T&gt;() {
    Copy(that);
  }

  NAN_INLINE Persistent &amp;operator=(const Persistent &amp;that) {
    Copy(that);
    return *this;
  }

  template &lt;class S, class M2&gt;
  NAN_INLINE Persistent &amp;operator=(const Persistent&lt;S, M2&gt; &amp;that) {
    Copy(that);
    return *this;
  }

  NAN_INLINE ~Persistent() {
    if (M::kResetInDestructor) this-&gt;Reset();
  }

 private:
  NAN_INLINE T *operator*() const { return *PersistentBase&lt;T&gt;::persistent; }

  template&lt;typename S, typename M2&gt;
  NAN_INLINE void Copy(const Persistent&lt;S, M2&gt; &amp;that) {
    TYPE_CHECK(T, S);

    this-&gt;Reset();

    if (!that.IsEmpty()) {
      this-&gt;persistent = v8::Persistent&lt;T&gt;::New(that.persistent);
      M::Copy(that, this);
    }
  }
};

template&lt;typename T&gt;
class Global : public PersistentBase&lt;T&gt; {
  struct RValue {
    NAN_INLINE explicit RValue(Global* obj) : object(obj) {}
    Global* object;
  };

 public:
  NAN_INLINE Global() : PersistentBase&lt;T&gt;(0) { }

  template &lt;typename S&gt;
  NAN_INLINE Global(v8::Local&lt;S&gt; that)
      : PersistentBase&lt;T&gt;(v8::Persistent&lt;T&gt;::New(that)) {
    TYPE_CHECK(T, S);
  }

  template &lt;typename S&gt;
  NAN_INLINE Global(const PersistentBase&lt;S&gt; &amp;that)
    : PersistentBase&lt;T&gt;(that) {
    TYPE_CHECK(T, S);
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<div class="dox">
<div class="summary">
<p>Move constructor.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">  NAN_INLINE Global(RValue rvalue)
    : PersistentBase&lt;T&gt;(rvalue.object-&gt;persistent) {
    rvalue.object-&gt;Reset();
  }
  NAN_INLINE ~Global() { this-&gt;Reset(); }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<div class="dox">
<div class="summary">
<p>Move via assignment.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> S&gt;
  NAN_INLINE Global &amp;<span class="hljs-keyword">operator</span>=(Global&lt;S&gt; rhs) {
    TYPE_CHECK(T, S);
    <span class="hljs-keyword">this</span>-&gt;Reset(rhs.persistent);
    rhs.Reset();
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<div class="dox">
<div class="summary">
<p>Cast operator for moves.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-function">NAN_INLINE <span class="hljs-keyword">operator</span> <span class="hljs-title">RValue</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> RValue(<span class="hljs-keyword">this</span>); }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<div class="dox">
<div class="summary">
<p>Pass allows returning uniques from functions, etc.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-function">Global <span class="hljs-title">Pass</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> Global(RValue(<span class="hljs-keyword">this</span>)); }

 <span class="hljs-keyword">private</span>:
  Global(Global &amp;);
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>=(Global &amp;);
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> S&gt; <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> ReturnValue;
};

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAN_PERSISTENT_PRE_12_INL_H_</span></span>

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
