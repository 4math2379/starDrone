<!DOCTYPE html>
<html>
<head>
  <title>nan.h</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/nan/nan.h";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>nan.h</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<div class="dox">
<div class="summary">
<hr>
<p>NAN - Native Abstractions for Node.js</p>
</div>
<div class="body">
<p>Copyright (c) 2016 NAN contributors:</p>
<ul>
<li>Rod Vagg <a href="https://github.com/rvagg">https://github.com/rvagg</a></li>
<li>Benjamin Byholm <a href="https://github.com/kkoopa">https://github.com/kkoopa</a></li>
<li>Trevor Norris <a href="https://github.com/trevnorris">https://github.com/trevnorris</a></li>
<li>Nathan Rajlich <a href="https://github.com/TooTallNate">https://github.com/TooTallNate</a></li>
<li>Brett Lawson <a href="https://github.com/brett19">https://github.com/brett19</a></li>
<li>Ben Noordhuis <a href="https://github.com/bnoordhuis">https://github.com/bnoordhuis</a></li>
<li>David Siegel <a href="https://github.com/agnat">https://github.com/agnat</a></li>
</ul>
<p>MIT License <a href="https://github.com/nodejs/nan/blob/master/LICENSE.md">https://github.com/nodejs/nan/blob/master/LICENSE.md</a></p>
<p>Version 2.2.1: current Node 5.9.1, Node 12: 0.12.12, Node 10: 0.10.43, iojs: 3.3.1</p>
<p>See https://github.com/nodejs/nan for the latest update to this file</p>
<hr>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NAN_H_</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAN_H_</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;node_version.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_0_10_MODULE_VERSION 11</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_0_12_MODULE_VERSION 14</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ATOM_0_21_MODULE_VERSION 41</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOJS_1_0_MODULE_VERSION  42</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOJS_1_1_MODULE_VERSION  43</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOJS_2_0_MODULE_VERSION  44</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOJS_3_0_MODULE_VERSION  45</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_4_0_MODULE_VERSION  46</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_HAS_CPLUSPLUS_11 (_MSC_VER &gt;= 1800)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_HAS_CPLUSPLUS_11 (__cplusplus &gt;= 201103L)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION &amp;&amp; !NAN_HAS_CPLUSPLUS_11</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">error</span> This version of node/NAN/v8 requires a C++11 compiler</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;uv.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;node_buffer.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;node_object_wrap.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_MSC_VER)</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( push )</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( disable : 4530 )</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( pop )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>uv helpers</p>

        </td>
        <td class="code highlight">
          <pre class="c">#ifdef UV_VERSION_MAJOR
# ifndef UV_VERSION_PATCH
#  define UV_VERSION_PATCH 0
# endif
# define NAUV_UVVERSION ((UV_VERSION_MAJOR &lt;&lt; 16) | \
                         (UV_VERSION_MINOR &lt;&lt;  8) | \
                         (UV_VERSION_PATCH))
#else
# define NAUV_UVVERSION 0x000b00
#endif

#if NAUV_UVVERSION &lt; 0x000b0b
# ifdef WIN32
#  include &lt;windows.h&gt;
# else
#  include &lt;pthread.h&gt;
# endif
#endif

namespace Nan {

#if defined(__GNUC__) &amp;&amp; !(defined(DEBUG) &amp;&amp; DEBUG)
# define NAN_INLINE inline __attribute__((always_inline))
#elif defined(_MSC_VER) &amp;&amp; !(defined(DEBUG) &amp;&amp; DEBUG)
# define NAN_INLINE __forceinline
#else
# define NAN_INLINE inline
#endif

#if defined(__GNUC__) &amp;&amp; \
    !(defined(V8_DISABLE_DEPRECATIONS) &amp;&amp; V8_DISABLE_DEPRECATIONS)
# define NAN_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER) &amp;&amp; \
    !(defined(V8_DISABLE_DEPRECATIONS) &amp;&amp; V8_DISABLE_DEPRECATIONS)
# define NAN_DEPRECATED __declspec(deprecated)
#else
# define NAN_DEPRECATED
#endif

#if NAN_HAS_CPLUSPLUS_11
# define NAN_DISALLOW_ASSIGN(CLASS) void operator=(const CLASS&amp;) = delete;
# define NAN_DISALLOW_COPY(CLASS) CLASS(const CLASS&amp;) = delete;
# define NAN_DISALLOW_MOVE(CLASS)                                              \
    CLASS(CLASS&amp;&amp;) = delete;  /* NOLINT(build/c++11) */                        \
    void operator=(CLASS&amp;&amp;) = delete;
#else
# define NAN_DISALLOW_ASSIGN(CLASS) void operator=(const CLASS&amp;);
# define NAN_DISALLOW_COPY(CLASS) CLASS(const CLASS&amp;);
# define NAN_DISALLOW_MOVE(CLASS)
#endif

#define NAN_DISALLOW_ASSIGN_COPY(CLASS)                                        \
    NAN_DISALLOW_ASSIGN(CLASS)                                                 \
    NAN_DISALLOW_COPY(CLASS)

#define NAN_DISALLOW_ASSIGN_MOVE(CLASS)                                        \
    NAN_DISALLOW_ASSIGN(CLASS)                                                 \
    NAN_DISALLOW_MOVE(CLASS)

#define NAN_DISALLOW_COPY_MOVE(CLASS)                                          \
    NAN_DISALLOW_COPY(CLASS)                                                   \
    NAN_DISALLOW_MOVE(CLASS)

#define NAN_DISALLOW_ASSIGN_COPY_MOVE(CLASS)                                   \
    NAN_DISALLOW_ASSIGN(CLASS)                                                 \
    NAN_DISALLOW_COPY(CLASS)                                                   \
    NAN_DISALLOW_MOVE(CLASS)

#define TYPE_CHECK(T, S)                                                       \
    while (false) {                                                            \
      *(static_cast&lt;T *volatile *&gt;(0)) = static_cast&lt;S*&gt;(0);                   \
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>=== RegistrationFunction =====================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
#if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
  typedef v8::Handle&lt;v8::Object&gt; ADDON_REGISTER_FUNCTION_ARGS_TYPE;
#else
  typedef v8::Local&lt;v8::Object&gt; ADDON_REGISTER_FUNCTION_ARGS_TYPE;
#endif

#define NAN_MODULE_INIT(name)                                                  \
    void name(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>=== CallbackInfo =============================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_callbacks.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>==============================================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
#if (NODE_MODULE_VERSION &lt; NODE_0_12_MODULE_VERSION)
typedef v8::Script             UnboundScript;
typedef v8::Script             BoundScript;
#else
typedef v8::UnboundScript      UnboundScript;
typedef v8::Script             BoundScript;
#endif

#if (NODE_MODULE_VERSION &lt; ATOM_0_21_MODULE_VERSION)
typedef v8::String::ExternalAsciiStringResource
    ExternalOneByteStringResource;
#else
typedef v8::String::ExternalOneByteStringResource
    ExternalOneByteStringResource;
#endif

#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
template&lt;typename T&gt;
class NonCopyablePersistentTraits :
    public v8::NonCopyablePersistentTraits&lt;T&gt; {};
template&lt;typename T&gt;
class CopyablePersistentTraits :
    public v8::CopyablePersistentTraits&lt;T&gt; {};

template&lt;typename T&gt;
class PersistentBase :
    public v8::PersistentBase&lt;T&gt; {};

template&lt;typename T, typename M = v8::NonCopyablePersistentTraits&lt;T&gt; &gt;
class Persistent;
#else
template&lt;typename T&gt; class NonCopyablePersistentTraits;
template&lt;typename T&gt; class PersistentBase;
template&lt;typename T, typename P&gt; class WeakCallbackData;
template&lt;typename T, typename M = NonCopyablePersistentTraits&lt;T&gt; &gt;
class Persistent;
#endif  // NODE_MODULE_VERSION

#if defined(V8_MAJOR_VERSION) &amp;&amp; (V8_MAJOR_VERSION &gt; 4 ||                      \
  (V8_MAJOR_VERSION == 4 &amp;&amp; defined(V8_MINOR_VERSION) &amp;&amp; V8_MINOR_VERSION &gt;= 3))
# include "nan_maybe_43_inl.h"  // NOLINT(build/include)
#else
# include "nan_maybe_pre_43_inl.h"  // NOLINT(build/include)
#endif

#include "nan_converters.h"  // NOLINT(build/include)
#include "nan_new.h"  // NOLINT(build/include)

#if NAUV_UVVERSION &lt; 0x000b17
#define NAUV_WORK_CB(func) \
    void func(uv_async_t *async, int)
#else
#define NAUV_WORK_CB(func) \
    void func(uv_async_t *async)
#endif

#if NAUV_UVVERSION &gt;= 0x000b0b

typedef uv_key_t nauv_key_t;

inline int nauv_key_create(nauv_key_t *key) {
  return uv_key_create(key);
}

inline void nauv_key_delete(nauv_key_t *key) {
  uv_key_delete(key);
}

inline void* nauv_key_get(nauv_key_t *key) {
  return uv_key_get(key);
}

inline void nauv_key_set(nauv_key_t *key, void *value) {
  uv_key_set(key, value);
}

#else

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<div class="dox">
<div class="summary">
<p>Implement thread local storage for older versions of libuv.
This is essentially a backport of libuv commit 5d2434bf
written by Ben Noordhuis, adjusted for names and inline.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
#ifndef WIN32

typedef pthread_key_t nauv_key_t;

inline int nauv_key_create(nauv_key_t* key) {
  return -pthread_key_create(key, NULL);
}

inline void nauv_key_delete(nauv_key_t* key) {
  if (pthread_key_delete(*key))
    abort();
}

inline void* nauv_key_get(nauv_key_t* key) {
  return pthread_getspecific(*key);
}

inline void nauv_key_set(nauv_key_t* key, void* value) {
  if (pthread_setspecific(*key, value))
    abort();
}

#else

typedef struct {
  DWORD tls_index;
} nauv_key_t;

inline int nauv_key_create(nauv_key_t* key) {
  key-&gt;tls_index = TlsAlloc();
  if (key-&gt;tls_index == TLS_OUT_OF_INDEXES)
    return UV_ENOMEM;
  return 0;
}

inline void nauv_key_delete(nauv_key_t* key) {
  if (TlsFree(key-&gt;tls_index) == FALSE)
    abort();
  key-&gt;tls_index = TLS_OUT_OF_INDEXES;
}

inline void* nauv_key_get(nauv_key_t* key) {
  void* value = TlsGetValue(key-&gt;tls_index);
  if (value == NULL)
    if (GetLastError() != ERROR_SUCCESS)
      abort();
  return value;
}

inline void nauv_key_set(nauv_key_t* key, void* value) {
  if (TlsSetValue(key-&gt;tls_index, value) == FALSE)
    abort();
}

#endif
#endif

#if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
template&lt;typename T&gt;
v8::Local&lt;T&gt; New(v8::Handle&lt;T&gt;);
#endif

#if defined(V8_MAJOR_VERSION) &amp;&amp; (V8_MAJOR_VERSION &gt; 4 ||                      \
  (V8_MAJOR_VERSION == 4 &amp;&amp; defined(V8_MINOR_VERSION) &amp;&amp; V8_MINOR_VERSION &gt;= 3))
  typedef v8::WeakCallbackType WeakCallbackType;
#else
struct WeakCallbackType {
  enum E {kParameter, kInternalFields};
  E type;
  WeakCallbackType(E other) : type(other) {}  // NOLINT(runtime/explicit)
  inline bool operator==(E other) { return other == this-&gt;type; }
  inline bool operator!=(E other) { return !operator==(other); }
};
#endif

template&lt;typename P&gt; class WeakCallbackInfo;

#if NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION
# include "nan_persistent_12_inl.h"  // NOLINT(build/include)
#else
# include "nan_persistent_pre_12_inl.h"  // NOLINT(build/include)
#endif

namespace imp {
  static const size_t kMaxLength = 0x3fffffff;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>v8::String::REPLACE_INVALID_UTF8 was introduced
in node.js v0.10.29 and v0.8.27.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MAJOR_VERSION &gt; 0 || \
    NODE_MINOR_VERSION &gt; 10 || \
    NODE_MINOR_VERSION == 10 &amp;&amp; NODE_PATCH_VERSION &gt;= 29 || \
    NODE_MINOR_VERSION == 8 &amp;&amp; NODE_PATCH_VERSION &gt;= 27</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> kReplaceInvalidUtf8 = v8::String::REPLACE_INVALID_UTF8;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> kReplaceInvalidUtf8 = <span class="hljs-number">0</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}  <span class="hljs-comment">// end of namespace imp</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>=== HandleScope ==============================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
class HandleScope {
  v8::HandleScope scope;

 public:
#if NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION
  inline HandleScope() : scope(v8::Isolate::GetCurrent()) {}
  inline static int NumberOfHandles() {
    return v8::HandleScope::NumberOfHandles(v8::Isolate::GetCurrent());
  }
#else
  inline HandleScope() : scope() {}
  inline static int NumberOfHandles() {
    return v8::HandleScope::NumberOfHandles();
  }
#endif

 private:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Make it hard to create heap-allocated or illegal handle scopes by
disallowing certain operations.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  HandleScope(const HandleScope &amp;);
  void operator=(const HandleScope &amp;);
  void *operator new(size_t size);
  void operator delete(void *, size_t);
};

class EscapableHandleScope {
 public:
#if NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION
  inline EscapableHandleScope() : scope(v8::Isolate::GetCurrent()) {}

  inline static int NumberOfHandles() {
    return v8::EscapableHandleScope::NumberOfHandles(v8::Isolate::GetCurrent());
  }

  template&lt;typename T&gt;
  inline v8::Local&lt;T&gt; Escape(v8::Local&lt;T&gt; value) {
    return scope.Escape(value);
  }

 private:
  v8::EscapableHandleScope scope;
#else
  inline EscapableHandleScope() : scope() {}

  inline static int NumberOfHandles() {
    return v8::HandleScope::NumberOfHandles();
  }

  template&lt;typename T&gt;
  inline v8::Local&lt;T&gt; Escape(v8::Local&lt;T&gt; value) {
    return scope.Close(value);
  }

 private:
  v8::HandleScope scope;
#endif

 private:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Make it hard to create heap-allocated or illegal handle scopes by
disallowing certain operations.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  EscapableHandleScope(<span class="hljs-keyword">const</span> EscapableHandleScope &amp;);
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> EscapableHandleScope &amp;);
  <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">size_t</span>)</span></span>;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>=== TryCatch =================================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
class TryCatch {
  v8::TryCatch try_catch_;
  friend void FatalException(const TryCatch&amp;);

 public:
#if NODE_MODULE_VERSION &gt; NODE_0_12_MODULE_VERSION
  TryCatch() : try_catch_(v8::Isolate::GetCurrent()) {}
#endif

  NAN_INLINE bool HasCaught() const { return try_catch_.HasCaught(); }

  NAN_INLINE bool CanContinue() const { return try_catch_.CanContinue(); }

  NAN_INLINE v8::Local&lt;v8::Value&gt; ReThrow() {
#if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    return New(try_catch_.ReThrow());
#else
    return try_catch_.ReThrow();
#endif
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; Exception() const {
    return try_catch_.Exception();
  }

#if defined(V8_MAJOR_VERSION) &amp;&amp; (V8_MAJOR_VERSION &gt; 4 ||                      \
  (V8_MAJOR_VERSION == 4 &amp;&amp; defined(V8_MINOR_VERSION) &amp;&amp; V8_MINOR_VERSION &gt;= 3))
  NAN_INLINE v8::MaybeLocal&lt;v8::Value&gt; StackTrace() const {
    return try_catch_.StackTrace(GetCurrentContext());
  }
#else
  NAN_INLINE MaybeLocal&lt;v8::Value&gt; StackTrace() const {
    return MaybeLocal&lt;v8::Value&gt;(try_catch_.StackTrace());
  }
#endif

  NAN_INLINE v8::Local&lt;v8::Message&gt; Message() const {
    return try_catch_.Message();
  }

  NAN_INLINE void Reset() { try_catch_.Reset(); }

  NAN_INLINE void SetVerbose(bool value) { try_catch_.SetVerbose(value); }

  NAN_INLINE void SetCaptureMessage(bool value) {
    try_catch_.SetCaptureMessage(value);
  }
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>============ =================================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
/* node 0.12  */
#if NODE_MODULE_VERSION &gt;= NODE_0_12_MODULE_VERSION
  NAN_INLINE
  void SetCounterFunction(v8::CounterLookupCallback cb) {
    v8::Isolate::GetCurrent()-&gt;SetCounterFunction(cb);
  }

  NAN_INLINE
  void SetCreateHistogramFunction(v8::CreateHistogramCallback cb) {
    v8::Isolate::GetCurrent()-&gt;SetCreateHistogramFunction(cb);
  }

  NAN_INLINE
  void SetAddHistogramSampleFunction(v8::AddHistogramSampleCallback cb) {
    v8::Isolate::GetCurrent()-&gt;SetAddHistogramSampleFunction(cb);
  }

#if defined(V8_MAJOR_VERSION) &amp;&amp; (V8_MAJOR_VERSION &gt; 4 ||                      \
  (V8_MAJOR_VERSION == 4 &amp;&amp; defined(V8_MINOR_VERSION) &amp;&amp; V8_MINOR_VERSION &gt;= 3))
  NAN_INLINE bool IdleNotification(int idle_time_in_ms) {
    return v8::Isolate::GetCurrent()-&gt;IdleNotificationDeadline(
        idle_time_in_ms * 0.001);
  }
# else
  NAN_INLINE bool IdleNotification(int idle_time_in_ms) {
    return v8::Isolate::GetCurrent()-&gt;IdleNotification(idle_time_in_ms);
  }
#endif

  NAN_INLINE void LowMemoryNotification() {
    v8::Isolate::GetCurrent()-&gt;LowMemoryNotification();
  }

  NAN_INLINE void ContextDisposedNotification() {
    v8::Isolate::GetCurrent()-&gt;ContextDisposedNotification();
  }
#else
  NAN_INLINE
  void SetCounterFunction(v8::CounterLookupCallback cb) {
    v8::V8::SetCounterFunction(cb);
  }

  NAN_INLINE
  void SetCreateHistogramFunction(v8::CreateHistogramCallback cb) {
    v8::V8::SetCreateHistogramFunction(cb);
  }

  NAN_INLINE
  void SetAddHistogramSampleFunction(v8::AddHistogramSampleCallback cb) {
    v8::V8::SetAddHistogramSampleFunction(cb);
  }

  NAN_INLINE bool IdleNotification(int idle_time_in_ms) {
    return v8::V8::IdleNotification(idle_time_in_ms);
  }

  NAN_INLINE void LowMemoryNotification() {
    v8::V8::LowMemoryNotification();
  }

  NAN_INLINE void ContextDisposedNotification() {
    v8::V8::ContextDisposedNotification();
  }
#endif

#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)  // Node 0.12
  NAN_INLINE v8::Local&lt;v8::Primitive&gt; Undefined() {
# if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(v8::Undefined(v8::Isolate::GetCurrent())));
# else
    return v8::Undefined(v8::Isolate::GetCurrent());
# endif
  }

  NAN_INLINE v8::Local&lt;v8::Primitive&gt; Null() {
# if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(v8::Null(v8::Isolate::GetCurrent())));
# else
    return v8::Null(v8::Isolate::GetCurrent());
# endif
  }

  NAN_INLINE v8::Local&lt;v8::Boolean&gt; True() {
# if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(v8::True(v8::Isolate::GetCurrent())));
# else
    return v8::True(v8::Isolate::GetCurrent());
# endif
  }

  NAN_INLINE v8::Local&lt;v8::Boolean&gt; False() {
# if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(v8::False(v8::Isolate::GetCurrent())));
# else
    return v8::False(v8::Isolate::GetCurrent());
# endif
  }

  NAN_INLINE v8::Local&lt;v8::String&gt; EmptyString() {
    return v8::String::Empty(v8::Isolate::GetCurrent());
  }

  NAN_INLINE int AdjustExternalMemory(int bc) {
    return static_cast&lt;int&gt;(
        v8::Isolate::GetCurrent()-&gt;AdjustAmountOfExternalAllocatedMemory(bc));
  }

  NAN_INLINE void SetTemplate(
      v8::Local&lt;v8::Template&gt; templ
    , const char *name
    , v8::Local&lt;v8::Data&gt; value) {
    templ-&gt;Set(v8::Isolate::GetCurrent(), name, value);
  }

  NAN_INLINE void SetTemplate(
      v8::Local&lt;v8::Template&gt; templ
    , v8::Local&lt;v8::String&gt; name
    , v8::Local&lt;v8::Data&gt; value
    , v8::PropertyAttribute attributes) {
    templ-&gt;Set(name, value, attributes);
  }

  NAN_INLINE v8::Local&lt;v8::Context&gt; GetCurrentContext() {
    return v8::Isolate::GetCurrent()-&gt;GetCurrentContext();
  }

  NAN_INLINE void* GetInternalFieldPointer(
      v8::Local&lt;v8::Object&gt; object
    , int index) {
    return object-&gt;GetAlignedPointerFromInternalField(index);
  }

  NAN_INLINE void SetInternalFieldPointer(
      v8::Local&lt;v8::Object&gt; object
    , int index
    , void* value) {
    object-&gt;SetAlignedPointerInInternalField(index, value);
  }

# define NAN_GC_CALLBACK(name)                                                 \
    void name(v8::Isolate *isolate, v8::GCType type, v8::GCCallbackFlags flags)

#if NODE_MODULE_VERSION &lt;= NODE_4_0_MODULE_VERSION
  typedef v8::Isolate::GCEpilogueCallback GCEpilogueCallback;
  typedef v8::Isolate::GCPrologueCallback GCPrologueCallback;
#else
  typedef v8::Isolate::GCCallback GCEpilogueCallback;
  typedef v8::Isolate::GCCallback GCPrologueCallback;
#endif

  NAN_INLINE void AddGCEpilogueCallback(
      GCEpilogueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::Isolate::GetCurrent()-&gt;AddGCEpilogueCallback(callback, gc_type_filter);
  }

  NAN_INLINE void RemoveGCEpilogueCallback(
      GCEpilogueCallback callback) {
    v8::Isolate::GetCurrent()-&gt;RemoveGCEpilogueCallback(callback);
  }

  NAN_INLINE void AddGCPrologueCallback(
      GCPrologueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::Isolate::GetCurrent()-&gt;AddGCPrologueCallback(callback, gc_type_filter);
  }

  NAN_INLINE void RemoveGCPrologueCallback(
      GCPrologueCallback callback) {
    v8::Isolate::GetCurrent()-&gt;RemoveGCPrologueCallback(callback);
  }

  NAN_INLINE void GetHeapStatistics(
      v8::HeapStatistics *heap_statistics) {
    v8::Isolate::GetCurrent()-&gt;GetHeapStatistics(heap_statistics);
  }

# define X(NAME)                                                               \
    NAN_INLINE v8::Local&lt;v8::Value&gt; NAME(const char *msg) {                    \
      EscapableHandleScope scope;                                              \
      return scope.Escape(v8::Exception::NAME(New(msg).ToLocalChecked()));     \
    }                                                                          \
                                                                               \
    NAN_INLINE                                                                 \
    v8::Local&lt;v8::Value&gt; NAME(v8::Local&lt;v8::String&gt; msg) {                     \
      return v8::Exception::NAME(msg);                                         \
    }                                                                          \
                                                                               \
    NAN_INLINE void Throw ## NAME(const char *msg) {                           \
      HandleScope scope;                                                       \
      v8::Isolate::GetCurrent()-&gt;ThrowException(                               \
          v8::Exception::NAME(New(msg).ToLocalChecked()));                     \
    }                                                                          \
                                                                               \
    NAN_INLINE void Throw ## NAME(v8::Local&lt;v8::String&gt; msg) {                 \
      HandleScope scope;                                                       \
      v8::Isolate::GetCurrent()-&gt;ThrowException(                               \
          v8::Exception::NAME(msg));                                           \
    }

  X(Error)
  X(RangeError)
  X(ReferenceError)
  X(SyntaxError)
  X(TypeError)

# undef X

  NAN_INLINE void ThrowError(v8::Local&lt;v8::Value&gt; error) {
    v8::Isolate::GetCurrent()-&gt;ThrowException(error);
  }

  NAN_INLINE MaybeLocal&lt;v8::Object&gt; NewBuffer(
      char *data
    , size_t length
#if NODE_MODULE_VERSION &gt; IOJS_2_0_MODULE_VERSION
    , node::Buffer::FreeCallback callback
#else
    , node::smalloc::FreeCallback callback
#endif
    , void *hint
  ) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(length &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt; IOJS_2_0_MODULE_VERSION</span>
    <span class="hljs-keyword">return</span> node::Buffer::New(
        v8::Isolate::GetCurrent(), data, length, callback, hint);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(node::Buffer::New(
        v8::Isolate::GetCurrent(), data, length, callback, hint));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  }

  NAN_INLINE MaybeLocal&lt;v8::Object&gt; CopyBuffer(
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data
    , <span class="hljs-keyword">uint32_t</span> size
  ) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(size &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt; IOJS_2_0_MODULE_VERSION</span>
    <span class="hljs-keyword">return</span> node::Buffer::Copy(
        v8::Isolate::GetCurrent(), data, size);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(node::Buffer::New(
        v8::Isolate::GetCurrent(), data, size));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  }

  NAN_INLINE MaybeLocal&lt;v8::Object&gt; NewBuffer(<span class="hljs-keyword">uint32_t</span> size) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(size &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt; IOJS_2_0_MODULE_VERSION</span>
    <span class="hljs-keyword">return</span> node::Buffer::New(
        v8::Isolate::GetCurrent(), size);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(node::Buffer::New(
        v8::Isolate::GetCurrent(), size));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  }

  NAN_INLINE MaybeLocal&lt;v8::Object&gt; NewBuffer(
      <span class="hljs-keyword">char</span>* data
    , <span class="hljs-keyword">uint32_t</span> size
  ) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(size &lt;= imp::kMaxLength &amp;&amp; "too large buffer");
#if NODE_MODULE_VERSION &gt; IOJS_2_0_MODULE_VERSION
    return node::Buffer::New(v8::Isolate::GetCurrent(), data, size);
#else
    return MaybeLocal&lt;v8::Object&gt;(
        node::Buffer::Use(v8::Isolate::GetCurrent(), data, size));
#endif
  }

#if defined(V8_MAJOR_VERSION) &amp;&amp; (V8_MAJOR_VERSION &gt; 4 ||                      \
  (V8_MAJOR_VERSION == 4 &amp;&amp; defined(V8_MINOR_VERSION) &amp;&amp; V8_MINOR_VERSION &gt;= 3))
  NAN_INLINE MaybeLocal&lt;v8::String&gt;
  NewOneByteString(const uint8_t * value, int length = -1) {
    return v8::String::NewFromOneByte(v8::Isolate::GetCurrent(), value,
          v8::NewStringType::kNormal, length);
  }

  NAN_INLINE MaybeLocal&lt;BoundScript&gt; CompileScript(
      v8::Local&lt;v8::String&gt; s
    , const v8::ScriptOrigin&amp; origin
  ) {
    v8::ScriptCompiler::Source source(s, origin);
    return v8::ScriptCompiler::Compile(GetCurrentContext(), &amp;source);
  }

  NAN_INLINE MaybeLocal&lt;BoundScript&gt; CompileScript(
      v8::Local&lt;v8::String&gt; s
  ) {
    v8::ScriptCompiler::Source source(s);
    return v8::ScriptCompiler::Compile(GetCurrentContext(), &amp;source);
  }

  NAN_INLINE MaybeLocal&lt;v8::Value&gt; RunScript(
      v8::Local&lt;UnboundScript&gt; script
  ) {
    return script-&gt;BindToCurrentContext()-&gt;Run(GetCurrentContext());
  }

  NAN_INLINE MaybeLocal&lt;v8::Value&gt; RunScript(
      v8::Local&lt;BoundScript&gt; script
  ) {
    return script-&gt;Run(GetCurrentContext());
  }
#else
  NAN_INLINE MaybeLocal&lt;v8::String&gt;
  NewOneByteString(const uint8_t * value, int length = -1) {
    return MaybeLocal&lt;v8::String&gt;(
        v8::String::NewFromOneByte(
            v8::Isolate::GetCurrent()
          , value
          , v8::String::kNormalString, length));
  }

  NAN_INLINE MaybeLocal&lt;BoundScript&gt; CompileScript(
      v8::Local&lt;v8::String&gt; s
    , const v8::ScriptOrigin&amp; origin
  ) {
    v8::ScriptCompiler::Source source(s, origin);
    return MaybeLocal&lt;BoundScript&gt;(
        v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &amp;source));
  }

  NAN_INLINE MaybeLocal&lt;BoundScript&gt; CompileScript(
      v8::Local&lt;v8::String&gt; s
  ) {
    v8::ScriptCompiler::Source source(s);
    return MaybeLocal&lt;BoundScript&gt;(
        v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &amp;source));
  }

  NAN_INLINE MaybeLocal&lt;v8::Value&gt; RunScript(
      v8::Local&lt;UnboundScript&gt; script
  ) {
    return MaybeLocal&lt;v8::Value&gt;(script-&gt;BindToCurrentContext()-&gt;Run());
  }

  NAN_INLINE MaybeLocal&lt;v8::Value&gt; RunScript(
      v8::Local&lt;BoundScript&gt; script
  ) {
    return MaybeLocal&lt;v8::Value&gt;(script-&gt;Run());
  }
#endif

  NAN_INLINE v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , v8::Local&lt;v8::Function&gt; func
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
#if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    return New(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, func, argc, argv));
#else
    return node::MakeCallback(
        v8::Isolate::GetCurrent(), target, func, argc, argv);
#endif
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , v8::Local&lt;v8::String&gt; symbol
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
#if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    return New(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, symbol, argc, argv));
#else
    return node::MakeCallback(
        v8::Isolate::GetCurrent(), target, symbol, argc, argv);
#endif
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , const char* method
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
#if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    return New(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, method, argc, argv));
#else
    return node::MakeCallback(
        v8::Isolate::GetCurrent(), target, method, argc, argv);
#endif
  }

  NAN_INLINE void FatalException(const TryCatch&amp; try_catch) {
    node::FatalException(v8::Isolate::GetCurrent(), try_catch.try_catch_);
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; ErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) {
    return node::ErrnoException(v8::Isolate::GetCurrent(), errorno, syscall,
            message, path);
  }

  NAN_DEPRECATED NAN_INLINE v8::Local&lt;v8::Value&gt; NanErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) {
    return ErrnoException(errorno, syscall, message, path);
  }

  template&lt;typename T&gt;
  NAN_INLINE void SetIsolateData(
      v8::Isolate *isolate
    , T *data
  ) {
      isolate-&gt;SetData(0, data);
  }

  template&lt;typename T&gt;
  NAN_INLINE T *GetIsolateData(
      v8::Isolate *isolate
  ) {
      return static_cast&lt;T*&gt;(isolate-&gt;GetData(0));
  }

class Utf8String {
 public:
  NAN_INLINE explicit Utf8String(v8::Local&lt;v8::Value&gt; from) :
      length_(0), str_(str_st_) {
    if (!from.IsEmpty()) {
      v8::Local&lt;v8::String&gt; string = from-&gt;ToString();
      if (!string.IsEmpty()) {
        size_t len = 3 * string-&gt;Length() + 1;
        assert(len &lt;= INT_MAX);
        if (len &gt; sizeof (str_st_)) {
          str_ = static_cast&lt;char*&gt;(malloc(len));
          assert(str_ != 0);
        }
        const int flags =
            v8::String::NO_NULL_TERMINATION | imp::kReplaceInvalidUtf8;
        length_ = string-&gt;WriteUtf8(str_, static_cast&lt;int&gt;(len), 0, flags);
        str_[length_] = '\0';
      }
    }
  }

  NAN_INLINE int length() const {
    return length_;
  }

  NAN_INLINE char* operator*() { return str_; }
  NAN_INLINE const char* operator*() const { return str_; }

  NAN_INLINE ~Utf8String() {
    if (str_ != str_st_) {
      free(str_);
    }
  }

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(Utf8String)

  int length_;
  char *str_;
  char str_st_[1024];
};

#else  // Node 0.8 and 0.10
  NAN_INLINE v8::Local&lt;v8::Primitive&gt; Undefined() {
    EscapableHandleScope scope;
    return scope.Escape(New(v8::Undefined()));
  }

  NAN_INLINE v8::Local&lt;v8::Primitive&gt; Null() {
    EscapableHandleScope scope;
    return scope.Escape(New(v8::Null()));
  }

  NAN_INLINE v8::Local&lt;v8::Boolean&gt; True() {
    EscapableHandleScope scope;
    return scope.Escape(New(v8::True()));
  }

  NAN_INLINE v8::Local&lt;v8::Boolean&gt; False() {
    EscapableHandleScope scope;
    return scope.Escape(New(v8::False()));
  }

  NAN_INLINE v8::Local&lt;v8::String&gt; EmptyString() {
    return v8::String::Empty();
  }

  NAN_INLINE int AdjustExternalMemory(int bc) {
    return static_cast&lt;int&gt;(v8::V8::AdjustAmountOfExternalAllocatedMemory(bc));
  }

  NAN_INLINE void SetTemplate(
      v8::Local&lt;v8::Template&gt; templ
    , const char *name
    , v8::Local&lt;v8::Data&gt; value) {
    templ-&gt;Set(name, value);
  }

  NAN_INLINE void SetTemplate(
      v8::Local&lt;v8::Template&gt; templ
    , v8::Local&lt;v8::String&gt; name
    , v8::Local&lt;v8::Data&gt; value
    , v8::PropertyAttribute attributes) {
    templ-&gt;Set(name, value, attributes);
  }

  NAN_INLINE v8::Local&lt;v8::Context&gt; GetCurrentContext() {
    return v8::Context::GetCurrent();
  }

  NAN_INLINE void* GetInternalFieldPointer(
      v8::Local&lt;v8::Object&gt; object
    , int index) {
    return object-&gt;GetPointerFromInternalField(index);
  }

  NAN_INLINE void SetInternalFieldPointer(
      v8::Local&lt;v8::Object&gt; object
    , int index
    , void* value) {
    object-&gt;SetPointerInInternalField(index, value);
  }

# define NAN_GC_CALLBACK(name)                                                 \
    void name(v8::GCType type, v8::GCCallbackFlags flags)

  NAN_INLINE void AddGCEpilogueCallback(
    v8::GCEpilogueCallback callback
  , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::V8::AddGCEpilogueCallback(callback, gc_type_filter);
  }
  NAN_INLINE void RemoveGCEpilogueCallback(
    v8::GCEpilogueCallback callback) {
    v8::V8::RemoveGCEpilogueCallback(callback);
  }
  NAN_INLINE void AddGCPrologueCallback(
    v8::GCPrologueCallback callback
  , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::V8::AddGCPrologueCallback(callback, gc_type_filter);
  }
  NAN_INLINE void RemoveGCPrologueCallback(
    v8::GCPrologueCallback callback) {
    v8::V8::RemoveGCPrologueCallback(callback);
  }
  NAN_INLINE void GetHeapStatistics(
    v8::HeapStatistics *heap_statistics) {
    v8::V8::GetHeapStatistics(heap_statistics);
  }

# define X(NAME)                                                               \
    NAN_INLINE v8::Local&lt;v8::Value&gt; NAME(const char *msg) {                    \
      EscapableHandleScope scope;                                              \
      return scope.Escape(v8::Exception::NAME(New(msg).ToLocalChecked()));     \
    }                                                                          \
                                                                               \
    NAN_INLINE                                                                 \
    v8::Local&lt;v8::Value&gt; NAME(v8::Local&lt;v8::String&gt; msg) {                     \
      return v8::Exception::NAME(msg);                                         \
    }                                                                          \
                                                                               \
    NAN_INLINE void Throw ## NAME(const char *msg) {                           \
      HandleScope scope;                                                       \
      v8::ThrowException(v8::Exception::NAME(New(msg).ToLocalChecked()));      \
    }                                                                          \
                                                                               \
    NAN_INLINE                                                                 \
    void Throw ## NAME(v8::Local&lt;v8::String&gt; errmsg) {                         \
      v8::ThrowException(v8::Exception::NAME(errmsg));                         \
    }

  X(Error)
  X(RangeError)
  X(ReferenceError)
  X(SyntaxError)
  X(TypeError)

# undef X

  NAN_INLINE void ThrowError(v8::Local&lt;v8::Value&gt; error) {
    v8::ThrowException(error);
  }

  NAN_INLINE MaybeLocal&lt;v8::Object&gt; NewBuffer(
      char *data
    , size_t length
    , node::Buffer::free_callback callback
    , void *hint
  ) {
    EscapableHandleScope scope;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(length &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(scope.Escape(
        New(node::Buffer::New(data, length, callback, hint)-&gt;handle_)));
  }

  NAN_INLINE MaybeLocal&lt;v8::Object&gt; CopyBuffer(
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data
    , <span class="hljs-keyword">uint32_t</span> size
  ) {
    EscapableHandleScope scope;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(size &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt;= NODE_0_10_MODULE_VERSION</span>
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(
        scope.Escape(New(node::Buffer::New(data, size)-&gt;handle_)));
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(scope.Escape(
        New(node::Buffer::New(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(data), size)-&gt;handle_)));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  }

  NAN_INLINE MaybeLocal&lt;v8::Object&gt; NewBuffer(<span class="hljs-keyword">uint32_t</span> size) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    EscapableHandleScope scope;
    assert(size &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(
        scope.Escape(New(node::Buffer::New(size)-&gt;handle_)));
  }

  <span class="hljs-function">NAN_INLINE <span class="hljs-keyword">void</span> <span class="hljs-title">FreeData</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">void</span> *hint)</span> </span>{
    (<span class="hljs-keyword">void</span>) hint;  <span class="hljs-comment">// unused</span>
    <span class="hljs-keyword">delete</span>[] data;
  }

  NAN_INLINE MaybeLocal&lt;v8::Object&gt; NewBuffer(
      <span class="hljs-keyword">char</span>* data
    , <span class="hljs-keyword">uint32_t</span> size
  ) {
    EscapableHandleScope scope;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(size &lt;= imp::kMaxLength &amp;&amp; "too large buffer");
    return MaybeLocal&lt;v8::Object&gt;(scope.Escape(New(
        node::Buffer::New(data, size, FreeData, NULL)-&gt;handle_)));
  }

namespace imp {
NAN_INLINE void
widenString(std::vector&lt;uint16_t&gt; *ws, const uint8_t *s, int l) {
  size_t len = static_cast&lt;size_t&gt;(l);
  if (l &lt; 0) {
    len = strlen(reinterpret_cast&lt;const char*&gt;(s));
  }
  assert(len &lt;= INT_MAX &amp;&amp; "string too long");
  ws-&gt;resize(len);
  std::copy(s, s + len, ws-&gt;begin());  // NOLINT(build/include_what_you_use)
}
}  // end of namespace imp

  NAN_INLINE MaybeLocal&lt;v8::String&gt;
  NewOneByteString(const uint8_t * value, int length = -1) {
    std::vector&lt;uint16_t&gt; wideString;  // NOLINT(build/include_what_you_use)
    imp::widenString(&amp;wideString, value, length);
    return imp::Factory&lt;v8::String&gt;::return_t(v8::String::New(
        &amp;wideString.front(), static_cast&lt;int&gt;(wideString.size())));
  }

  NAN_INLINE MaybeLocal&lt;BoundScript&gt; CompileScript(
      v8::Local&lt;v8::String&gt; s
    , const v8::ScriptOrigin&amp; origin
  ) {
    return MaybeLocal&lt;BoundScript&gt;(
        v8::Script::Compile(s, const_cast&lt;v8::ScriptOrigin *&gt;(&amp;origin)));
  }

  NAN_INLINE MaybeLocal&lt;BoundScript&gt; CompileScript(
    v8::Local&lt;v8::String&gt; s
  ) {
    return MaybeLocal&lt;BoundScript&gt;(v8::Script::Compile(s));
  }

  NAN_INLINE
  MaybeLocal&lt;v8::Value&gt; RunScript(v8::Local&lt;v8::Script&gt; script) {
    return MaybeLocal&lt;v8::Value&gt;(script-&gt;Run());
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , v8::Local&lt;v8::Function&gt; func
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
    return New(node::MakeCallback(target, func, argc, argv));
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , v8::Local&lt;v8::String&gt; symbol
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
    return New(node::MakeCallback(target, symbol, argc, argv));
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , const char* method
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
    return New(node::MakeCallback(target, method, argc, argv));
  }

  NAN_INLINE void FatalException(const TryCatch&amp; try_catch) {
    node::FatalException(const_cast&lt;v8::TryCatch &amp;&gt;(try_catch.try_catch_));
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; ErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) {
    return node::ErrnoException(errorno, syscall, message, path);
  }

  NAN_DEPRECATED NAN_INLINE v8::Local&lt;v8::Value&gt; NanErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) {
    return ErrnoException(errorno, syscall, message, path);
  }


  template&lt;typename T&gt;
  NAN_INLINE void SetIsolateData(
      v8::Isolate *isolate
    , T *data
  ) {
      isolate-&gt;SetData(data);
  }

  template&lt;typename T&gt;
  NAN_INLINE T *GetIsolateData(
      v8::Isolate *isolate
  ) {
      return static_cast&lt;T*&gt;(isolate-&gt;GetData());
  }

class Utf8String {
 public:
  NAN_INLINE explicit Utf8String(v8::Local&lt;v8::Value&gt; from) :
      length_(0), str_(str_st_) {
    if (!from.IsEmpty()) {
      v8::Local&lt;v8::String&gt; string = from-&gt;ToString();
      if (!string.IsEmpty()) {
        size_t len = 3 * string-&gt;Length() + 1;
        assert(len &lt;= INT_MAX);
        if (len &gt; sizeof (str_st_)) {
          str_ = static_cast&lt;char*&gt;(malloc(len));
          assert(str_ != 0);
        }
        const int flags =
            v8::String::NO_NULL_TERMINATION | imp::kReplaceInvalidUtf8;
        length_ = string-&gt;WriteUtf8(str_, static_cast&lt;int&gt;(len), 0, flags);
        str_[length_] = '\0';
      }
    }
  }

  NAN_INLINE int length() const {
    return length_;
  }

  NAN_INLINE char* operator*() { return str_; }
  NAN_INLINE const char* operator*() const { return str_; }

  NAN_INLINE ~Utf8String() {
    if (str_ != str_st_) {
      free(str_);
    }
  }

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(Utf8String)

  int length_;
  char *str_;
  char str_st_[1024];
};

#endif  // NODE_MODULE_VERSION

typedef void (*FreeCallback)(char *data, void *hint);

typedef const FunctionCallbackInfo&lt;v8::Value&gt;&amp; NAN_METHOD_ARGS_TYPE;
typedef void NAN_METHOD_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Value&gt;&amp; NAN_GETTER_ARGS_TYPE;
typedef void NAN_GETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;void&gt;&amp; NAN_SETTER_ARGS_TYPE;
typedef void NAN_SETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Value&gt;&amp;
    NAN_PROPERTY_GETTER_ARGS_TYPE;
typedef void NAN_PROPERTY_GETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Value&gt;&amp;
    NAN_PROPERTY_SETTER_ARGS_TYPE;
typedef void NAN_PROPERTY_SETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Array&gt;&amp;
    NAN_PROPERTY_ENUMERATOR_ARGS_TYPE;
typedef void NAN_PROPERTY_ENUMERATOR_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Boolean&gt;&amp;
    NAN_PROPERTY_DELETER_ARGS_TYPE;
typedef void NAN_PROPERTY_DELETER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Integer&gt;&amp;
    NAN_PROPERTY_QUERY_ARGS_TYPE;
typedef void NAN_PROPERTY_QUERY_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Value&gt;&amp; NAN_INDEX_GETTER_ARGS_TYPE;
typedef void NAN_INDEX_GETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Value&gt;&amp; NAN_INDEX_SETTER_ARGS_TYPE;
typedef void NAN_INDEX_SETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Array&gt;&amp;
    NAN_INDEX_ENUMERATOR_ARGS_TYPE;
typedef void NAN_INDEX_ENUMERATOR_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Boolean&gt;&amp;
    NAN_INDEX_DELETER_ARGS_TYPE;
typedef void NAN_INDEX_DELETER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Integer&gt;&amp;
    NAN_INDEX_QUERY_ARGS_TYPE;
typedef void NAN_INDEX_QUERY_RETURN_TYPE;

#define NAN_METHOD(name)                                                       \
    Nan::NAN_METHOD_RETURN_TYPE name(Nan::NAN_METHOD_ARGS_TYPE info)
#define NAN_GETTER(name)                                                       \
    Nan::NAN_GETTER_RETURN_TYPE name(                                          \
        v8::Local&lt;v8::String&gt; property                                         \
      , Nan::NAN_GETTER_ARGS_TYPE info)
#define NAN_SETTER(name)                                                       \
    Nan::NAN_SETTER_RETURN_TYPE name(                                          \
        v8::Local&lt;v8::String&gt; property                                         \
      , v8::Local&lt;v8::Value&gt; value                                             \
      , Nan::NAN_SETTER_ARGS_TYPE info)
#define NAN_PROPERTY_GETTER(name)                                              \
    Nan::NAN_PROPERTY_GETTER_RETURN_TYPE name(                                 \
        v8::Local&lt;v8::String&gt; property                                         \
      , Nan::NAN_PROPERTY_GETTER_ARGS_TYPE info)
#define NAN_PROPERTY_SETTER(name)                                              \
    Nan::NAN_PROPERTY_SETTER_RETURN_TYPE name(                                 \
        v8::Local&lt;v8::String&gt; property                                         \
      , v8::Local&lt;v8::Value&gt; value                                             \
      , Nan::NAN_PROPERTY_SETTER_ARGS_TYPE info)
#define NAN_PROPERTY_ENUMERATOR(name)                                          \
    Nan::NAN_PROPERTY_ENUMERATOR_RETURN_TYPE name(                             \
        Nan::NAN_PROPERTY_ENUMERATOR_ARGS_TYPE info)
#define NAN_PROPERTY_DELETER(name)                                             \
    Nan::NAN_PROPERTY_DELETER_RETURN_TYPE name(                                \
        v8::Local&lt;v8::String&gt; property                                         \
      , Nan::NAN_PROPERTY_DELETER_ARGS_TYPE info)
#define NAN_PROPERTY_QUERY(name)                                               \
    Nan::NAN_PROPERTY_QUERY_RETURN_TYPE name(                                  \
        v8::Local&lt;v8::String&gt; property                                         \
      , Nan::NAN_PROPERTY_QUERY_ARGS_TYPE info)
# define NAN_INDEX_GETTER(name)                                                \
    Nan::NAN_INDEX_GETTER_RETURN_TYPE name(                                    \
        uint32_t index                                                         \
      , Nan::NAN_INDEX_GETTER_ARGS_TYPE info)
#define NAN_INDEX_SETTER(name)                                                 \
    Nan::NAN_INDEX_SETTER_RETURN_TYPE name(                                    \
        uint32_t index                                                         \
      , v8::Local&lt;v8::Value&gt; value                                             \
      , Nan::NAN_INDEX_SETTER_ARGS_TYPE info)
#define NAN_INDEX_ENUMERATOR(name)                                             \
    Nan::NAN_INDEX_ENUMERATOR_RETURN_TYPE                                      \
    name(Nan::NAN_INDEX_ENUMERATOR_ARGS_TYPE info)
#define NAN_INDEX_DELETER(name)                                                \
    Nan::NAN_INDEX_DELETER_RETURN_TYPE name(                                   \
        uint32_t index                                                         \
      , Nan::NAN_INDEX_DELETER_ARGS_TYPE info)
#define NAN_INDEX_QUERY(name)                                                  \
    Nan::NAN_INDEX_QUERY_RETURN_TYPE name(                                     \
        uint32_t index                                                         \
      , Nan::NAN_INDEX_QUERY_ARGS_TYPE info)

class Callback {
 public:
  Callback() {
    HandleScope scope;
    v8::Local&lt;v8::Object&gt; obj = New&lt;v8::Object&gt;();
    handle.Reset(obj);
  }

  explicit Callback(const v8::Local&lt;v8::Function&gt; &amp;fn) {
    HandleScope scope;
    v8::Local&lt;v8::Object&gt; obj = New&lt;v8::Object&gt;();
    handle.Reset(obj);
    SetFunction(fn);
  }

  ~Callback() {
    if (handle.IsEmpty()) return;
    handle.Reset();
  }

  bool operator==(const Callback &amp;other) const {
    HandleScope scope;
    v8::Local&lt;v8::Value&gt; a = New(handle)-&gt;Get(kCallbackIndex);
    v8::Local&lt;v8::Value&gt; b = New(other.handle)-&gt;Get(kCallbackIndex);
    return a-&gt;StrictEquals(b);
  }

  bool operator!=(const Callback &amp;other) const {
    return !this-&gt;operator==(other);
  }

  NAN_INLINE
  v8::Local&lt;v8::Function&gt; operator*() const { return this-&gt;GetFunction(); }

  NAN_INLINE v8::Local&lt;v8::Value&gt; operator()(
      v8::Local&lt;v8::Object&gt; target
    , int argc = 0
    , v8::Local&lt;v8::Value&gt; argv[] = 0) const {
    return this-&gt;Call(target, argc, argv);
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; operator()(
      int argc = 0
    , v8::Local&lt;v8::Value&gt; argv[] = 0) const {
    return this-&gt;Call(argc, argv);
  }

  NAN_INLINE void SetFunction(const v8::Local&lt;v8::Function&gt; &amp;fn) {
    HandleScope scope;
    Set(New(handle), kCallbackIndex, fn);
  }

  NAN_INLINE v8::Local&lt;v8::Function&gt; GetFunction() const {
    EscapableHandleScope scope;
    return scope.Escape(New(handle)-&gt;Get(kCallbackIndex)
        .As&lt;v8::Function&gt;());
  }

  NAN_INLINE bool IsEmpty() const {
    HandleScope scope;
    return New(handle)-&gt;Get(kCallbackIndex)-&gt;IsUndefined();
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt;
  Call(v8::Local&lt;v8::Object&gt; target
     , int argc
     , v8::Local&lt;v8::Value&gt; argv[]) const {
#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    return Call_(isolate, target, argc, argv);
#else
    return Call_(target, argc, argv);
#endif
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt;
  Call(int argc, v8::Local&lt;v8::Value&gt; argv[]) const {
#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    return Call_(isolate, isolate-&gt;GetCurrentContext()-&gt;Global(), argc, argv);
#else
    return Call_(v8::Context::GetCurrent()-&gt;Global(), argc, argv);
#endif
  }

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(Callback)
  Persistent&lt;v8::Object&gt; handle;
  static const uint32_t kCallbackIndex = 0;

#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
  v8::Local&lt;v8::Value&gt; Call_(v8::Isolate *isolate
                           , v8::Local&lt;v8::Object&gt; target
                           , int argc
                           , v8::Local&lt;v8::Value&gt; argv[]) const {
    EscapableHandleScope scope;

    v8::Local&lt;v8::Function&gt; callback = New(handle)-&gt;
        Get(kCallbackIndex).As&lt;v8::Function&gt;();
# if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    return scope.Escape(New(node::MakeCallback(
        isolate
      , target
      , callback
      , argc
      , argv
    )));
# else
    return scope.Escape(node::MakeCallback(
        isolate
      , target
      , callback
      , argc
      , argv
    ));
# endif
  }
#else
  v8::Local&lt;v8::Value&gt; Call_(v8::Local&lt;v8::Object&gt; target
                           , int argc
                           , v8::Local&lt;v8::Value&gt; argv[]) const {
    EscapableHandleScope scope;

    v8::Local&lt;v8::Function&gt; callback = New(handle)-&gt;
        Get(kCallbackIndex).As&lt;v8::Function&gt;();
    return scope.Escape(New(node::MakeCallback(
        target
      , callback
      , argc
      , argv
    )));
  }
#endif
};

/* abstract */ class AsyncWorker {
 public:
  explicit AsyncWorker(Callback *callback_)
      : callback(callback_), errmsg_(NULL) {
    request.data = this;

    HandleScope scope;
    v8::Local&lt;v8::Object&gt; obj = New&lt;v8::Object&gt;();
    persistentHandle.Reset(obj);
  }

  virtual ~AsyncWorker() {
    HandleScope scope;

    if (!persistentHandle.IsEmpty())
      persistentHandle.Reset();
    delete callback;
    delete[] errmsg_;
  }

  virtual void WorkComplete() {
    HandleScope scope;

    if (errmsg_ == NULL)
      HandleOKCallback();
    else
      HandleErrorCallback();
    delete callback;
    callback = NULL;
  }

  NAN_INLINE void SaveToPersistent(
      const char *key, const v8::Local&lt;v8::Value&gt; &amp;value) {
    HandleScope scope;
    New(persistentHandle)-&gt;Set(New(key).ToLocalChecked(), value);
  }

  NAN_INLINE void SaveToPersistent(
      const v8::Local&lt;v8::String&gt; &amp;key, const v8::Local&lt;v8::Value&gt; &amp;value) {
    HandleScope scope;
    New(persistentHandle)-&gt;Set(key, value);
  }

  NAN_INLINE void SaveToPersistent(
      uint32_t index, const v8::Local&lt;v8::Value&gt; &amp;value) {
    HandleScope scope;
    New(persistentHandle)-&gt;Set(index, value);
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; GetFromPersistent(const char *key) const {
    EscapableHandleScope scope;
    return scope.Escape(
        New(persistentHandle)-&gt;Get(New(key).ToLocalChecked()));
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt;
  GetFromPersistent(const v8::Local&lt;v8::String&gt; &amp;key) const {
    EscapableHandleScope scope;
    return scope.Escape(New(persistentHandle)-&gt;Get(key));
  }

  NAN_INLINE v8::Local&lt;v8::Value&gt; GetFromPersistent(uint32_t index) const {
    EscapableHandleScope scope;
    return scope.Escape(New(persistentHandle)-&gt;Get(index));
  }

  virtual void Execute() = 0;

  uv_work_t request;

  virtual void Destroy() {
      delete this;
  }

 protected:
  Persistent&lt;v8::Object&gt; persistentHandle;
  Callback *callback;

  virtual void HandleOKCallback() {
    callback-&gt;Call(0, NULL);
  }

  virtual void HandleErrorCallback() {
    HandleScope scope;

    v8::Local&lt;v8::Value&gt; argv[] = {
      v8::Exception::Error(New&lt;v8::String&gt;(ErrorMessage()).ToLocalChecked())
    };
    callback-&gt;Call(1, argv);
  }

  void SetErrorMessage(const char *msg) {
    delete[] errmsg_;

    size_t size = strlen(msg) + 1;
    errmsg_ = new char[size];
    memcpy(errmsg_, msg, size);
  }

  const char* ErrorMessage() const {
    return errmsg_;
  }

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(AsyncWorker)
  char *errmsg_;
};

/* abstract */ class AsyncProgressWorker : public AsyncWorker {
 public:
  explicit AsyncProgressWorker(Callback *callback_)
      : AsyncWorker(callback_), asyncdata_(NULL), asyncsize_(0) {
    async = new uv_async_t;
    uv_async_init(
        uv_default_loop()
      , async
      , AsyncProgress_
    );
    async-&gt;data = this;

    uv_mutex_init(&amp;async_lock);
  }

  virtual ~AsyncProgressWorker() {
    uv_mutex_destroy(&amp;async_lock);

    delete[] asyncdata_;
  }

  void WorkProgress() {
    uv_mutex_lock(&amp;async_lock);
    char *data = asyncdata_;
    size_t size = asyncsize_;
    asyncdata_ = NULL;
    uv_mutex_unlock(&amp;async_lock);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>Dont send progress events after we've already completed.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-keyword">if</span> (callback) {
        HandleProgressCallback(data, size);
    }
    <span class="hljs-keyword">delete</span>[] data;
  }

  <span class="hljs-keyword">class</span> ExecutionProgress {
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> AsyncProgressWorker;
   <span class="hljs-keyword">public</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>You could do fancy generics with templates here.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    void Send(const char* data, size_t size) const {
        that_-&gt;SendProgress_(data, size);
    }

   private:
    explicit ExecutionProgress(AsyncProgressWorker* that) : that_(that) {}
    NAN_DISALLOW_ASSIGN_COPY_MOVE(ExecutionProgress)
    AsyncProgressWorker* const that_;
  };

  virtual void Execute(const ExecutionProgress&amp; progress) = 0;
  virtual void HandleProgressCallback(const char *data, size_t size) = 0;

  virtual void Destroy() {
      uv_close(reinterpret_cast&lt;uv_handle_t*&gt;(async), AsyncClose_);
  }

 private:
  void Execute() /*final override*/ {
      ExecutionProgress progress(this);
      Execute(progress);
  }

  void SendProgress_(const char *data, size_t size) {
    char *new_data = new char[size];
    memcpy(new_data, data, size);

    uv_mutex_lock(&amp;async_lock);
    char *old_data = asyncdata_;
    asyncdata_ = new_data;
    asyncsize_ = size;
    uv_mutex_unlock(&amp;async_lock);

    delete[] old_data;
    uv_async_send(async);
  }

  NAN_INLINE static NAUV_WORK_CB(AsyncProgress_) {
    AsyncProgressWorker *worker =
            static_cast&lt;AsyncProgressWorker*&gt;(async-&gt;data);
    worker-&gt;WorkProgress();
  }

  NAN_INLINE static void AsyncClose_(uv_handle_t* handle) {
    AsyncProgressWorker *worker =
            static_cast&lt;AsyncProgressWorker*&gt;(handle-&gt;data);
    delete reinterpret_cast&lt;uv_async_t*&gt;(handle);
    delete worker;
  }

  uv_async_t *async;
  uv_mutex_t async_lock;
  char *asyncdata_;
  size_t asyncsize_;
};

NAN_INLINE void AsyncExecute (uv_work_t* req) {
  AsyncWorker *worker = static_cast&lt;AsyncWorker*&gt;(req-&gt;data);
  worker-&gt;Execute();
}

NAN_INLINE void AsyncExecuteComplete (uv_work_t* req) {
  AsyncWorker* worker = static_cast&lt;AsyncWorker*&gt;(req-&gt;data);
  worker-&gt;WorkComplete();
  worker-&gt;Destroy();
}

NAN_INLINE void AsyncQueueWorker (AsyncWorker* worker) {
  uv_queue_work(
      uv_default_loop()
    , &amp;worker-&gt;request
    , AsyncExecute
    , reinterpret_cast&lt;uv_after_work_cb&gt;(AsyncExecuteComplete)
  );
}

namespace imp {

inline
ExternalOneByteStringResource const*
GetExternalResource(v8::Local&lt;v8::String&gt; str) {
#if NODE_MODULE_VERSION &lt; ATOM_0_21_MODULE_VERSION
    return str-&gt;GetExternalAsciiStringResource();
#else
    return str-&gt;GetExternalOneByteStringResource();
#endif
}

inline
bool
IsExternal(v8::Local&lt;v8::String&gt; str) {
#if NODE_MODULE_VERSION &lt; ATOM_0_21_MODULE_VERSION
    return str-&gt;IsExternalAscii();
#else
    return str-&gt;IsExternalOneByte();
#endif
}

}  // end of namespace imp

enum Encoding {ASCII, UTF8, BASE64, UCS2, BINARY, HEX, BUFFER};

#if NODE_MODULE_VERSION &lt; NODE_0_10_MODULE_VERSION
# include "nan_string_bytes.h"  // NOLINT(build/include)
#endif

NAN_INLINE v8::Local&lt;v8::Value&gt; Encode(
    const void *buf, size_t len, enum Encoding encoding = BINARY) {
#if (NODE_MODULE_VERSION &gt;= ATOM_0_21_MODULE_VERSION)
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  node::encoding node_enc = static_cast&lt;node::encoding&gt;(encoding);

  if (encoding == UCS2) {
    return node::Encode(
        isolate
      , reinterpret_cast&lt;const uint16_t *&gt;(buf)
      , len / 2);
  } else {
    return node::Encode(
        isolate
      , reinterpret_cast&lt;const char *&gt;(buf)
      , len
      , node_enc);
  }
#elif (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
  return node::Encode(
      v8::Isolate::GetCurrent()
    , buf, len
    , static_cast&lt;node::encoding&gt;(encoding));
#else
# if NODE_MODULE_VERSION &gt;= NODE_0_10_MODULE_VERSION
  return node::Encode(buf, len, static_cast&lt;node::encoding&gt;(encoding));
# else
  return imp::Encode(reinterpret_cast&lt;const char*&gt;(buf), len, encoding);
# endif
#endif
}

NAN_INLINE ssize_t DecodeBytes(
    v8::Local&lt;v8::Value&gt; val, enum Encoding encoding = BINARY) {
#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
  return node::DecodeBytes(
      v8::Isolate::GetCurrent()
    , val
    , static_cast&lt;node::encoding&gt;(encoding));
#else
# if (NODE_MODULE_VERSION &lt; NODE_0_10_MODULE_VERSION)
  if (encoding == BUFFER) {
    return node::DecodeBytes(val, node::BINARY);
  }
# endif
  return node::DecodeBytes(val, static_cast&lt;node::encoding&gt;(encoding));
#endif
}

NAN_INLINE ssize_t DecodeWrite(
    char *buf
  , size_t len
  , v8::Local&lt;v8::Value&gt; val
  , enum Encoding encoding = BINARY) {
#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
  return node::DecodeWrite(
      v8::Isolate::GetCurrent()
    , buf
    , len
    , val
    , static_cast&lt;node::encoding&gt;(encoding));
#else
# if (NODE_MODULE_VERSION &lt; NODE_0_10_MODULE_VERSION)
  if (encoding == BUFFER) {
    return node::DecodeWrite(buf, len, val, node::BINARY);
  }
# endif
  return node::DecodeWrite(
      buf
    , len
    , val
    , static_cast&lt;node::encoding&gt;(encoding));
#endif
}

NAN_INLINE void SetPrototypeTemplate(
    v8::Local&lt;v8::FunctionTemplate&gt; templ
  , const char *name
  , v8::Local&lt;v8::Data&gt; value
) {
  SetTemplate(templ-&gt;PrototypeTemplate(), name, value);
}

NAN_INLINE void SetPrototypeTemplate(
    v8::Local&lt;v8::FunctionTemplate&gt; templ
  , v8::Local&lt;v8::String&gt; name
  , v8::Local&lt;v8::Data&gt; value
  , v8::PropertyAttribute attributes
) {
  SetTemplate(templ-&gt;PrototypeTemplate(), name, value, attributes);
}

NAN_INLINE void SetInstanceTemplate(
    v8::Local&lt;v8::FunctionTemplate&gt; templ
  , const char *name
  , v8::Local&lt;v8::Data&gt; value
) {
  SetTemplate(templ-&gt;InstanceTemplate(), name, value);
}

NAN_INLINE void SetInstanceTemplate(
    v8::Local&lt;v8::FunctionTemplate&gt; templ
  , v8::Local&lt;v8::String&gt; name
  , v8::Local&lt;v8::Data&gt; value
  , v8::PropertyAttribute attributes
) {
  SetTemplate(templ-&gt;InstanceTemplate(), name, value, attributes);
}

template&lt;typename T&gt;
NAN_INLINE void SetMethod(
    const T &amp;recv
  , const char *name
  , FunctionCallback callback) {
  HandleScope scope;
  v8::Local&lt;v8::Function&gt; fn = GetFunction(New&lt;v8::FunctionTemplate&gt;(
      callback)).ToLocalChecked();
  v8::Local&lt;v8::String&gt; fn_name = New(name).ToLocalChecked();
  fn-&gt;SetName(fn_name);
  recv-&gt;Set(fn_name, fn);
}

NAN_INLINE void SetPrototypeMethod(
    v8::Local&lt;v8::FunctionTemplate&gt; recv
  , const char* name, FunctionCallback callback) {
  HandleScope scope;
  v8::Local&lt;v8::Function&gt; fn = GetFunction(New&lt;v8::FunctionTemplate&gt;(
      callback
    , v8::Local&lt;v8::Value&gt;()
    , New&lt;v8::Signature&gt;(recv))).ToLocalChecked();
  v8::Local&lt;v8::String&gt; fn_name = New(name).ToLocalChecked();
  recv-&gt;PrototypeTemplate()-&gt;Set(fn_name, fn);
  fn-&gt;SetName(fn_name);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>=== Accessors and Such =======================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
inline void SetAccessor(
    v8::Local&lt;v8::ObjectTemplate&gt; tpl
  , v8::Local&lt;v8::String&gt; name
  , GetterCallback getter
  , SetterCallback setter = 0
  , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()
  , v8::AccessControl settings = v8::DEFAULT
  , v8::PropertyAttribute attribute = v8::None
  , imp::Sig signature = imp::Sig()) {
  HandleScope scope;

  imp::NativeGetter getter_ =
      imp::GetterCallbackWrapper;
  imp::NativeSetter setter_ =
      setter ? imp::SetterCallbackWrapper : 0;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kAccessorFieldCount);
  v8::Local&lt;v8::Object&gt; obj = NewInstance(otpl).ToLocalChecked();

  obj-&gt;SetInternalField(
      imp::kGetterIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(getter)));

  if (setter != 0) {
    obj-&gt;SetInternalField(
        imp::kSetterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(setter)));
  }

  if (!data.IsEmpty()) {
    obj-&gt;SetInternalField(imp::kDataIndex, data);
  }

  tpl-&gt;SetAccessor(
      name
    , getter_
    , setter_
    , obj
    , settings
    , attribute
    , signature);
}

inline bool SetAccessor(
    v8::Local&lt;v8::Object&gt; obj
  , v8::Local&lt;v8::String&gt; name
  , GetterCallback getter
  , SetterCallback setter = 0
  , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()
  , v8::AccessControl settings = v8::DEFAULT
  , v8::PropertyAttribute attribute = v8::None) {
  EscapableHandleScope scope;

  imp::NativeGetter getter_ =
      imp::GetterCallbackWrapper;
  imp::NativeSetter setter_ =
      setter ? imp::SetterCallbackWrapper : 0;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kAccessorFieldCount);
  v8::Local&lt;v8::Object&gt; dataobj = NewInstance(otpl).ToLocalChecked();

  dataobj-&gt;SetInternalField(
      imp::kGetterIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(getter)));

  if (!data.IsEmpty()) {
    dataobj-&gt;SetInternalField(imp::kDataIndex, data);
  }

  if (setter) {
    dataobj-&gt;SetInternalField(
        imp::kSetterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(setter)));
  }

  return obj-&gt;SetAccessor(
      name
    , getter_
    , setter_
    , dataobj
    , settings
    , attribute);
}

inline void SetNamedPropertyHandler(
    v8::Local&lt;v8::ObjectTemplate&gt; tpl
  , PropertyGetterCallback getter
  , PropertySetterCallback setter = 0
  , PropertyQueryCallback query = 0
  , PropertyDeleterCallback deleter = 0
  , PropertyEnumeratorCallback enumerator = 0
  , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()) {
  HandleScope scope;

  imp::NativePropertyGetter getter_ =
      imp::PropertyGetterCallbackWrapper;
  imp::NativePropertySetter setter_ =
      setter ? imp::PropertySetterCallbackWrapper : 0;
  imp::NativePropertyQuery query_ =
      query ? imp::PropertyQueryCallbackWrapper : 0;
  imp::NativePropertyDeleter *deleter_ =
      deleter ? imp::PropertyDeleterCallbackWrapper : 0;
  imp::NativePropertyEnumerator enumerator_ =
      enumerator ? imp::PropertyEnumeratorCallbackWrapper : 0;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kPropertyFieldCount);
  v8::Local&lt;v8::Object&gt; obj = NewInstance(otpl).ToLocalChecked();
  obj-&gt;SetInternalField(
      imp::kPropertyGetterIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(getter)));

  if (setter) {
    obj-&gt;SetInternalField(
        imp::kPropertySetterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(setter)));
  }

  if (query) {
    obj-&gt;SetInternalField(
        imp::kPropertyQueryIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(query)));
  }

  if (deleter) {
    obj-&gt;SetInternalField(
        imp::kPropertyDeleterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(deleter)));
  }

  if (enumerator) {
    obj-&gt;SetInternalField(
        imp::kPropertyEnumeratorIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(enumerator)));
  }

  if (!data.IsEmpty()) {
    obj-&gt;SetInternalField(imp::kDataIndex, data);
  }

#if NODE_MODULE_VERSION &gt; NODE_0_12_MODULE_VERSION
  tpl-&gt;SetHandler(v8::NamedPropertyHandlerConfiguration(
      getter_, setter_, query_, deleter_, enumerator_, obj));
#else
  tpl-&gt;SetNamedPropertyHandler(
      getter_
    , setter_
    , query_
    , deleter_
    , enumerator_
    , obj);
#endif
}

inline void SetIndexedPropertyHandler(
    v8::Local&lt;v8::ObjectTemplate&gt; tpl
  , IndexGetterCallback getter
  , IndexSetterCallback setter = 0
  , IndexQueryCallback query = 0
  , IndexDeleterCallback deleter = 0
  , IndexEnumeratorCallback enumerator = 0
  , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()) {
  HandleScope scope;

  imp::NativeIndexGetter getter_ =
      imp::IndexGetterCallbackWrapper;
  imp::NativeIndexSetter setter_ =
      setter ? imp::IndexSetterCallbackWrapper : 0;
  imp::NativeIndexQuery query_ =
      query ? imp::IndexQueryCallbackWrapper : 0;
  imp::NativeIndexDeleter deleter_ =
      deleter ? imp::IndexDeleterCallbackWrapper : 0;
  imp::NativeIndexEnumerator enumerator_ =
      enumerator ? imp::IndexEnumeratorCallbackWrapper : 0;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kIndexPropertyFieldCount);
  v8::Local&lt;v8::Object&gt; obj = NewInstance(otpl).ToLocalChecked();
  obj-&gt;SetInternalField(
      imp::kIndexPropertyGetterIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(getter)));

  if (setter) {
    obj-&gt;SetInternalField(
        imp::kIndexPropertySetterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(setter)));
  }

  if (query) {
    obj-&gt;SetInternalField(
        imp::kIndexPropertyQueryIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(query)));
  }

  if (deleter) {
    obj-&gt;SetInternalField(
        imp::kIndexPropertyDeleterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(deleter)));
  }

  if (enumerator) {
    obj-&gt;SetInternalField(
        imp::kIndexPropertyEnumeratorIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(enumerator)));
  }

  if (!data.IsEmpty()) {
    obj-&gt;SetInternalField(imp::kDataIndex, data);
  }

#if NODE_MODULE_VERSION &gt; NODE_0_12_MODULE_VERSION
  tpl-&gt;SetHandler(v8::IndexedPropertyHandlerConfiguration(
      getter_, setter_, query_, deleter_, enumerator_, obj));
#else
  tpl-&gt;SetIndexedPropertyHandler(
      getter_
    , setter_
    , query_
    , deleter_
    , enumerator_
    , obj);
#endif
}

inline void SetCallHandler(
    v8::Local&lt;v8::FunctionTemplate&gt; tpl
  , FunctionCallback callback
  , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()) {
  HandleScope scope;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kFunctionFieldCount);
  v8::Local&lt;v8::Object&gt; obj = NewInstance(otpl).ToLocalChecked();

  obj-&gt;SetInternalField(
      imp::kFunctionIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(callback)));

  if (!data.IsEmpty()) {
    obj-&gt;SetInternalField(imp::kDataIndex, data);
  }

  tpl-&gt;SetCallHandler(imp::FunctionCallbackWrapper, obj);
}


inline void SetCallAsFunctionHandler(
    v8::Local&lt;v8::ObjectTemplate&gt; tpl,
    FunctionCallback callback,
    v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()) {
  HandleScope scope;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kFunctionFieldCount);
  v8::Local&lt;v8::Object&gt; obj = NewInstance(otpl).ToLocalChecked();

  obj-&gt;SetInternalField(
      imp::kFunctionIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(callback)));

  if (!data.IsEmpty()) {
    obj-&gt;SetInternalField(imp::kDataIndex, data);
  }

  tpl-&gt;SetCallAsFunctionHandler(imp::FunctionCallbackWrapper, obj);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>=== Weak Persistent Handling =================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_weak.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>=== ObjectWrap ===============================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_object_wrap.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>=== Export ==================================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span>
<span class="hljs-title">Export</span><span class="hljs-params">(ADDON_REGISTER_FUNCTION_ARGS_TYPE target, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,
    FunctionCallback f)</span> </span>{
  Set(target, New&lt;v8::String&gt;(name).ToLocalChecked(),
      GetFunction(New&lt;v8::FunctionTemplate&gt;(f)).ToLocalChecked());
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>=== Tap Reverse Binding =====================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
struct Tap {
  explicit Tap(v8::Local&lt;v8::Value&gt; t) : t_() {
    t_.Reset(To&lt;v8::Object&gt;(t).ToLocalChecked());
  }

  ~Tap() { t_.Reset(); }  // not sure if neccessary

  inline void plan(int i) {
    v8::Local&lt;v8::Value&gt; arg = New(i);
    MakeCallback(New(t_), "plan", 1, &amp;arg);
  }

  inline void ok(bool isOk, const char *msg = NULL) {
    v8::Local&lt;v8::Value&gt; args[2];
    args[0] = New(isOk);
    if (msg) args[1] = New(msg).ToLocalChecked();
    MakeCallback(New(t_), "ok", msg ? 2 : 1, args);
  }

  inline void pass(const char * msg = NULL) {
    v8::Local&lt;v8::Value&gt; hmsg;
    if (msg) hmsg = New(msg).ToLocalChecked();
    MakeCallback(New(t_), "pass", msg ? 1 : 0, &amp;hmsg);
  }

 private:
  Persistent&lt;v8::Object&gt; t_;
};

#define NAN_STRINGIZE2(x) #x
#define NAN_STRINGIZE(x) NAN_STRINGIZE2(x)
#define NAN_TEST_EXPRESSION(expression) \
  ( expression ), __FILE__ ":" NAN_STRINGIZE(__LINE__) ": " #expression

#define NAN_EXPORT(target, function) Export(target, #function, function)

#undef TYPE_CHECK

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>=== Generic Maybefication ===================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">namespace</span> imp {

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> Maybefier;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> Maybefier&lt;v8::Local&lt;T&gt; &gt; {
  <span class="hljs-keyword">static</span> MaybeLocal&lt;T&gt; convert(v8::Local&lt;T&gt; v) {
    <span class="hljs-keyword">return</span> MaybeLocal&lt;T&gt;(v);
  }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> Maybefier&lt;MaybeLocal&lt;T&gt; &gt; {
  <span class="hljs-keyword">static</span> MaybeLocal&lt;T&gt; convert(MaybeLocal&lt;T&gt; v) {
    <span class="hljs-keyword">return</span> v;
  }
};

}  <span class="hljs-comment">// end of namespace imp</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> MaybeMaybe&gt;
MaybeLocal&lt;T&gt;
MakeMaybe(MaybeMaybe&lt;T&gt; v) {
  <span class="hljs-keyword">return</span> imp::Maybefier&lt;MaybeMaybe&lt;T&gt; &gt;::convert(v);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>=== TypedArrayContents =======================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_typedarray_contents.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>

}  <span class="hljs-comment">// end of namespace Nan</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAN_H_</span></span>

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
