<!DOCTYPE html>
<html>
<head>
  <title>object_wrappers.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "node_modules/nan/doc/object_wrappers.md";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h2">
        <a href="#object-wrappers">Object Wrappers</a>
      </div>

      <div class="heading h3">
        <a href="#nan-objectwrap">Nan::ObjectWrap()</a>
      </div>

      <div class="heading h3">
        <a href="#this-vs.holder">This vs. Holder</a>
      </div>

      <div class="heading h3">
        <a href="#examples">Examples</a>
      </div>

      <div class="heading h4">
        <a href="#basic">Basic</a>
      </div>

      <div class="heading h4">
        <a href="#factory-of-wrapped-objects">Factory of wrapped objects</a>
      </div>

      <div class="heading h4">
        <a href="#passing-wrapped-objects-around">Passing wrapped objects around</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="object-wrappers">
  <h2>
    <a href="#object-wrappers" name="object-wrappers" class="pilcrow"></a>
Object Wrappers
  </h2>
</div>
<p>The <code>ObjectWrap</code> class can be used to make wrapped C++ objects and a factory of wrapped objects.</p>
<ul>
<li><a href="#api_nan_object_wrap"><b><code>Nan::ObjectWrap</code></b></a></li>
</ul>
<p><a name="api_nan_object_wrap"></a></p>
<div class="pilwrap" id="nan-objectwrap">
  <h3>
    <a href="#nan-objectwrap" name="nan-objectwrap" class="pilcrow"></a>
Nan::ObjectWrap()
  </h3>
</div>
<p>A reimplementation of <code>node::ObjectWrap</code> that adds some API not present in older versions of Node. Should be preferred over <code>node::ObjectWrap</code> in all cases for consistency.</p>
<p>Definition:</p>
<pre><code class="c++"><span class="hljs-keyword">class</span> ObjectWrap {
 <span class="hljs-keyword">public</span>:
  ObjectWrap();

  <span class="hljs-keyword">virtual</span> ~ObjectWrap();

  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> T* <span class="hljs-title">Unwrap</span><span class="hljs-params">(v8::Local&lt;v8::Object&gt; handle)</span></span>;

  <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Object&gt; handle();

  <span class="hljs-keyword">inline</span> Nan::Persistent&lt;v8::Object&gt;&amp; persistent();

 <span class="hljs-keyword">protected</span>:
  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Wrap</span><span class="hljs-params">(v8::Local&lt;v8::Object&gt; handle)</span></span>;

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeWeak</span><span class="hljs-params">()</span></span>;

  <span class="hljs-comment">/* Ref() marks the object as being attached to an event loop.
   * Refed objects will not be garbage collected, even if
   * all references are lost.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Ref</span><span class="hljs-params">()</span></span>;

  <span class="hljs-comment">/* Unref() marks an object as detached from the event loop.  This is its
   * default state.  When an object with a "weak" reference changes from
   * attached to detached state it will be freed. Be careful not to access
   * the object after making this call as it might be gone!
   * (A "weak reference" means an object that only has a
   * persistant handle.)
   *
   * DO NOT CALL THIS FROM DESTRUCTOR
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Unref</span><span class="hljs-params">()</span></span>;

  <span class="hljs-keyword">int</span> refs_;  <span class="hljs-comment">// ro</span>
};
</code></pre>
<p>See the Node documentation on <a href="https://nodejs.org/api/addons.html#addons_wrapping_c_objects">Wrapping C++ Objects</a> for more details.</p>
<div class="pilwrap" id="this-vs.holder">
  <h3>
    <a href="#this-vs.holder" name="this-vs.holder" class="pilcrow"></a>
This vs. Holder
  </h3>
</div>
<p>When calling <code>Unwrap</code>, it is important that the argument is indeed some JavaScript object which got wrapped by a <code>Wrap</code> call for this class or any derived class.
The <code>Signature</code> installed by <a href="methods.md#api_nan_set_prototype_method.html"><code>Nan::SetPrototypeMethod()</code></a> does ensure that <code>info.Holder()</code> is just such an instance.
In Node 0.12 and later, <code>info.This()</code> will also be of such a type, since otherwise the invocation will get rejected.
However, in Node 0.10 and before it was possible to invoke a method on a JavaScript object which just had the extension type in its prototype chain.
In such a situation, calling <code>Unwrap</code> on <code>info.This()</code> will likely lead to a failed assertion causing a crash, but could lead to even more serious corruption.</p>
<p>On the other hand, calling <code>Unwrap</code> in an <a href="methods.md#api_nan_set_accessor.html">accessor</a> should not use <code>Holder()</code> if the accessor is defined on the prototype.
So either define your accessors on the instance template,
or use <code>This()</code> after verifying that it is indeed a valid object.</p>
<div class="pilwrap" id="examples">
  <h3>
    <a href="#examples" name="examples" class="pilcrow"></a>
Examples
  </h3>
</div>
<div class="pilwrap" id="basic">
  <h4>
    <a href="#basic" name="basic" class="pilcrow"></a>
Basic
  </h4>
</div>
<pre><code class="c++">class MyObject : public Nan::ObjectWrap {
 public:
  static NAN_MODULE_INIT(Init) {
    v8::Local&lt;v8::FunctionTemplate&gt; tpl = Nan::New&lt;v8::FunctionTemplate&gt;(New);
    tpl-&gt;SetClassName(Nan::New("MyObject").ToLocalChecked());
    tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

    SetPrototypeMethod(tpl, "getHandle", GetHandle);
    SetPrototypeMethod(tpl, "getValue", GetValue);

    constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());
    Nan::Set(target, Nan::New("MyObject").ToLocalChecked(),
      Nan::GetFunction(tpl).ToLocalChecked());
  }

 private:
  explicit MyObject(double value = 0) : value_(value) {}
  ~MyObject() {}

  static NAN_METHOD(New) {
    if (info.IsConstructCall()) {
      double value = info[0]-&gt;IsUndefined() ? 0 : Nan::To&lt;double&gt;(info[0]).FromJust();
      MyObject *obj = new MyObject(value);
      obj-&gt;Wrap(info.This());
      info.GetReturnValue().Set(info.This());
    } else {
      const int argc = 1;
      v8::Local&lt;v8::Value&gt; argv[argc] = {info[0]};
      v8::Local&lt;v8::Function&gt; cons = Nan::New(constructor());
      info.GetReturnValue().Set(cons-&gt;NewInstance(argc, argv));
    }
  }

  static NAN_METHOD(GetHandle) {
    MyObject* obj = Nan::ObjectWrap::Unwrap&lt;MyObject&gt;(info.Holder());
    info.GetReturnValue().Set(obj-&gt;handle());
  }

  static NAN_METHOD(GetValue) {
    MyObject* obj = Nan::ObjectWrap::Unwrap&lt;MyObject&gt;(info.Holder());
    info.GetReturnValue().Set(obj-&gt;value_);
  }

  static inline Nan::Persistent&lt;v8::Function&gt; &amp; constructor() {
    static Nan::Persistent&lt;v8::Function&gt; my_constructor;
    return my_constructor;
  }

  double value_;
};

NODE_MODULE(objectwrapper, MyObject::Init)
</code></pre>
<p>To use in Javascript:</p>
<pre><code class="Javascript"><span class="hljs-keyword">var</span> objectwrapper = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bindings'</span>)(<span class="hljs-string">'objectwrapper'</span>);

<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> objectwrapper.MyObject(<span class="hljs-number">5</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Should be 5: '</span> + obj.getValue());
</code></pre>
<div class="pilwrap" id="factory-of-wrapped-objects">
  <h4>
    <a href="#factory-of-wrapped-objects" name="factory-of-wrapped-objects" class="pilcrow"></a>
Factory of wrapped objects
  </h4>
</div>
<pre><code class="c++">class MyFactoryObject : public Nan::ObjectWrap {
 public:
  static NAN_MODULE_INIT(Init) {
    v8::Local&lt;v8::FunctionTemplate&gt; tpl = Nan::New&lt;v8::FunctionTemplate&gt;(New);
    tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

    Nan::SetPrototypeMethod(tpl, "getValue", GetValue);

    constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());
  }

  static NAN_METHOD(NewInstance) {
    v8::Local&lt;v8::Function&gt; cons = Nan::New(constructor());
    double value = info[0]-&gt;IsNumber() ? Nan::To&lt;double&gt;(info[0]).FromJust() : 0;
    const int argc = 1;
    v8::Local&lt;v8::Value&gt; argv[1] = {Nan::New(value)};
    info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());
  }

  // Needed for the next example:
  inline double value() const {
    return value_;
  }

 private:
  explicit MyFactoryObject(double value = 0) : value_(value) {}
  ~MyFactoryObject() {}

  static NAN_METHOD(New) {
    if (info.IsConstructCall()) {
      double value = info[0]-&gt;IsNumber() ? Nan::To&lt;double&gt;(info[0]).FromJust() : 0;
      MyFactoryObject * obj = new MyFactoryObject(value);
      obj-&gt;Wrap(info.This());
      info.GetReturnValue().Set(info.This());
    } else {
      const int argc = 1;
      v8::Local&lt;v8::Value&gt; argv[argc] = {info[0]};
      v8::Local&lt;v8::Function&gt; cons = Nan::New(constructor());
      info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());
    }
  }

  static NAN_METHOD(GetValue) {
    MyFactoryObject* obj = ObjectWrap::Unwrap&lt;MyFactoryObject&gt;(info.Holder());
    info.GetReturnValue().Set(obj-&gt;value_);
  }

  static inline Nan::Persistent&lt;v8::Function&gt; &amp; constructor() {
    static Nan::Persistent&lt;v8::Function&gt; my_constructor;
    return my_constructor;
  }

  double value_;
};

NAN_MODULE_INIT(Init) {
  MyFactoryObject::Init(target);
  Nan::Set(target,
    Nan::New&lt;v8::String&gt;("newFactoryObjectInstance").ToLocalChecked(),
    Nan::GetFunction(
      Nan::New&lt;v8::FunctionTemplate&gt;(MyFactoryObject::NewInstance)).ToLocalChecked()
  );
}

NODE_MODULE(wrappedobjectfactory, Init)
</code></pre>
<p>To use in Javascript:</p>
<pre><code class="Javascript"><span class="hljs-keyword">var</span> wrappedobjectfactory = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bindings'</span>)(<span class="hljs-string">'wrappedobjectfactory'</span>);

<span class="hljs-keyword">var</span> obj = wrappedobjectfactory.newFactoryObjectInstance(<span class="hljs-number">10</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Should be 10: '</span> + obj.getValue());
</code></pre>
<div class="pilwrap" id="passing-wrapped-objects-around">
  <h4>
    <a href="#passing-wrapped-objects-around" name="passing-wrapped-objects-around" class="pilcrow"></a>
Passing wrapped objects around
  </h4>
</div>
<p>Use the <code>MyFactoryObject</code> class above along with the following:</p>
<pre><code class="c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">NAN_METHOD</span><span class="hljs-params">(Sum)</span> </span>{
  Nan::MaybeLocal&lt;v8::Object&gt; maybe1 = Nan::To&lt;v8::Object&gt;(info[<span class="hljs-number">0</span>]);
  Nan::MaybeLocal&lt;v8::Object&gt; maybe2 = Nan::To&lt;v8::Object&gt;(info[<span class="hljs-number">1</span>]);

  <span class="hljs-comment">// Quick check:</span>
  <span class="hljs-keyword">if</span> (maybe1.IsEmpty() || maybe2.IsEmpty()) {
    <span class="hljs-comment">// return value is undefined by default</span>
    <span class="hljs-keyword">return</span>;
  }

  MyFactoryObject* obj1 =
    Nan::ObjectWrap::Unwrap&lt;MyFactoryObject&gt;(maybe1.ToLocalChecked());
  MyFactoryObject* obj2 =
    Nan::ObjectWrap::Unwrap&lt;MyFactoryObject&gt;(maybe2.ToLocalChecked());

  info.GetReturnValue().Set(Nan::New&lt;v8::Number&gt;(obj1-&gt;value() + obj2-&gt;value()));
}

NAN_MODULE_INIT(Init) {
  MyFactoryObject::Init(target);
  Nan::Set(target,
    Nan::New&lt;v8::String&gt;(<span class="hljs-string">"newFactoryObjectInstance"</span>).ToLocalChecked(),
    Nan::GetFunction(
      Nan::New&lt;v8::FunctionTemplate&gt;(MyFactoryObject::NewInstance)).ToLocalChecked()
  );
  Nan::Set(target,
    Nan::New&lt;v8::String&gt;(<span class="hljs-string">"sum"</span>).ToLocalChecked(),
    Nan::GetFunction(Nan::New&lt;v8::FunctionTemplate&gt;(Sum)).ToLocalChecked()
  );
}

NODE_MODULE(myaddon, Init)
</code></pre>
<p>To use in Javascript:</p>
<pre><code class="Javascript"><span class="hljs-keyword">var</span> myaddon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bindings'</span>)(<span class="hljs-string">'myaddon'</span>);

<span class="hljs-keyword">var</span> obj1 = myaddon.newFactoryObjectInstance(<span class="hljs-number">5</span>);
<span class="hljs-keyword">var</span> obj2 = myaddon.newFactoryObjectInstance(<span class="hljs-number">10</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'sum of object values: '</span> + myaddon.sum(obj1, obj2));
</code></pre>
</div>
  </div>
</body>
</html>
