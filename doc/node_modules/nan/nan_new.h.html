<!DOCTYPE html>
<html>
<head>
  <title>nan_new.h</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/nan/nan_new.h";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>nan_new.h</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<div class="dox">
<div class="summary">
<hr>
<p>NAN - Native Abstractions for Node.js</p>
</div>
<div class="body">
<p>Copyright (c) 2016 NAN contributors</p>
<p>MIT License <a href="https://github.com/nodejs/nan/blob/master/LICENSE.md">https://github.com/nodejs/nan/blob/master/LICENSE.md</a></p>
<hr>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NAN_NEW_H_</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAN_NEW_H_</span>

<span class="hljs-keyword">namespace</span> imp {  <span class="hljs-comment">// scnr</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>TODO(agnat): Generalize</p>

        </td>
        <td class="code highlight">
          <pre class="c">template &lt;typename T&gt; v8::Local&lt;T&gt; To(v8::Local&lt;v8::Integer&gt; i);

template &lt;&gt;
inline
v8::Local&lt;v8::Integer&gt;
To&lt;v8::Integer&gt;(v8::Local&lt;v8::Integer&gt; i) {
  return Nan::To&lt;v8::Integer&gt;(i).ToLocalChecked();
}

template &lt;&gt;
inline
v8::Local&lt;v8::Int32&gt;
To&lt;v8::Int32&gt;(v8::Local&lt;v8::Integer&gt; i) {
  return Nan::To&lt;v8::Int32&gt;(i).ToLocalChecked();
}

template &lt;&gt;
inline
v8::Local&lt;v8::Uint32&gt;
To&lt;v8::Uint32&gt;(v8::Local&lt;v8::Integer&gt; i) {
  return Nan::To&lt;v8::Uint32&gt;(i).ToLocalChecked();
}

template &lt;typename T&gt; struct FactoryBase {
  typedef v8::Local&lt;T&gt; return_t;
};

template &lt;typename T&gt; struct MaybeFactoryBase {
  typedef MaybeLocal&lt;T&gt; return_t;
};

template &lt;typename T&gt; struct Factory;

template &lt;&gt;
struct Factory&lt;v8::Array&gt; : FactoryBase&lt;v8::Array&gt; {
  static inline return_t New();
  static inline return_t New(int length);
};

template &lt;&gt;
struct Factory&lt;v8::Boolean&gt; : FactoryBase&lt;v8::Boolean&gt; {
  static inline return_t New(bool value);
};

template &lt;&gt;
struct Factory&lt;v8::BooleanObject&gt; : FactoryBase&lt;v8::BooleanObject&gt; {
  static inline return_t New(bool value);
};

template &lt;&gt;
struct Factory&lt;v8::Context&gt; : FactoryBase&lt;v8::Context&gt; {
  static inline
  return_t
  New( v8::ExtensionConfiguration* extensions = NULL
     , v8::Local&lt;v8::ObjectTemplate&gt; tmpl = v8::Local&lt;v8::ObjectTemplate&gt;()
     , v8::Local&lt;v8::Value&gt; obj = v8::Local&lt;v8::Value&gt;());
};

template &lt;&gt;
struct Factory&lt;v8::Date&gt; : MaybeFactoryBase&lt;v8::Date&gt; {
  static inline return_t New(double value);
};

template &lt;&gt;
struct Factory&lt;v8::External&gt; : FactoryBase&lt;v8::External&gt; {
  static inline return_t New(void *value);
};

template &lt;&gt;
struct Factory&lt;v8::Function&gt; : FactoryBase&lt;v8::Function&gt; {
  static inline
  return_t
  New( FunctionCallback callback
     , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;());
};

template &lt;&gt;
struct Factory&lt;v8::FunctionTemplate&gt; : FactoryBase&lt;v8::FunctionTemplate&gt; {
  static inline
  return_t
  New( FunctionCallback callback = NULL
     , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()
     , v8::Local&lt;v8::Signature&gt; signature = v8::Local&lt;v8::Signature&gt;());
};

template &lt;&gt;
struct Factory&lt;v8::Number&gt; : FactoryBase&lt;v8::Number&gt; {
  static inline return_t New(double value);
};

template &lt;&gt;
struct Factory&lt;v8::NumberObject&gt; : FactoryBase&lt;v8::NumberObject&gt; {
  static inline return_t New(double value);
};

template &lt;typename T&gt;
struct IntegerFactory : FactoryBase&lt;T&gt; {
  typedef typename FactoryBase&lt;T&gt;::return_t return_t;
  static inline return_t New(int32_t value);
  static inline return_t New(uint32_t value);
};

template &lt;&gt;
struct Factory&lt;v8::Integer&gt; : IntegerFactory&lt;v8::Integer&gt; {};

template &lt;&gt;
struct Factory&lt;v8::Int32&gt; : IntegerFactory&lt;v8::Int32&gt; {};

template &lt;&gt;
struct Factory&lt;v8::Uint32&gt; : FactoryBase&lt;v8::Uint32&gt; {
  static inline return_t New(int32_t value);
  static inline return_t New(uint32_t value);
};

template &lt;&gt;
struct Factory&lt;v8::Object&gt; : FactoryBase&lt;v8::Object&gt; {
  static inline return_t New();
};

template &lt;&gt;
struct Factory&lt;v8::ObjectTemplate&gt; : FactoryBase&lt;v8::ObjectTemplate&gt; {
  static inline return_t New();
};

template &lt;&gt;
struct Factory&lt;v8::RegExp&gt; : MaybeFactoryBase&lt;v8::RegExp&gt; {
  static inline return_t New(
      v8::Local&lt;v8::String&gt; pattern, v8::RegExp::Flags flags);
};

template &lt;&gt;
struct Factory&lt;v8::Script&gt; : MaybeFactoryBase&lt;v8::Script&gt; {
  static inline return_t New( v8::Local&lt;v8::String&gt; source);
  static inline return_t New( v8::Local&lt;v8::String&gt; source
                            , v8::ScriptOrigin const&amp; origin);
};

template &lt;&gt;
struct Factory&lt;v8::Signature&gt; : FactoryBase&lt;v8::Signature&gt; {
  typedef v8::Local&lt;v8::FunctionTemplate&gt; FTH;
  static inline return_t New(FTH receiver = FTH());
};

template &lt;&gt;
struct Factory&lt;v8::String&gt; : MaybeFactoryBase&lt;v8::String&gt; {
  static inline return_t New();
  static inline return_t New(const char *value, int length = -1);
  static inline return_t New(const uint16_t *value, int length = -1);
  static inline return_t New(std::string const&amp; value);

  static inline return_t New(v8::String::ExternalStringResource * value);
  static inline return_t New(ExternalOneByteStringResource * value);
};

template &lt;&gt;
struct Factory&lt;v8::StringObject&gt; : FactoryBase&lt;v8::StringObject&gt; {
  static inline return_t New(v8::Local&lt;v8::String&gt; value);
};

}  // end of namespace imp

#if (NODE_MODULE_VERSION &gt;= 12)

namespace imp {

template &lt;&gt;
struct Factory&lt;v8::UnboundScript&gt; : MaybeFactoryBase&lt;v8::UnboundScript&gt; {
  static inline return_t New( v8::Local&lt;v8::String&gt; source);
  static inline return_t New( v8::Local&lt;v8::String&gt; source
                            , v8::ScriptOrigin const&amp; origin);
};

}  // end of namespace imp

# include "nan_implementation_12_inl.h"

#else  // NODE_MODULE_VERSION &gt;= 12

# include "nan_implementation_pre_12_inl.h"

#endif

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>=== API ======================================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">typename</span> imp::Factory&lt;T&gt;::<span class="hljs-keyword">return_t</span>
New() {
  <span class="hljs-keyword">return</span> imp::Factory&lt;T&gt;::New();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> A0&gt;
<span class="hljs-keyword">typename</span> imp::Factory&lt;T&gt;::<span class="hljs-keyword">return_t</span>
New(A0 arg0) {
  <span class="hljs-keyword">return</span> imp::Factory&lt;T&gt;::New(arg0);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> A0, <span class="hljs-keyword">typename</span> A1&gt;
<span class="hljs-keyword">typename</span> imp::Factory&lt;T&gt;::<span class="hljs-keyword">return_t</span>
New(A0 arg0, A1 arg1) {
  <span class="hljs-keyword">return</span> imp::Factory&lt;T&gt;::New(arg0, arg1);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> A0, <span class="hljs-keyword">typename</span> A1, <span class="hljs-keyword">typename</span> A2&gt;
<span class="hljs-keyword">typename</span> imp::Factory&lt;T&gt;::<span class="hljs-keyword">return_t</span>
New(A0 arg0, A1 arg1, A2 arg2) {
  <span class="hljs-keyword">return</span> imp::Factory&lt;T&gt;::New(arg0, arg1, arg2);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> A0, <span class="hljs-keyword">typename</span> A1, <span class="hljs-keyword">typename</span> A2, <span class="hljs-keyword">typename</span> A3&gt;
<span class="hljs-keyword">typename</span> imp::Factory&lt;T&gt;::<span class="hljs-keyword">return_t</span>
New(A0 arg0, A1 arg1, A2 arg2, A3 arg3) {
  <span class="hljs-keyword">return</span> imp::Factory&lt;T&gt;::New(arg0, arg1, arg2, arg3);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>Note(agnat): When passing overloaded function pointers to template functions
as generic arguments the compiler needs help in picking the right overload.
These two functions handle New<Function> and New<FunctionTemplate> with
all argument variations.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>v8::Function and v8::FunctionTemplate with one or two arguments</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">typename</span> imp::Factory&lt;T&gt;::<span class="hljs-keyword">return_t</span>
New( FunctionCallback callback
      , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()) {
    <span class="hljs-keyword">return</span> imp::Factory&lt;T&gt;::New(callback, data);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>v8::Function and v8::FunctionTemplate with three arguments</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> A2&gt;
<span class="hljs-keyword">typename</span> imp::Factory&lt;T&gt;::<span class="hljs-keyword">return_t</span>
New( FunctionCallback callback
      , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()
      , A2 a2 = A2()) {
    <span class="hljs-keyword">return</span> imp::Factory&lt;T&gt;::New(callback, data, a2);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Convenience</p>

        </td>
        <td class="code highlight">
          <pre class="c">
#if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
template &lt;typename T&gt; inline v8::Local&lt;T&gt; New(v8::Handle&lt;T&gt; h);
#endif

#if NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION
template &lt;typename T, typename M&gt;
    inline v8::Local&lt;T&gt; New(v8::Persistent&lt;T, M&gt; const&amp; p);
#else
template &lt;typename T&gt; inline v8::Local&lt;T&gt; New(v8::Persistent&lt;T&gt; const&amp; p);
#endif
template &lt;typename T, typename M&gt;
inline v8::Local&lt;T&gt; New(Persistent&lt;T, M&gt; const&amp; p);
template &lt;typename T&gt;
inline v8::Local&lt;T&gt; New(Global&lt;T&gt; const&amp; p);

inline
imp::Factory&lt;v8::Boolean&gt;::return_t
New(bool value) {
  return New&lt;v8::Boolean&gt;(value);
}

inline
imp::Factory&lt;v8::Int32&gt;::return_t
New(int32_t value) {
  return New&lt;v8::Int32&gt;(value);
}

inline
imp::Factory&lt;v8::Uint32&gt;::return_t
New(uint32_t value) {
  return New&lt;v8::Uint32&gt;(value);
}

inline
imp::Factory&lt;v8::Number&gt;::return_t
New(double value) {
  return New&lt;v8::Number&gt;(value);
}

inline
imp::Factory&lt;v8::String&gt;::return_t
New(std::string const&amp; value) {  // NOLINT(build/include_what_you_use)
  return New&lt;v8::String&gt;(value);
}

inline
imp::Factory&lt;v8::String&gt;::return_t
New(const char * value, int length) {
  return New&lt;v8::String&gt;(value, length);
}

inline
imp::Factory&lt;v8::String&gt;::return_t
New(const uint16_t * value, int length) {
  return New&lt;v8::String&gt;(value, length);
}

inline
imp::Factory&lt;v8::String&gt;::return_t
New(const char * value) {
  return New&lt;v8::String&gt;(value);
}

inline
imp::Factory&lt;v8::String&gt;::return_t
New(const uint16_t * value) {
  return New&lt;v8::String&gt;(value);
}

inline
imp::Factory&lt;v8::String&gt;::return_t
New(v8::String::ExternalStringResource * value) {
  return New&lt;v8::String&gt;(value);
}

inline
imp::Factory&lt;v8::String&gt;::return_t
New(ExternalOneByteStringResource * value) {
  return New&lt;v8::String&gt;(value);
}

inline
imp::Factory&lt;v8::RegExp&gt;::return_t
New(v8::Local&lt;v8::String&gt; pattern, v8::RegExp::Flags flags) {
  return New&lt;v8::RegExp&gt;(pattern, flags);
}

#endif  // NAN_NEW_H_

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
