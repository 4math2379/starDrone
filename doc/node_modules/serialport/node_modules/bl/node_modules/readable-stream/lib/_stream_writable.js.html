<!DOCTYPE html>
<html>
<head>
  <title>_stream_writable.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../../../doc-style.css" />
  <script src="../../../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../../../";
    var thisFile = "node_modules/serialport/node_modules/bl/node_modules/readable-stream/lib/_stream_writable.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>_stream_writable.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<p>A bit simpler than readable streams.
Implement an async ._write(chunk, encoding, cb), and it'll handle all
the drain event emission and buffering.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">
'use strict'</span>;

<span class="hljs-built_in">module</span>.exports = Writable;

<span class="hljs-comment">/*&lt;replacement&gt;*/</span>
<span class="hljs-keyword">var</span> processNextTick = <span class="hljs-built_in">require</span>(<span class="hljs-string">'process-nextick-args'</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<div class="dox">
<div class="summary">
</replacement>  
</div>
<div class="body">
<p>/<em><replacement></em>/</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> asyncWrite = !process.browser &amp;&amp; [<span class="hljs-string">'v0.10'</span>, <span class="hljs-string">'v0.9.'</span>].indexOf(process.version.slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)) &gt; <span class="hljs-number">-1</span> ? setImmediate : processNextTick;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<div class="dox">
<div class="summary">
</replacement>  
</div>
<div class="body">
<p>/<em><replacement></em>/</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> Buffer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'buffer'</span>).Buffer;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<div class="dox">
<div class="summary">
</replacement>  
</div>
<div class="body">
<p>Writable.WritableState = WritableState;</p>
<p>/<em><replacement></em>/</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'core-util-is'</span>);
util.inherits = <span class="hljs-built_in">require</span>(<span class="hljs-string">'inherits'</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<div class="dox">
<div class="summary">
</replacement>  
</div>
<div class="body">
<p>/<em><replacement></em>/</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> internalUtil = {
  <span class="hljs-attr">deprecate</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'util-deprecate'</span>)
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<div class="dox">
<div class="summary">
</replacement>  
</div>
<div class="body">
<p>/<em><replacement></em>/</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> Stream;
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    Stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'st'</span> + <span class="hljs-string">'ream'</span>);
  } <span class="hljs-keyword">catch</span> (_) {} <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">if</span> (!Stream) Stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>).EventEmitter;
  }
})();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<div class="dox">
<div class="summary">
</replacement>  
</div>
<div class="body">
<p>var Buffer = require('buffer').Buffer;</p>
<p>util.inherits(Writable, Stream);</p>
<p>function nop() {}</p>
<p>function WriteReq(chunk, encoding, cb) {
this.chunk = chunk;
this.encoding = encoding;
this.callback = cb;
this.next = null;
}</p>
<p>var Duplex;
function WritableState(options, stream) {
Duplex = Duplex || require('./_stream_duplex');</p>
<p>options = options || {};</p>
<p>// object stream flag to indicate whether or not this stream
// contains buffers or objects.
this.objectMode = !!options.objectMode;</p>
<p>if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;</p>
<p>// the point at which write() starts returning false
// Note: 0 is a valid value, means that we always return false if
// the entire buffer is not flushed immediately on write()
var hwm = options.highWaterMark;
var defaultHwm = this.objectMode ? 16 : 16 * 1024;
this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;</p>
<p>// cast to ints.
this.highWaterMark = ~ ~this.highWaterMark;</p>
<p>this.needDrain = false;
// at the start of calling end()
this.ending = false;
// when end() has been called, and returned
this.ended = false;
// when 'finish' is emitted
this.finished = false;</p>
<p>// should we decode strings into buffers before passing to _write?
// this is here so that some node-core streams can optimize string
// handling at a lower level.
var noDecode = options.decodeStrings === false;
this.decodeStrings = !noDecode;</p>
<p>// Crypto is kind of old and crusty.  Historically, its default string
// encoding is 'binary' so we have to make this configurable.
// Everything else in the universe uses 'utf8', though.
this.defaultEncoding = options.defaultEncoding || 'utf8';</p>
<p>// not an actual buffer we keep track of, but a measurement
// of how much we're waiting to get pushed to some underlying
// socket or file.
this.length = 0;</p>
<p>// a flag to see when we're in the middle of a write.
this.writing = false;</p>
<p>// when true all writes will be buffered until .uncork() call
this.corked = 0;</p>
<p>// a flag to be able to tell if the onwrite cb is called immediately,
// or on a later tick.  We set this to true at first, because any
// actions that shouldn't happen until &quot;later&quot; should generally also
// not happen before the first write call.
this.sync = true;</p>
<p>// a flag to know if we're processing previously buffered items, which
// may call the _write() callback in the same tick, so that we don't
// end up in an overlapped onwrite situation.
this.bufferProcessing = false;</p>
<p>// the callback that's passed to _write(chunk,cb)
this.onwrite = function (er) {
onwrite(stream, er);
};</p>
<p>// the callback that the user supplies to write(chunk,encoding,cb)
this.writecb = null;</p>
<p>// the amount that is being written when _write is called.
this.writelen = 0;</p>
<p>this.bufferedRequest = null;
this.lastBufferedRequest = null;</p>
<p>// number of pending user-supplied write callbacks
// this must be 0 before 'finish' can be emitted
this.pendingcb = 0;</p>
<p>// emit prefinish if the only thing we're waiting for is _write cbs
// This is relevant for synchronous Transform streams
this.prefinished = false;</p>
<p>// True if the error was already emitted and should not be thrown again
this.errorEmitted = false;</p>
<p>// count buffered requests
this.bufferedRequestCount = 0;</p>
<p>// create the two objects needed to store the corked requests
// they are not a linked list, as no new elements are inserted in there
this.corkedRequestsFree = new CorkedRequest(this);
this.corkedRequestsFree.next = new CorkedRequest(this);
}</p>
<p>WritableState.prototype.getBuffer = function writableStateGetBuffer() {
var current = this.bufferedRequest;
var out = [];
while (current) {
out.push(current);
current = current.next;
}
return out;
};</p>
<p>(function () {
try {
Object.defineProperty(WritableState.prototype, 'buffer', {
get: internalUtil.deprecate(function () {
return this.getBuffer();
}, '_writableState.buffer is deprecated. Use <em>writableState.getBuffer ' + 'instead.')
});
} catch (</em>) {}
})();</p>
<p>var Duplex;
function Writable(options) {
Duplex = Duplex || require('./_stream_duplex');</p>
<p>// Writable ctor is applied to Duplexes, though they're not
// instanceof Writable, they're instanceof Readable.
if (!(this instanceof Writable) &amp;&amp; !(this instanceof Duplex)) return new Writable(options);</p>
<p>this._writableState = new WritableState(options, this);</p>
<p>// legacy.
this.writable = true;</p>
<p>if (options) {
if (typeof options.write === 'function') this._write = options.write;</p>
<p>if (typeof options.writev === 'function') this._writev = options.writev;
}</p>
<p>Stream.call(this);
}</p>
<p>// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
this.emit('error', new Error('Cannot pipe. Not readable.'));
};</p>
<p>function writeAfterEnd(stream, cb) {
var er = new Error('write after end');
// TODO: defer error events consistently everywhere, not just the cb
stream.emit('error', er);
processNextTick(cb, er);
}</p>
<p>// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
var valid = true;</p>
<p>if (!Buffer.isBuffer(chunk) &amp;&amp; typeof chunk !== 'string' &amp;&amp; chunk !== null &amp;&amp; chunk !== undefined &amp;&amp; !state.objectMode) {
var er = new TypeError('Invalid non-string/buffer chunk');
stream.emit('error', er);
processNextTick(cb, er);
valid = false;
}
return valid;
}</p>
<p>Writable.prototype.write = function (chunk, encoding, cb) {
var state = this._writableState;
var ret = false;</p>
<p>if (typeof encoding === 'function') {
cb = encoding;
encoding = null;
}</p>
<p>if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;</p>
<p>if (typeof cb !== 'function') cb = nop;</p>
<p>if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
state.pendingcb++;
ret = writeOrBuffer(this, state, chunk, encoding, cb);
}</p>
<p>return ret;
};</p>
<p>Writable.prototype.cork = function () {
var state = this._writableState;</p>
<p>state.corked++;
};</p>
<p>Writable.prototype.uncork = function () {
var state = this._writableState;</p>
<p>if (state.corked) {
state.corked--;</p>
<p>if (!state.writing &amp;&amp; !state.corked &amp;&amp; !state.finished &amp;&amp; !state.bufferProcessing &amp;&amp; state.bufferedRequest) clearBuffer(this, state);
}
};</p>
<p>Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
// node::ParseEncoding() requires lower case.
if (typeof encoding === 'string') encoding = encoding.toLowerCase();
if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) &gt; -1)) throw new TypeError('Unknown encoding: ' + encoding);
this._writableState.defaultEncoding = encoding;
};</p>
<p>function decodeChunk(state, chunk, encoding) {
if (!state.objectMode &amp;&amp; state.decodeStrings !== false &amp;&amp; typeof chunk === 'string') {
chunk = new Buffer(chunk, encoding);
}
return chunk;
}</p>
<p>// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
chunk = decodeChunk(state, chunk, encoding);</p>
<p>if (Buffer.isBuffer(chunk)) encoding = 'buffer';
var len = state.objectMode ? 1 : chunk.length;</p>
<p>state.length += len;</p>
<p>var ret = state.length &lt; state.highWaterMark;
// we must ensure that previous needDrain will not be reset to false.
if (!ret) state.needDrain = true;</p>
<p>if (state.writing || state.corked) {
var last = state.lastBufferedRequest;
state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
if (last) {
last.next = state.lastBufferedRequest;
} else {
state.bufferedRequest = state.lastBufferedRequest;
}
state.bufferedRequestCount += 1;
} else {
doWrite(stream, state, false, len, chunk, encoding, cb);
}</p>
<p>return ret;
}</p>
<p>function doWrite(stream, state, writev, len, chunk, encoding, cb) {
state.writelen = len;
state.writecb = cb;
state.writing = true;
state.sync = true;
if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
state.sync = false;
}</p>
<p>function onwriteError(stream, state, sync, er, cb) {
--state.pendingcb;
if (sync) processNextTick(cb, er);else cb(er);</p>
<p>stream._writableState.errorEmitted = true;
stream.emit('error', er);
}</p>
<p>function onwriteStateUpdate(state) {
state.writing = false;
state.writecb = null;
state.length -= state.writelen;
state.writelen = 0;
}</p>
<p>function onwrite(stream, er) {
var state = stream._writableState;
var sync = state.sync;
var cb = state.writecb;</p>
<p>onwriteStateUpdate(state);</p>
<p>if (er) onwriteError(stream, state, sync, er, cb);else {
// Check if we're actually ready to finish, but don't emit yet
var finished = needFinish(state);</p>
<p>if (!finished &amp;&amp; !state.corked &amp;&amp; !state.bufferProcessing &amp;&amp; state.bufferedRequest) {
clearBuffer(stream, state);
}</p>
<p>if (sync) {
/<em><replacement></em>/</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      asyncWrite(afterWrite, stream, state, finished, cb);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"></pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
