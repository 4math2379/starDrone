<!DOCTYPE html>
<html>
<head>
  <title>source-map-consumer.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/source-map/lib/source-map-consumer.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>source-map-consumer.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">{
  <span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util'</span>);
  <span class="hljs-keyword">var</span> binarySearch = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./binary-search'</span>);
  <span class="hljs-keyword">var</span> ArraySet = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./array-set'</span>).ArraySet;
  <span class="hljs-keyword">var</span> base64VLQ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./base64-vlq'</span>);
  <span class="hljs-keyword">var</span> quickSort = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./quick-sort'</span>).quickSort;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer</span>(<span class="hljs-params">aSourceMap</span>) </span>{
    <span class="hljs-keyword">var</span> sourceMap = aSourceMap;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> aSourceMap === <span class="hljs-string">'string'</span>) {
      sourceMap = <span class="hljs-built_in">JSON</span>.parse(aSourceMap.replace(<span class="hljs-regexp">/^\)\]\}'/</span>, <span class="hljs-string">''</span>));
    }

    <span class="hljs-keyword">return</span> sourceMap.sections != <span class="hljs-literal">null</span>
      ? <span class="hljs-keyword">new</span> IndexedSourceMapConsumer(sourceMap)
      : <span class="hljs-keyword">new</span> BasicSourceMapConsumer(sourceMap);
  }

  SourceMapConsumer.fromSourceMap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">aSourceMap</span>) </span>{
    <span class="hljs-keyword">return</span> BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<div class="dox">
<div class="summary">
<p>The version of the source mapping spec that we are consuming.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  SourceMapConsumer.prototype._version = <span class="hljs-number">3</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p><code>__generatedMappings</code> and <code>__originalMappings</code> are arrays that hold the
parsed mapping coordinates from the source map's &quot;mappings&quot; attribute. They
are lazily instantiated, accessed via the <code>_generatedMappings</code> and
<code>_originalMappings</code> getters respectively, and we only parse the mappings
and create these arrays once queried for a source location. We jump through
these hoops because there can be many thousands of mappings, and parsing
them is expensive, so we only want to do it if we must.</p>
<p>Each object in the arrays is of the form:</p>
<pre><code>{
  generatedLine: The line number in the generated code,
  generatedColumn: The column number in the generated code,
  source: The path to the original source file that generated this
          chunk of code,
  originalLine: The line number in the original source that
                corresponds to this chunk of generated code,
  originalColumn: The column number in the original source that
                  corresponds to this chunk of generated code,
  name: The name of the original symbol which generated this chunk of
        code.
}
</code></pre>
<p>All properties except for <code>generatedLine</code> and <code>generatedColumn</code> can be
<code>null</code>.</p>
<p><code>_generatedMappings</code> is ordered by the generated positions.</p>
<p><code>_originalMappings</code> is ordered by the original positions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  SourceMapConsumer.prototype.__generatedMappings = <span class="hljs-literal">null</span>;
  <span class="hljs-built_in">Object</span>.defineProperty(SourceMapConsumer.prototype, <span class="hljs-string">'_generatedMappings'</span>, {
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.__generatedMappings) {
        <span class="hljs-keyword">this</span>._parseMappings(<span class="hljs-keyword">this</span>._mappings, <span class="hljs-keyword">this</span>.sourceRoot);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = <span class="hljs-literal">null</span>;
  <span class="hljs-built_in">Object</span>.defineProperty(SourceMapConsumer.prototype, <span class="hljs-string">'_originalMappings'</span>, {
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.__originalMappings) {
        <span class="hljs-keyword">this</span>._parseMappings(<span class="hljs-keyword">this</span>._mappings, <span class="hljs-keyword">this</span>.sourceRoot);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._charIsMappingSeparator =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_charIsMappingSeparator</span>(<span class="hljs-params">aStr, index</span>) </span>{
      <span class="hljs-keyword">var</span> c = aStr.charAt(index);
      <span class="hljs-keyword">return</span> c === <span class="hljs-string">";"</span> || c === <span class="hljs-string">","</span>;
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<div class="dox">
<div class="summary">
<p>Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the <code>this.__generatedMappings</code> and
<code>this.__originalMappings</code> properties).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  SourceMapConsumer.prototype._parseMappings =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_parseMappings</span>(<span class="hljs-params">aStr, aSourceRoot</span>) </span>{
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Subclasses must implement _parseMappings"</span>);
    };

  SourceMapConsumer.GENERATED_ORDER = <span class="hljs-number">1</span>;
  SourceMapConsumer.ORIGINAL_ORDER = <span class="hljs-number">2</span>;

  SourceMapConsumer.GREATEST_LOWER_BOUND = <span class="hljs-number">1</span>;
  SourceMapConsumer.LEAST_UPPER_BOUND = <span class="hljs-number">2</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<div class="dox">
<div class="summary">
<p>Iterate over each mapping between an original source/line/column and a
generated line/column in this source map.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">Function</span>
<span>aCallback        The function that is called with each mapping.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">Object</span>
<span>aContext        Optional. If specified, this object will be the value of <code>this</code> every
time that <code>aCallback</code> is called.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aOrder</span>
<span>Either <code>SourceMapConsumer.GENERATED_ORDER</code> or
<code>SourceMapConsumer.ORIGINAL_ORDER</code>. Specifies whether you want to
iterate over the mappings sorted by the generated file's line/column
order or the original's source/line/column order, respectively. Defaults to
<code>SourceMapConsumer.GENERATED_ORDER</code>.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  SourceMapConsumer.prototype.eachMapping =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_eachMapping</span>(<span class="hljs-params">aCallback, aContext, aOrder</span>) </span>{
      <span class="hljs-keyword">var</span> context = aContext || <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      <span class="hljs-keyword">var</span> mappings;
      <span class="hljs-keyword">switch</span> (order) {
      <span class="hljs-keyword">case</span> SourceMapConsumer.GENERATED_ORDER:
        mappings = <span class="hljs-keyword">this</span>._generatedMappings;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> SourceMapConsumer.ORIGINAL_ORDER:
        mappings = <span class="hljs-keyword">this</span>._originalMappings;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown order of iteration."</span>);
      }

      <span class="hljs-keyword">var</span> sourceRoot = <span class="hljs-keyword">this</span>.sourceRoot;
      mappings.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mapping</span>) </span>{
        <span class="hljs-keyword">var</span> source = mapping.source === <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>._sources.at(mapping.source);
        <span class="hljs-keyword">if</span> (source != <span class="hljs-literal">null</span> &amp;&amp; sourceRoot != <span class="hljs-literal">null</span>) {
          source = util.join(sourceRoot, source);
        }
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">source</span>: source,
          <span class="hljs-attr">generatedLine</span>: mapping.generatedLine,
          <span class="hljs-attr">generatedColumn</span>: mapping.generatedColumn,
          <span class="hljs-attr">originalLine</span>: mapping.originalLine,
          <span class="hljs-attr">originalColumn</span>: mapping.originalColumn,
          <span class="hljs-attr">name</span>: mapping.name === <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>._names.at(mapping.name)
        };
      }, <span class="hljs-keyword">this</span>).forEach(aCallback, context);
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns all generated line and column information for the original source,
line, and column provided. If no column is provided, returns all mappings
corresponding to a either the line we are searching for or the next
closest line that has any mappings. Otherwise, returns all mappings
corresponding to the given line and either the column we are searching for
or the next closest column that has any offsets.</p>
</div>
<div class="body">
<p>The only argument is an object with the following properties:</p>
<ul>
<li>source: The filename of the original source.</li>
<li>line: The line number in the original source.</li>
<li>column: Optional. the column number in the original source.</li>
</ul>
<p>and an array of objects is returned, each with the following properties:</p>
<ul>
<li>line: The line number in the generated source, or null.</li>
<li>column: The column number in the generated source, or null.</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_allGeneratedPositionsFor</span>(<span class="hljs-params">aArgs</span>) </span>{
      <span class="hljs-keyword">var</span> line = util.getArg(aArgs, <span class="hljs-string">'line'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
returns the index of the closest mapping less than the needle. By
setting needle.originalColumn to 0, we thus find the last mapping for
the given line, provided such a mapping exists.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> needle = {
        <span class="hljs-attr">source</span>: util.getArg(aArgs, <span class="hljs-string">'source'</span>),
        <span class="hljs-attr">originalLine</span>: line,
        <span class="hljs-attr">originalColumn</span>: util.getArg(aArgs, <span class="hljs-string">'column'</span>, <span class="hljs-number">0</span>)
      };

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sourceRoot != <span class="hljs-literal">null</span>) {
        needle.source = util.relative(<span class="hljs-keyword">this</span>.sourceRoot, needle.source);
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._sources.has(needle.source)) {
        <span class="hljs-keyword">return</span> [];
      }
      needle.source = <span class="hljs-keyword">this</span>._sources.indexOf(needle.source);

      <span class="hljs-keyword">var</span> mappings = [];

      <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>._findMapping(needle,
                                    <span class="hljs-keyword">this</span>._originalMappings,
                                    <span class="hljs-string">"originalLine"</span>,
                                    <span class="hljs-string">"originalColumn"</span>,
                                    util.compareByOriginalPositions,
                                    binarySearch.LEAST_UPPER_BOUND);
      <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> mapping = <span class="hljs-keyword">this</span>._originalMappings[index];

        <span class="hljs-keyword">if</span> (aArgs.column === <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">var</span> originalLine = mapping.originalLine;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Iterate until either we run out of mappings, or we run into
a mapping for a different line than the one we found. Since
mappings are sorted, this is guaranteed to find all mappings for
the line we found.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">while</span> (mapping &amp;&amp; mapping.originalLine === originalLine) {
            mappings.push({
              <span class="hljs-attr">line</span>: util.getArg(mapping, <span class="hljs-string">'generatedLine'</span>, <span class="hljs-literal">null</span>),
              <span class="hljs-attr">column</span>: util.getArg(mapping, <span class="hljs-string">'generatedColumn'</span>, <span class="hljs-literal">null</span>),
              <span class="hljs-attr">lastColumn</span>: util.getArg(mapping, <span class="hljs-string">'lastGeneratedColumn'</span>, <span class="hljs-literal">null</span>)
            });

            mapping = <span class="hljs-keyword">this</span>._originalMappings[++index];
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> originalColumn = mapping.originalColumn;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Iterate until either we run out of mappings, or we run into
a mapping for a different line than the one we were searching for.
Since mappings are sorted, this is guaranteed to find all mappings for
the line we are searching for.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">while</span> (mapping &amp;&amp;
                 mapping.originalLine === line &amp;&amp;
                 mapping.originalColumn == originalColumn) {
            mappings.push({
              <span class="hljs-attr">line</span>: util.getArg(mapping, <span class="hljs-string">'generatedLine'</span>, <span class="hljs-literal">null</span>),
              <span class="hljs-attr">column</span>: util.getArg(mapping, <span class="hljs-string">'generatedColumn'</span>, <span class="hljs-literal">null</span>),
              <span class="hljs-attr">lastColumn</span>: util.getArg(mapping, <span class="hljs-string">'lastGeneratedColumn'</span>, <span class="hljs-literal">null</span>)
            });

            mapping = <span class="hljs-keyword">this</span>._originalMappings[++index];
          }
        }
      }

      <span class="hljs-keyword">return</span> mappings;
    };

  exports.SourceMapConsumer = SourceMapConsumer;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<div class="dox">
<div class="summary">
<p>A BasicSourceMapConsumer instance represents a parsed source map which we can
query for information about the original file positions by giving it a file
position in the generated source.</p>
</div>
<div class="body">
<p>The only parameter is the raw source map (either as a JSON string, or
already parsed to an object). According to the spec, source maps have the
following attributes:</p>
<ul>
<li>version: Which version of the source map spec this map is following.</li>
<li>sources: An array of URLs to the original source files.</li>
<li>names: An array of identifiers which can be referrenced by individual mappings.</li>
<li>sourceRoot: Optional. The URL root from which all sources are relative.</li>
<li>sourcesContent: Optional. An array of contents of the original source files.</li>
<li>mappings: A string of base64 VLQs which contain the actual mappings.</li>
<li>file: Optional. The generated file this source map is associated with.</li>
</ul>
<p>Here is an example source map, taken from the source map spec<a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#">0</a>:</p>
<pre><code>{
  version : 3,
  file: &quot;out.js&quot;,
  sourceRoot : &quot;&quot;,
  sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],
  names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],
  mappings: &quot;AA,AB;;ABCDE;&quot;
}
</code></pre>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BasicSourceMapConsumer</span>(<span class="hljs-params">aSourceMap</span>) </span>{
    <span class="hljs-keyword">var</span> sourceMap = aSourceMap;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> aSourceMap === <span class="hljs-string">'string'</span>) {
      sourceMap = <span class="hljs-built_in">JSON</span>.parse(aSourceMap.replace(<span class="hljs-regexp">/^\)\]\}'/</span>, <span class="hljs-string">''</span>));
    }

    <span class="hljs-keyword">var</span> version = util.getArg(sourceMap, <span class="hljs-string">'version'</span>);
    <span class="hljs-keyword">var</span> sources = util.getArg(sourceMap, <span class="hljs-string">'sources'</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
requires the array) to play nice here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> names = util.getArg(sourceMap, <span class="hljs-string">'names'</span>, []);
    <span class="hljs-keyword">var</span> sourceRoot = util.getArg(sourceMap, <span class="hljs-string">'sourceRoot'</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> sourcesContent = util.getArg(sourceMap, <span class="hljs-string">'sourcesContent'</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> mappings = util.getArg(sourceMap, <span class="hljs-string">'mappings'</span>);
    <span class="hljs-keyword">var</span> file = util.getArg(sourceMap, <span class="hljs-string">'file'</span>, <span class="hljs-literal">null</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>Once again, Sass deviates from the spec and supplies the version as a
string rather than a number, so we use loose equality checking here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (version != <span class="hljs-keyword">this</span>._version) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unsupported version: '</span> + version);
    }

    sources = sources
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Some source maps produce relative source paths like &quot;./foo.js&quot; instead of
&quot;foo.js&quot;.  Normalize these first so that future comparisons will succeed.
See bugzil.la/1090768.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      .map(util.normalize)
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>Always ensure that absolute sources are internally stored relative to
the source root, if the source root is absolute. Not doing this would
be particularly problematic when the source root is a prefix of the
source (valid, but why??). See github issue #199 and bugzil.la/1188982.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      .map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>{
        <span class="hljs-keyword">return</span> sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source)
          ? util.relative(sourceRoot, source)
          : source;
      });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Pass <code>true</code> below to allow duplicate names and sources. While source maps
are intended to be compressed and deduplicated, the TypeScript compiler
sometimes generates source maps with duplicates in them. See Github issue
#72 and bugzil.la/889492.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>._names = ArraySet.fromArray(names, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">this</span>._sources = ArraySet.fromArray(sources, <span class="hljs-literal">true</span>);

    <span class="hljs-keyword">this</span>.sourceRoot = sourceRoot;
    <span class="hljs-keyword">this</span>.sourcesContent = sourcesContent;
    <span class="hljs-keyword">this</span>._mappings = mappings;
    <span class="hljs-keyword">this</span>.file = file;
  }

  BasicSourceMapConsumer.prototype = <span class="hljs-built_in">Object</span>.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<div class="dox">
<div class="summary">
<p>Create a BasicSourceMapConsumer from a SourceMapGenerator.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">SourceMapGenerator</span>
<span>aSourceMap        The source map that will be consumed.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  BasicSourceMapConsumer.fromSourceMap =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_fromSourceMap</span>(<span class="hljs-params">aSourceMap</span>) </span>{
      <span class="hljs-keyword">var</span> smc = <span class="hljs-built_in">Object</span>.create(BasicSourceMapConsumer.prototype);

      <span class="hljs-keyword">var</span> names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), <span class="hljs-literal">true</span>);
      <span class="hljs-keyword">var</span> sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), <span class="hljs-literal">true</span>);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>Because we are modifying the entries (by converting string sources and
names to indices into the sources and names ArraySets), we have to make
a copy of the entry or else bad things happen. Shared mutable state
strikes again! See github issue #191.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> generatedMappings = aSourceMap._mappings.toArray().slice();
      <span class="hljs-keyword">var</span> destGeneratedMappings = smc.__generatedMappings = [];
      <span class="hljs-keyword">var</span> destOriginalMappings = smc.__originalMappings = [];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, length = generatedMappings.length; i &lt; length; i++) {
        <span class="hljs-keyword">var</span> srcMapping = generatedMappings[i];
        <span class="hljs-keyword">var</span> destMapping = <span class="hljs-keyword">new</span> Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;

        <span class="hljs-keyword">if</span> (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;

          <span class="hljs-keyword">if</span> (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }

          destOriginalMappings.push(destMapping);
        }

        destGeneratedMappings.push(destMapping);
      }

      quickSort(smc.__originalMappings, util.compareByOriginalPositions);

      <span class="hljs-keyword">return</span> smc;
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<div class="dox">
<div class="summary">
<p>The version of the source mapping spec that we are consuming.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  BasicSourceMapConsumer.prototype._version = <span class="hljs-number">3</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<div class="dox">
<div class="summary">
<p>The list of original sources.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-built_in">Object</span>.defineProperty(BasicSourceMapConsumer.prototype, <span class="hljs-string">'sources'</span>, {
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._sources.toArray().map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sourceRoot != <span class="hljs-literal">null</span> ? util.join(<span class="hljs-keyword">this</span>.sourceRoot, s) : s;
      }, <span class="hljs-keyword">this</span>);
    }
  });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<div class="dox">
<div class="summary">
<p>Provide the JIT with a nice shape / hidden class.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mapping</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.generatedLine = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.generatedColumn = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.source = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.originalLine = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.originalColumn = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.name = <span class="hljs-literal">null</span>;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<div class="dox">
<div class="summary">
<p>Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the <code>this.__generatedMappings</code> and
<code>this.__originalMappings</code> properties).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  BasicSourceMapConsumer.prototype._parseMappings =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_parseMappings</span>(<span class="hljs-params">aStr, aSourceRoot</span>) </span>{
      <span class="hljs-keyword">var</span> generatedLine = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">var</span> previousGeneratedColumn = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> previousOriginalLine = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> previousOriginalColumn = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> previousSource = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> previousName = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> length = aStr.length;
      <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> cachedSegments = {};
      <span class="hljs-keyword">var</span> temp = {};
      <span class="hljs-keyword">var</span> originalMappings = [];
      <span class="hljs-keyword">var</span> generatedMappings = [];
      <span class="hljs-keyword">var</span> mapping, str, segment, end, value;

      <span class="hljs-keyword">while</span> (index &lt; length) {
        <span class="hljs-keyword">if</span> (aStr.charAt(index) === <span class="hljs-string">';'</span>) {
          generatedLine++;
          index++;
          previousGeneratedColumn = <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aStr.charAt(index) === <span class="hljs-string">','</span>) {
          index++;
        }
        <span class="hljs-keyword">else</span> {
          mapping = <span class="hljs-keyword">new</span> Mapping();
          mapping.generatedLine = generatedLine;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>Because each offset is encoded relative to the previous one,
many segments often have the same encoding. We can exploit this
fact by caching the parsed variable length fields of each segment,
allowing us to avoid a second parse if we encounter the same
segment again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">for</span> (end = index; end &lt; length; end++) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._charIsMappingSeparator(aStr, end)) {
              <span class="hljs-keyword">break</span>;
            }
          }
          str = aStr.slice(index, end);

          segment = cachedSegments[str];
          <span class="hljs-keyword">if</span> (segment) {
            index += str.length;
          } <span class="hljs-keyword">else</span> {
            segment = [];
            <span class="hljs-keyword">while</span> (index &lt; end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }

            <span class="hljs-keyword">if</span> (segment.length === <span class="hljs-number">2</span>) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Found a source, but no line and column'</span>);
            }

            <span class="hljs-keyword">if</span> (segment.length === <span class="hljs-number">3</span>) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Found a source and line, but no column'</span>);
            }

            cachedSegments[str] = segment;
          }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>Generated column.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          mapping.generatedColumn = previousGeneratedColumn + segment[<span class="hljs-number">0</span>];
          previousGeneratedColumn = mapping.generatedColumn;

          <span class="hljs-keyword">if</span> (segment.length &gt; <span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>Original source.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            mapping.source = previousSource + segment[<span class="hljs-number">1</span>];
            previousSource += segment[<span class="hljs-number">1</span>];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>Original line.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            mapping.originalLine = previousOriginalLine + segment[<span class="hljs-number">2</span>];
            previousOriginalLine = mapping.originalLine;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>Lines are stored 0-based</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            mapping.originalLine += <span class="hljs-number">1</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>Original column.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            mapping.originalColumn = previousOriginalColumn + segment[<span class="hljs-number">3</span>];
            previousOriginalColumn = mapping.originalColumn;

            <span class="hljs-keyword">if</span> (segment.length &gt; <span class="hljs-number">4</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>Original name.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              mapping.name = previousName + segment[<span class="hljs-number">4</span>];
              previousName += segment[<span class="hljs-number">4</span>];
            }
          }

          generatedMappings.push(mapping);
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> mapping.originalLine === <span class="hljs-string">'number'</span>) {
            originalMappings.push(mapping);
          }
        }
      }

      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      <span class="hljs-keyword">this</span>.__generatedMappings = generatedMappings;

      quickSort(originalMappings, util.compareByOriginalPositions);
      <span class="hljs-keyword">this</span>.__originalMappings = originalMappings;
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<div class="dox">
<div class="summary">
<p>Find the mapping that best matches the hypothetical &quot;needle&quot; mapping that
we are searching for in the given &quot;haystack&quot; of mappings.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  BasicSourceMapConsumer.prototype._findMapping =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_findMapping</span>(<span class="hljs-params">aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator, aBias</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>To return the position we are searching for, we must first find the
mapping for the given position and then return the opposite position it
points to. Because the mappings are sorted, we can use binary search to
find the best mapping.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (aNeedle[aLineName] &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Line must be greater than or equal to 1, got '</span>
                            + aNeedle[aLineName]);
      }
      <span class="hljs-keyword">if</span> (aNeedle[aColumnName] &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Column must be greater than or equal to 0, got '</span>
                            + aNeedle[aColumnName]);
      }

      <span class="hljs-keyword">return</span> binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<div class="dox">
<div class="summary">
<p>Compute the last column for each generated mapping. The last column is
inclusive.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  BasicSourceMapConsumer.prototype.computeColumnSpans =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_computeColumnSpans</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-keyword">this</span>._generatedMappings.length; ++index) {
        <span class="hljs-keyword">var</span> mapping = <span class="hljs-keyword">this</span>._generatedMappings[index];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>Mappings do not contain a field for the last generated columnt. We
can come up with an optimistic estimate, however, by assuming that
mappings are contiguous (i.e. given two consecutive mappings, the
first mapping ends where the second one starts).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">this</span>._generatedMappings.length) {
          <span class="hljs-keyword">var</span> nextMapping = <span class="hljs-keyword">this</span>._generatedMappings[index + <span class="hljs-number">1</span>];

          <span class="hljs-keyword">if</span> (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">continue</span>;
          }
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>The last mapping for each line spans the entire line.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        mapping.lastGeneratedColumn = <span class="hljs-literal">Infinity</span>;
      }
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the original source, line, and column information for the generated
source's line and column positions provided. The only argument is an object
with the following properties:</p>
</div>
<div class="body">
<ul>
<li>line: The line number in the generated source.
<ul>
<li>column: The column number in the generated source.</li>
<li>bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
closest element that is smaller than or greater than the one we are
searching for, respectively, if the exact element cannot be found.
Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</li>
</ul>
</li>
</ul>
<p>and an object is returned with the following properties:</p>
<ul>
<li>source: The original source file, or null.</li>
<li>line: The line number in the original source, or null.</li>
<li>column: The column number in the original source, or null.</li>
<li>name: The original identifier, or null.</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  BasicSourceMapConsumer.prototype.originalPositionFor =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_originalPositionFor</span>(<span class="hljs-params">aArgs</span>) </span>{
      <span class="hljs-keyword">var</span> needle = {
        <span class="hljs-attr">generatedLine</span>: util.getArg(aArgs, <span class="hljs-string">'line'</span>),
        <span class="hljs-attr">generatedColumn</span>: util.getArg(aArgs, <span class="hljs-string">'column'</span>)
      };

      <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>._findMapping(
        needle,
        <span class="hljs-keyword">this</span>._generatedMappings,
        <span class="hljs-string">"generatedLine"</span>,
        <span class="hljs-string">"generatedColumn"</span>,
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, <span class="hljs-string">'bias'</span>, SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> mapping = <span class="hljs-keyword">this</span>._generatedMappings[index];

        <span class="hljs-keyword">if</span> (mapping.generatedLine === needle.generatedLine) {
          <span class="hljs-keyword">var</span> source = util.getArg(mapping, <span class="hljs-string">'source'</span>, <span class="hljs-literal">null</span>);
          <span class="hljs-keyword">if</span> (source !== <span class="hljs-literal">null</span>) {
            source = <span class="hljs-keyword">this</span>._sources.at(source);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sourceRoot != <span class="hljs-literal">null</span>) {
              source = util.join(<span class="hljs-keyword">this</span>.sourceRoot, source);
            }
          }
          <span class="hljs-keyword">var</span> name = util.getArg(mapping, <span class="hljs-string">'name'</span>, <span class="hljs-literal">null</span>);
          <span class="hljs-keyword">if</span> (name !== <span class="hljs-literal">null</span>) {
            name = <span class="hljs-keyword">this</span>._names.at(name);
          }
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">source</span>: source,
            <span class="hljs-attr">line</span>: util.getArg(mapping, <span class="hljs-string">'originalLine'</span>, <span class="hljs-literal">null</span>),
            <span class="hljs-attr">column</span>: util.getArg(mapping, <span class="hljs-string">'originalColumn'</span>, <span class="hljs-literal">null</span>),
            <span class="hljs-attr">name</span>: name
          };
        }
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">source</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">line</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-literal">null</span>
      };
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return true if we have the source content for every source in the source
map, false otherwise.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BasicSourceMapConsumer_hasContentsOfAllSources</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.sourcesContent) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sourcesContent.length &gt;= <span class="hljs-keyword">this</span>._sources.size() &amp;&amp;
        !<span class="hljs-keyword">this</span>.sourcesContent.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sc</span>) </span>{ <span class="hljs-keyword">return</span> sc == <span class="hljs-literal">null</span>; });
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the original source content. The only argument is the url of the
original source file. Returns null if no original source content is
available.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  BasicSourceMapConsumer.prototype.sourceContentFor =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_sourceContentFor</span>(<span class="hljs-params">aSource, nullOnMissing</span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.sourcesContent) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sourceRoot != <span class="hljs-literal">null</span>) {
        aSource = util.relative(<span class="hljs-keyword">this</span>.sourceRoot, aSource);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._sources.has(aSource)) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sourcesContent[<span class="hljs-keyword">this</span>._sources.indexOf(aSource)];
      }

      <span class="hljs-keyword">var</span> url;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sourceRoot != <span class="hljs-literal">null</span>
          &amp;&amp; (url = util.urlParse(<span class="hljs-keyword">this</span>.sourceRoot))) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<p>XXX: file:// URIs and absolute paths lead to unexpected behavior for
many users. We can help them out when they expect file:// URIs to
behave like it would if they were running a local HTTP server. See
https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> fileUriAbsPath = aSource.replace(<span class="hljs-regexp">/^file:\/\//</span>, <span class="hljs-string">""</span>);
        <span class="hljs-keyword">if</span> (url.scheme == <span class="hljs-string">"file"</span>
            &amp;&amp; <span class="hljs-keyword">this</span>._sources.has(fileUriAbsPath)) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sourcesContent[<span class="hljs-keyword">this</span>._sources.indexOf(fileUriAbsPath)]
        }

        <span class="hljs-keyword">if</span> ((!url.path || url.path == <span class="hljs-string">"/"</span>)
            &amp;&amp; <span class="hljs-keyword">this</span>._sources.has(<span class="hljs-string">"/"</span> + aSource)) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sourcesContent[<span class="hljs-keyword">this</span>._sources.indexOf(<span class="hljs-string">"/"</span> + aSource)];
        }
      }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>This function is used recursively from
IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
don't want to throw if we can't find the source - we just want to
return null, so we provide a flag to exit gracefully.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (nullOnMissing) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'"'</span> + aSource + <span class="hljs-string">'" is not in the SourceMap.'</span>);
      }
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the generated line and column information for the original source,
line, and column positions provided. The only argument is an object with
the following properties:</p>
</div>
<div class="body">
<ul>
<li>source: The filename of the original source.
<ul>
<li>line: The line number in the original source.</li>
<li>column: The column number in the original source.</li>
<li>bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
closest element that is smaller than or greater than the one we are
searching for, respectively, if the exact element cannot be found.
Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</li>
</ul>
</li>
</ul>
<p>and an object is returned with the following properties:</p>
<ul>
<li>line: The line number in the generated source, or null.</li>
<li>column: The column number in the generated source, or null.</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  BasicSourceMapConsumer.prototype.generatedPositionFor =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_generatedPositionFor</span>(<span class="hljs-params">aArgs</span>) </span>{
      <span class="hljs-keyword">var</span> source = util.getArg(aArgs, <span class="hljs-string">'source'</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sourceRoot != <span class="hljs-literal">null</span>) {
        source = util.relative(<span class="hljs-keyword">this</span>.sourceRoot, source);
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._sources.has(source)) {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">line</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-attr">column</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-attr">lastColumn</span>: <span class="hljs-literal">null</span>
        };
      }
      source = <span class="hljs-keyword">this</span>._sources.indexOf(source);

      <span class="hljs-keyword">var</span> needle = {
        <span class="hljs-attr">source</span>: source,
        <span class="hljs-attr">originalLine</span>: util.getArg(aArgs, <span class="hljs-string">'line'</span>),
        <span class="hljs-attr">originalColumn</span>: util.getArg(aArgs, <span class="hljs-string">'column'</span>)
      };

      <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>._findMapping(
        needle,
        <span class="hljs-keyword">this</span>._originalMappings,
        <span class="hljs-string">"originalLine"</span>,
        <span class="hljs-string">"originalColumn"</span>,
        util.compareByOriginalPositions,
        util.getArg(aArgs, <span class="hljs-string">'bias'</span>, SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> mapping = <span class="hljs-keyword">this</span>._originalMappings[index];

        <span class="hljs-keyword">if</span> (mapping.source === needle.source) {
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">line</span>: util.getArg(mapping, <span class="hljs-string">'generatedLine'</span>, <span class="hljs-literal">null</span>),
            <span class="hljs-attr">column</span>: util.getArg(mapping, <span class="hljs-string">'generatedColumn'</span>, <span class="hljs-literal">null</span>),
            <span class="hljs-attr">lastColumn</span>: util.getArg(mapping, <span class="hljs-string">'lastGeneratedColumn'</span>, <span class="hljs-literal">null</span>)
          };
        }
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">line</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">lastColumn</span>: <span class="hljs-literal">null</span>
      };
    };

  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<div class="dox">
<div class="summary">
<p>An IndexedSourceMapConsumer instance represents a parsed source map which
we can query for information. It differs from BasicSourceMapConsumer in
that it takes &quot;indexed&quot; source maps (i.e. ones with a &quot;sections&quot; field) as
input.</p>
</div>
<div class="body">
<p>The only parameter is a raw source map (either as a JSON string, or already
parsed to an object). According to the spec for indexed source maps, they
have the following attributes:</p>
<ul>
<li>version: Which version of the source map spec this map is following.</li>
<li>file: Optional. The generated file this source map is associated with.</li>
<li>sections: A list of section definitions.</li>
</ul>
<p>Each value under the &quot;sections&quot; field has two fields:</p>
<ul>
<li>offset: The offset into the original specified at which this section
begins to apply, defined as an object with a &quot;line&quot; and &quot;column&quot;
field.</li>
<li>map: A source map definition. This source map could also be indexed,
but doesn't have to be.</li>
</ul>
<p>Instead of the &quot;map&quot; field, it's also possible to have a &quot;url&quot; field
specifying a URL to retrieve a source map from, but that's currently
unsupported.</p>
<p>Here's an example source map, taken from the source map spec<a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt">0</a>, but
modified to omit a section which uses the &quot;url&quot; field.</p>
<p>{
version : 3,
file: &quot;app.js&quot;,
sections: [{
offset: {line:100, column:10},
map: {
version : 3,
file: &quot;section.js&quot;,
sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],
names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],
mappings: &quot;AAAA,E;;ABCDE;&quot;
}
}],
}</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IndexedSourceMapConsumer</span>(<span class="hljs-params">aSourceMap</span>) </span>{
    <span class="hljs-keyword">var</span> sourceMap = aSourceMap;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> aSourceMap === <span class="hljs-string">'string'</span>) {
      sourceMap = <span class="hljs-built_in">JSON</span>.parse(aSourceMap.replace(<span class="hljs-regexp">/^\)\]\}'/</span>, <span class="hljs-string">''</span>));
    }

    <span class="hljs-keyword">var</span> version = util.getArg(sourceMap, <span class="hljs-string">'version'</span>);
    <span class="hljs-keyword">var</span> sections = util.getArg(sourceMap, <span class="hljs-string">'sections'</span>);

    <span class="hljs-keyword">if</span> (version != <span class="hljs-keyword">this</span>._version) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unsupported version: '</span> + version);
    }

    <span class="hljs-keyword">this</span>._sources = <span class="hljs-keyword">new</span> ArraySet();
    <span class="hljs-keyword">this</span>._names = <span class="hljs-keyword">new</span> ArraySet();

    <span class="hljs-keyword">var</span> lastOffset = {
      <span class="hljs-attr">line</span>: <span class="hljs-number">-1</span>,
      <span class="hljs-attr">column</span>: <span class="hljs-number">0</span>
    };
    <span class="hljs-keyword">this</span>._sections = sections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
      <span class="hljs-keyword">if</span> (s.url) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<p>The url field will require support for asynchronicity.
See https://github.com/mozilla/source-map/issues/16</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Support for url field in sections not implemented.'</span>);
      }
      <span class="hljs-keyword">var</span> offset = util.getArg(s, <span class="hljs-string">'offset'</span>);
      <span class="hljs-keyword">var</span> offsetLine = util.getArg(offset, <span class="hljs-string">'line'</span>);
      <span class="hljs-keyword">var</span> offsetColumn = util.getArg(offset, <span class="hljs-string">'column'</span>);

      <span class="hljs-keyword">if</span> (offsetLine &lt; lastOffset.line ||
          (offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Section offsets must be ordered and non-overlapping.'</span>);
      }
      lastOffset = offset;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">generatedOffset</span>: {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<p>The offset fields are 0-based, but we use 1-based indices when
encoding/decoding from VLQ.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          generatedLine: offsetLine + <span class="hljs-number">1</span>,
          <span class="hljs-attr">generatedColumn</span>: offsetColumn + <span class="hljs-number">1</span>
        },
        <span class="hljs-attr">consumer</span>: <span class="hljs-keyword">new</span> SourceMapConsumer(util.getArg(s, <span class="hljs-string">'map'</span>))
      }
    });
  }

  IndexedSourceMapConsumer.prototype = <span class="hljs-built_in">Object</span>.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<div class="dox">
<div class="summary">
<p>The version of the source mapping spec that we are consuming.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  IndexedSourceMapConsumer.prototype._version = <span class="hljs-number">3</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<div class="dox">
<div class="summary">
<p>The list of original sources.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-built_in">Object</span>.defineProperty(IndexedSourceMapConsumer.prototype, <span class="hljs-string">'sources'</span>, {
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> sources = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>._sections.length; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">this</span>._sections[i].consumer.sources.length; j++) {
          sources.push(<span class="hljs-keyword">this</span>._sections[i].consumer.sources[j]);
        }
      }
      <span class="hljs-keyword">return</span> sources;
    }
  });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the original source, line, and column information for the generated
source's line and column positions provided. The only argument is an object
with the following properties:</p>
</div>
<div class="body">
<ul>
<li>line: The line number in the generated source.
<ul>
<li>column: The column number in the generated source.</li>
</ul>
</li>
</ul>
<p>and an object is returned with the following properties:</p>
<ul>
<li>source: The original source file, or null.</li>
<li>line: The line number in the original source, or null.</li>
<li>column: The column number in the original source, or null.</li>
<li>name: The original identifier, or null.</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  IndexedSourceMapConsumer.prototype.originalPositionFor =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IndexedSourceMapConsumer_originalPositionFor</span>(<span class="hljs-params">aArgs</span>) </span>{
      <span class="hljs-keyword">var</span> needle = {
        <span class="hljs-attr">generatedLine</span>: util.getArg(aArgs, <span class="hljs-string">'line'</span>),
        <span class="hljs-attr">generatedColumn</span>: util.getArg(aArgs, <span class="hljs-string">'column'</span>)
      };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<p>Find the section containing the generated position we're trying to map
to an original position.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> sectionIndex = binarySearch.search(needle, <span class="hljs-keyword">this</span>._sections,
        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">needle, section</span>) </span>{
          <span class="hljs-keyword">var</span> cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          <span class="hljs-keyword">if</span> (cmp) {
            <span class="hljs-keyword">return</span> cmp;
          }

          <span class="hljs-keyword">return</span> (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        });
      <span class="hljs-keyword">var</span> section = <span class="hljs-keyword">this</span>._sections[sectionIndex];

      <span class="hljs-keyword">if</span> (!section) {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">source</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-attr">line</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-attr">column</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-literal">null</span>
        };
      }

      <span class="hljs-keyword">return</span> section.consumer.originalPositionFor({
        <span class="hljs-attr">line</span>: needle.generatedLine -
          (section.generatedOffset.generatedLine - <span class="hljs-number">1</span>),
        <span class="hljs-attr">column</span>: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - <span class="hljs-number">1</span>
           : <span class="hljs-number">0</span>),
        <span class="hljs-attr">bias</span>: aArgs.bias
      });
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return true if we have the source content for every source in the source
map, false otherwise.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IndexedSourceMapConsumer_hasContentsOfAllSources</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._sections.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
        <span class="hljs-keyword">return</span> s.consumer.hasContentsOfAllSources();
      });
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-49" id="section-49"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the original source content. The only argument is the url of the
original source file. Returns null if no original source content is
available.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  IndexedSourceMapConsumer.prototype.sourceContentFor =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IndexedSourceMapConsumer_sourceContentFor</span>(<span class="hljs-params">aSource, nullOnMissing</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>._sections.length; i++) {
        <span class="hljs-keyword">var</span> section = <span class="hljs-keyword">this</span>._sections[i];

        <span class="hljs-keyword">var</span> content = section.consumer.sourceContentFor(aSource, <span class="hljs-literal">true</span>);
        <span class="hljs-keyword">if</span> (content) {
          <span class="hljs-keyword">return</span> content;
        }
      }
      <span class="hljs-keyword">if</span> (nullOnMissing) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'"'</span> + aSource + <span class="hljs-string">'" is not in the SourceMap.'</span>);
      }
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-50" id="section-50"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the generated line and column information for the original source,
line, and column positions provided. The only argument is an object with
the following properties:</p>
</div>
<div class="body">
<ul>
<li>source: The filename of the original source.
<ul>
<li>line: The line number in the original source.</li>
<li>column: The column number in the original source.</li>
</ul>
</li>
</ul>
<p>and an object is returned with the following properties:</p>
<ul>
<li>line: The line number in the generated source, or null.</li>
<li>column: The column number in the generated source, or null.</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IndexedSourceMapConsumer_generatedPositionFor</span>(<span class="hljs-params">aArgs</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>._sections.length; i++) {
        <span class="hljs-keyword">var</span> section = <span class="hljs-keyword">this</span>._sections[i];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-51" id="section-51"></a>
</div>
<p>Only consider this section if the requested source is in the list of
sources of the consumer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (section.consumer.sources.indexOf(util.getArg(aArgs, <span class="hljs-string">'source'</span>)) === <span class="hljs-number">-1</span>) {
          <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">var</span> generatedPosition = section.consumer.generatedPositionFor(aArgs);
        <span class="hljs-keyword">if</span> (generatedPosition) {
          <span class="hljs-keyword">var</span> ret = {
            <span class="hljs-attr">line</span>: generatedPosition.line +
              (section.generatedOffset.generatedLine - <span class="hljs-number">1</span>),
            <span class="hljs-attr">column</span>: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - <span class="hljs-number">1</span>
               : <span class="hljs-number">0</span>)
          };
          <span class="hljs-keyword">return</span> ret;
        }
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">line</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-literal">null</span>
      };
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-52" id="section-52"></a>
</div>
<div class="dox">
<div class="summary">
<p>Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the <code>this.__generatedMappings</code> and
<code>this.__originalMappings</code> properties).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  IndexedSourceMapConsumer.prototype._parseMappings =
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IndexedSourceMapConsumer_parseMappings</span>(<span class="hljs-params">aStr, aSourceRoot</span>) </span>{
      <span class="hljs-keyword">this</span>.__generatedMappings = [];
      <span class="hljs-keyword">this</span>.__originalMappings = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>._sections.length; i++) {
        <span class="hljs-keyword">var</span> section = <span class="hljs-keyword">this</span>._sections[i];
        <span class="hljs-keyword">var</span> sectionMappings = section.consumer._generatedMappings;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; sectionMappings.length; j++) {
          <span class="hljs-keyword">var</span> mapping = sectionMappings[j];

          <span class="hljs-keyword">var</span> source = section.consumer._sources.at(mapping.source);
          <span class="hljs-keyword">if</span> (section.consumer.sourceRoot !== <span class="hljs-literal">null</span>) {
            source = util.join(section.consumer.sourceRoot, source);
          }
          <span class="hljs-keyword">this</span>._sources.add(source);
          source = <span class="hljs-keyword">this</span>._sources.indexOf(source);

          <span class="hljs-keyword">var</span> name = section.consumer._names.at(mapping.name);
          <span class="hljs-keyword">this</span>._names.add(name);
          name = <span class="hljs-keyword">this</span>._names.indexOf(name);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-53" id="section-53"></a>
</div>
<p>The mappings coming from the consumer for the section have
generated positions relative to the start of the section, so we
need to offset them to be relative to the start of the concatenated
generated file.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> adjustedMapping = {
            <span class="hljs-attr">source</span>: source,
            <span class="hljs-attr">generatedLine</span>: mapping.generatedLine +
              (section.generatedOffset.generatedLine - <span class="hljs-number">1</span>),
            <span class="hljs-attr">generatedColumn</span>: mapping.generatedColumn +
              (section.generatedOffset.generatedLine === mapping.generatedLine
              ? section.generatedOffset.generatedColumn - <span class="hljs-number">1</span>
              : <span class="hljs-number">0</span>),
            <span class="hljs-attr">originalLine</span>: mapping.originalLine,
            <span class="hljs-attr">originalColumn</span>: mapping.originalColumn,
            <span class="hljs-attr">name</span>: name
          };

          <span class="hljs-keyword">this</span>.__generatedMappings.push(adjustedMapping);
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> adjustedMapping.originalLine === <span class="hljs-string">'number'</span>) {
            <span class="hljs-keyword">this</span>.__originalMappings.push(adjustedMapping);
          }
        }
      }

      quickSort(<span class="hljs-keyword">this</span>.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(<span class="hljs-keyword">this</span>.__originalMappings, util.compareByOriginalPositions);
    };

  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
