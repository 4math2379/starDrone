<!DOCTYPE html>
<html>
<head>
  <title>esprima.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../doc-style.css" />
  <script src="../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../";
    var thisFile = "node_modules/serialport/node_modules/esprima/esprima.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>esprima.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.</p>
</div>
<div class="body">
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, factory</span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
Rhino, and plain browser loading.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-comment">/* istanbul ignore next */</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {
        define([<span class="hljs-string">'exports'</span>], factory);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports !== <span class="hljs-string">'undefined'</span>) {
        factory(exports);
    } <span class="hljs-keyword">else</span> {
        factory((root.esprima = {}));
    }
}(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">exports</span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-keyword">var</span> Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        hasLineTerminator,
        lastIndex,
        lastLineNumber,
        lastLineStart,
        startIndex,
        startLineNumber,
        startLineStart,
        scanning,
        length,
        lookahead,
        state,
        extra,
        isBindingElement,
        isAssignmentTarget,
        firstCoverInitializedNameError;

    Token = {
        <span class="hljs-attr">BooleanLiteral</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">EOF</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">Identifier</span>: <span class="hljs-number">3</span>,
        <span class="hljs-attr">Keyword</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">NullLiteral</span>: <span class="hljs-number">5</span>,
        <span class="hljs-attr">NumericLiteral</span>: <span class="hljs-number">6</span>,
        <span class="hljs-attr">Punctuator</span>: <span class="hljs-number">7</span>,
        <span class="hljs-attr">StringLiteral</span>: <span class="hljs-number">8</span>,
        <span class="hljs-attr">RegularExpression</span>: <span class="hljs-number">9</span>,
        <span class="hljs-attr">Template</span>: <span class="hljs-number">10</span>
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = <span class="hljs-string">'Boolean'</span>;
    TokenName[Token.EOF] = <span class="hljs-string">'&lt;end&gt;'</span>;
    TokenName[Token.Identifier] = <span class="hljs-string">'Identifier'</span>;
    TokenName[Token.Keyword] = <span class="hljs-string">'Keyword'</span>;
    TokenName[Token.NullLiteral] = <span class="hljs-string">'Null'</span>;
    TokenName[Token.NumericLiteral] = <span class="hljs-string">'Numeric'</span>;
    TokenName[Token.Punctuator] = <span class="hljs-string">'Punctuator'</span>;
    TokenName[Token.StringLiteral] = <span class="hljs-string">'String'</span>;
    TokenName[Token.RegularExpression] = <span class="hljs-string">'RegularExpression'</span>;
    TokenName[Token.Template] = <span class="hljs-string">'Template'</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>A function following one of those tokens is an expression.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    FnExprTokens = [<span class="hljs-string">'('</span>, <span class="hljs-string">'{'</span>, <span class="hljs-string">'['</span>, <span class="hljs-string">'in'</span>, <span class="hljs-string">'typeof'</span>, <span class="hljs-string">'instanceof'</span>, <span class="hljs-string">'new'</span>,
                    <span class="hljs-string">'return'</span>, <span class="hljs-string">'case'</span>, <span class="hljs-string">'delete'</span>, <span class="hljs-string">'throw'</span>, <span class="hljs-string">'void'</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>assignment operators</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    <span class="hljs-string">'='</span>, <span class="hljs-string">'+='</span>, <span class="hljs-string">'-='</span>, <span class="hljs-string">'*='</span>, <span class="hljs-string">'/='</span>, <span class="hljs-string">'%='</span>, <span class="hljs-string">'&lt;&lt;='</span>, <span class="hljs-string">'&gt;&gt;='</span>, <span class="hljs-string">'&gt;&gt;&gt;='</span>,
                    <span class="hljs-string">'&amp;='</span>, <span class="hljs-string">'|='</span>, <span class="hljs-string">'^='</span>, <span class="hljs-string">','</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>binary/unary operators</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    <span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'/'</span>, <span class="hljs-string">'%'</span>, <span class="hljs-string">'++'</span>, <span class="hljs-string">'--'</span>, <span class="hljs-string">'&lt;&lt;'</span>, <span class="hljs-string">'&gt;&gt;'</span>, <span class="hljs-string">'&gt;&gt;&gt;'</span>, <span class="hljs-string">'&amp;'</span>,
                    <span class="hljs-string">'|'</span>, <span class="hljs-string">'^'</span>, <span class="hljs-string">'!'</span>, <span class="hljs-string">'~'</span>, <span class="hljs-string">'&amp;&amp;'</span>, <span class="hljs-string">'||'</span>, <span class="hljs-string">'?'</span>, <span class="hljs-string">':'</span>, <span class="hljs-string">'==='</span>, <span class="hljs-string">'=='</span>, <span class="hljs-string">'&gt;='</span>,
                    <span class="hljs-string">'&lt;='</span>, <span class="hljs-string">'&lt;'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-string">'!='</span>, <span class="hljs-string">'!=='</span>];

    Syntax = {
        <span class="hljs-attr">AssignmentExpression</span>: <span class="hljs-string">'AssignmentExpression'</span>,
        <span class="hljs-attr">AssignmentPattern</span>: <span class="hljs-string">'AssignmentPattern'</span>,
        <span class="hljs-attr">ArrayExpression</span>: <span class="hljs-string">'ArrayExpression'</span>,
        <span class="hljs-attr">ArrayPattern</span>: <span class="hljs-string">'ArrayPattern'</span>,
        <span class="hljs-attr">ArrowFunctionExpression</span>: <span class="hljs-string">'ArrowFunctionExpression'</span>,
        <span class="hljs-attr">BlockStatement</span>: <span class="hljs-string">'BlockStatement'</span>,
        <span class="hljs-attr">BinaryExpression</span>: <span class="hljs-string">'BinaryExpression'</span>,
        <span class="hljs-attr">BreakStatement</span>: <span class="hljs-string">'BreakStatement'</span>,
        <span class="hljs-attr">CallExpression</span>: <span class="hljs-string">'CallExpression'</span>,
        <span class="hljs-attr">CatchClause</span>: <span class="hljs-string">'CatchClause'</span>,
        <span class="hljs-attr">ClassBody</span>: <span class="hljs-string">'ClassBody'</span>,
        <span class="hljs-attr">ClassDeclaration</span>: <span class="hljs-string">'ClassDeclaration'</span>,
        <span class="hljs-attr">ClassExpression</span>: <span class="hljs-string">'ClassExpression'</span>,
        <span class="hljs-attr">ConditionalExpression</span>: <span class="hljs-string">'ConditionalExpression'</span>,
        <span class="hljs-attr">ContinueStatement</span>: <span class="hljs-string">'ContinueStatement'</span>,
        <span class="hljs-attr">DoWhileStatement</span>: <span class="hljs-string">'DoWhileStatement'</span>,
        <span class="hljs-attr">DebuggerStatement</span>: <span class="hljs-string">'DebuggerStatement'</span>,
        <span class="hljs-attr">EmptyStatement</span>: <span class="hljs-string">'EmptyStatement'</span>,
        <span class="hljs-attr">ExportAllDeclaration</span>: <span class="hljs-string">'ExportAllDeclaration'</span>,
        <span class="hljs-attr">ExportDefaultDeclaration</span>: <span class="hljs-string">'ExportDefaultDeclaration'</span>,
        <span class="hljs-attr">ExportNamedDeclaration</span>: <span class="hljs-string">'ExportNamedDeclaration'</span>,
        <span class="hljs-attr">ExportSpecifier</span>: <span class="hljs-string">'ExportSpecifier'</span>,
        <span class="hljs-attr">ExpressionStatement</span>: <span class="hljs-string">'ExpressionStatement'</span>,
        <span class="hljs-attr">ForStatement</span>: <span class="hljs-string">'ForStatement'</span>,
        <span class="hljs-attr">ForOfStatement</span>: <span class="hljs-string">'ForOfStatement'</span>,
        <span class="hljs-attr">ForInStatement</span>: <span class="hljs-string">'ForInStatement'</span>,
        <span class="hljs-attr">FunctionDeclaration</span>: <span class="hljs-string">'FunctionDeclaration'</span>,
        <span class="hljs-attr">FunctionExpression</span>: <span class="hljs-string">'FunctionExpression'</span>,
        <span class="hljs-attr">Identifier</span>: <span class="hljs-string">'Identifier'</span>,
        <span class="hljs-attr">IfStatement</span>: <span class="hljs-string">'IfStatement'</span>,
        <span class="hljs-attr">ImportDeclaration</span>: <span class="hljs-string">'ImportDeclaration'</span>,
        <span class="hljs-attr">ImportDefaultSpecifier</span>: <span class="hljs-string">'ImportDefaultSpecifier'</span>,
        <span class="hljs-attr">ImportNamespaceSpecifier</span>: <span class="hljs-string">'ImportNamespaceSpecifier'</span>,
        <span class="hljs-attr">ImportSpecifier</span>: <span class="hljs-string">'ImportSpecifier'</span>,
        <span class="hljs-attr">Literal</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">LabeledStatement</span>: <span class="hljs-string">'LabeledStatement'</span>,
        <span class="hljs-attr">LogicalExpression</span>: <span class="hljs-string">'LogicalExpression'</span>,
        <span class="hljs-attr">MemberExpression</span>: <span class="hljs-string">'MemberExpression'</span>,
        <span class="hljs-attr">MetaProperty</span>: <span class="hljs-string">'MetaProperty'</span>,
        <span class="hljs-attr">MethodDefinition</span>: <span class="hljs-string">'MethodDefinition'</span>,
        <span class="hljs-attr">NewExpression</span>: <span class="hljs-string">'NewExpression'</span>,
        <span class="hljs-attr">ObjectExpression</span>: <span class="hljs-string">'ObjectExpression'</span>,
        <span class="hljs-attr">ObjectPattern</span>: <span class="hljs-string">'ObjectPattern'</span>,
        <span class="hljs-attr">Program</span>: <span class="hljs-string">'Program'</span>,
        <span class="hljs-attr">Property</span>: <span class="hljs-string">'Property'</span>,
        <span class="hljs-attr">RestElement</span>: <span class="hljs-string">'RestElement'</span>,
        <span class="hljs-attr">ReturnStatement</span>: <span class="hljs-string">'ReturnStatement'</span>,
        <span class="hljs-attr">SequenceExpression</span>: <span class="hljs-string">'SequenceExpression'</span>,
        <span class="hljs-attr">SpreadElement</span>: <span class="hljs-string">'SpreadElement'</span>,
        <span class="hljs-attr">Super</span>: <span class="hljs-string">'Super'</span>,
        <span class="hljs-attr">SwitchCase</span>: <span class="hljs-string">'SwitchCase'</span>,
        <span class="hljs-attr">SwitchStatement</span>: <span class="hljs-string">'SwitchStatement'</span>,
        <span class="hljs-attr">TaggedTemplateExpression</span>: <span class="hljs-string">'TaggedTemplateExpression'</span>,
        <span class="hljs-attr">TemplateElement</span>: <span class="hljs-string">'TemplateElement'</span>,
        <span class="hljs-attr">TemplateLiteral</span>: <span class="hljs-string">'TemplateLiteral'</span>,
        <span class="hljs-attr">ThisExpression</span>: <span class="hljs-string">'ThisExpression'</span>,
        <span class="hljs-attr">ThrowStatement</span>: <span class="hljs-string">'ThrowStatement'</span>,
        <span class="hljs-attr">TryStatement</span>: <span class="hljs-string">'TryStatement'</span>,
        <span class="hljs-attr">UnaryExpression</span>: <span class="hljs-string">'UnaryExpression'</span>,
        <span class="hljs-attr">UpdateExpression</span>: <span class="hljs-string">'UpdateExpression'</span>,
        <span class="hljs-attr">VariableDeclaration</span>: <span class="hljs-string">'VariableDeclaration'</span>,
        <span class="hljs-attr">VariableDeclarator</span>: <span class="hljs-string">'VariableDeclarator'</span>,
        <span class="hljs-attr">WhileStatement</span>: <span class="hljs-string">'WhileStatement'</span>,
        <span class="hljs-attr">WithStatement</span>: <span class="hljs-string">'WithStatement'</span>,
        <span class="hljs-attr">YieldExpression</span>: <span class="hljs-string">'YieldExpression'</span>
    };

    PlaceHolders = {
        <span class="hljs-attr">ArrowParameterPlaceHolder</span>: <span class="hljs-string">'ArrowParameterPlaceHolder'</span>
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Error messages should be identical to V8.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    Messages = {
        <span class="hljs-attr">UnexpectedToken</span>: <span class="hljs-string">'Unexpected token %0'</span>,
        <span class="hljs-attr">UnexpectedNumber</span>: <span class="hljs-string">'Unexpected number'</span>,
        <span class="hljs-attr">UnexpectedString</span>: <span class="hljs-string">'Unexpected string'</span>,
        <span class="hljs-attr">UnexpectedIdentifier</span>: <span class="hljs-string">'Unexpected identifier'</span>,
        <span class="hljs-attr">UnexpectedReserved</span>: <span class="hljs-string">'Unexpected reserved word'</span>,
        <span class="hljs-attr">UnexpectedTemplate</span>: <span class="hljs-string">'Unexpected quasi %0'</span>,
        <span class="hljs-attr">UnexpectedEOS</span>: <span class="hljs-string">'Unexpected end of input'</span>,
        <span class="hljs-attr">NewlineAfterThrow</span>: <span class="hljs-string">'Illegal newline after throw'</span>,
        <span class="hljs-attr">InvalidRegExp</span>: <span class="hljs-string">'Invalid regular expression'</span>,
        <span class="hljs-attr">UnterminatedRegExp</span>: <span class="hljs-string">'Invalid regular expression: missing /'</span>,
        <span class="hljs-attr">InvalidLHSInAssignment</span>: <span class="hljs-string">'Invalid left-hand side in assignment'</span>,
        <span class="hljs-attr">InvalidLHSInForIn</span>: <span class="hljs-string">'Invalid left-hand side in for-in'</span>,
        <span class="hljs-attr">InvalidLHSInForLoop</span>: <span class="hljs-string">'Invalid left-hand side in for-loop'</span>,
        <span class="hljs-attr">MultipleDefaultsInSwitch</span>: <span class="hljs-string">'More than one default clause in switch statement'</span>,
        <span class="hljs-attr">NoCatchOrFinally</span>: <span class="hljs-string">'Missing catch or finally after try'</span>,
        <span class="hljs-attr">UnknownLabel</span>: <span class="hljs-string">'Undefined label \'%0\''</span>,
        <span class="hljs-attr">Redeclaration</span>: <span class="hljs-string">'%0 \'%1\' has already been declared'</span>,
        <span class="hljs-attr">IllegalContinue</span>: <span class="hljs-string">'Illegal continue statement'</span>,
        <span class="hljs-attr">IllegalBreak</span>: <span class="hljs-string">'Illegal break statement'</span>,
        <span class="hljs-attr">IllegalReturn</span>: <span class="hljs-string">'Illegal return statement'</span>,
        <span class="hljs-attr">StrictModeWith</span>: <span class="hljs-string">'Strict mode code may not include a with statement'</span>,
        <span class="hljs-attr">StrictCatchVariable</span>: <span class="hljs-string">'Catch variable may not be eval or arguments in strict mode'</span>,
        <span class="hljs-attr">StrictVarName</span>: <span class="hljs-string">'Variable name may not be eval or arguments in strict mode'</span>,
        <span class="hljs-attr">StrictParamName</span>: <span class="hljs-string">'Parameter name eval or arguments is not allowed in strict mode'</span>,
        <span class="hljs-attr">StrictParamDupe</span>: <span class="hljs-string">'Strict mode function may not have duplicate parameter names'</span>,
        <span class="hljs-attr">StrictFunctionName</span>: <span class="hljs-string">'Function name may not be eval or arguments in strict mode'</span>,
        <span class="hljs-attr">StrictOctalLiteral</span>: <span class="hljs-string">'Octal literals are not allowed in strict mode.'</span>,
        <span class="hljs-attr">StrictDelete</span>: <span class="hljs-string">'Delete of an unqualified identifier in strict mode.'</span>,
        <span class="hljs-attr">StrictLHSAssignment</span>: <span class="hljs-string">'Assignment to eval or arguments is not allowed in strict mode'</span>,
        <span class="hljs-attr">StrictLHSPostfix</span>: <span class="hljs-string">'Postfix increment/decrement may not have eval or arguments operand in strict mode'</span>,
        <span class="hljs-attr">StrictLHSPrefix</span>: <span class="hljs-string">'Prefix increment/decrement may not have eval or arguments operand in strict mode'</span>,
        <span class="hljs-attr">StrictReservedWord</span>: <span class="hljs-string">'Use of future reserved word in strict mode'</span>,
        <span class="hljs-attr">TemplateOctalLiteral</span>: <span class="hljs-string">'Octal literals are not allowed in template strings.'</span>,
        <span class="hljs-attr">ParameterAfterRestParameter</span>: <span class="hljs-string">'Rest parameter must be last formal parameter'</span>,
        <span class="hljs-attr">DefaultRestParameter</span>: <span class="hljs-string">'Unexpected token ='</span>,
        <span class="hljs-attr">ObjectPatternAsRestParameter</span>: <span class="hljs-string">'Unexpected token {'</span>,
        <span class="hljs-attr">DuplicateProtoProperty</span>: <span class="hljs-string">'Duplicate __proto__ fields are not allowed in object literals'</span>,
        <span class="hljs-attr">ConstructorSpecialMethod</span>: <span class="hljs-string">'Class constructor may not be an accessor'</span>,
        <span class="hljs-attr">DuplicateConstructor</span>: <span class="hljs-string">'A class may only have one constructor'</span>,
        <span class="hljs-attr">StaticPrototype</span>: <span class="hljs-string">'Classes may not have static property named prototype'</span>,
        <span class="hljs-attr">MissingFromClause</span>: <span class="hljs-string">'Unexpected token'</span>,
        <span class="hljs-attr">NoAsAfterImportNamespace</span>: <span class="hljs-string">'Unexpected token'</span>,
        <span class="hljs-attr">InvalidModuleSpecifier</span>: <span class="hljs-string">'Unexpected token'</span>,
        <span class="hljs-attr">IllegalImportDeclaration</span>: <span class="hljs-string">'Unexpected token'</span>,
        <span class="hljs-attr">IllegalExportDeclaration</span>: <span class="hljs-string">'Unexpected token'</span>,
        <span class="hljs-attr">DuplicateBinding</span>: <span class="hljs-string">'Duplicate binding %0'</span>
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>See also tools/generate-unicode-regex.js.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    Regex = {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        NonAsciiIdentifierStart: <span class="hljs-regexp">/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/</span>,

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        NonAsciiIdentifierPart: <span class="hljs-regexp">/[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/</span>
    };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Ensure the condition is true, otherwise throw an error.
This is only to have a better contract semantic, i.e. another safety net
to catch a logic error. The condition shall be fulfilled in normal case.
Do NOT use this to enforce a certain condition on any user input.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assert</span>(<span class="hljs-params">condition, message</span>) </span>{
        <span class="hljs-comment">/* istanbul ignore if */</span>
        <span class="hljs-keyword">if</span> (!condition) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'ASSERT: '</span> + message);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDecimalDigit</span>(<span class="hljs-params">ch</span>) </span>{
        <span class="hljs-keyword">return</span> (ch &gt;= <span class="hljs-number">0x30</span> &amp;&amp; ch &lt;= <span class="hljs-number">0x39</span>);   <span class="hljs-comment">// 0..9</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isHexDigit</span>(<span class="hljs-params">ch</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'0123456789abcdefABCDEF'</span>.indexOf(ch) &gt;= <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isOctalDigit</span>(<span class="hljs-params">ch</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'01234567'</span>.indexOf(ch) &gt;= <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">octalToDecimal</span>(<span class="hljs-params">ch</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>\0 is not octal escape sequence</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> octal = (ch !== <span class="hljs-string">'0'</span>), code = <span class="hljs-string">'01234567'</span>.indexOf(ch);

        <span class="hljs-keyword">if</span> (index &lt; length &amp;&amp; isOctalDigit(source[index])) {
            octal = <span class="hljs-literal">true</span>;
            code = code * <span class="hljs-number">8</span> + <span class="hljs-string">'01234567'</span>.indexOf(source[index++]);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>3 digits are only allowed when string starts
with 0, 1, 2, 3</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (<span class="hljs-string">'0123'</span>.indexOf(ch) &gt;= <span class="hljs-number">0</span> &amp;&amp;
                    index &lt; length &amp;&amp;
                    isOctalDigit(source[index])) {
                code = code * <span class="hljs-number">8</span> + <span class="hljs-string">'01234567'</span>.indexOf(source[index++]);
            }
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">code</span>: code,
            <span class="hljs-attr">octal</span>: octal
        };
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>ECMA-262 11.2 White Space</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWhiteSpace</span>(<span class="hljs-params">ch</span>) </span>{
        <span class="hljs-keyword">return</span> (ch === <span class="hljs-number">0x20</span>) || (ch === <span class="hljs-number">0x09</span>) || (ch === <span class="hljs-number">0x0B</span>) || (ch === <span class="hljs-number">0x0C</span>) || (ch === <span class="hljs-number">0xA0</span>) ||
            (ch &gt;= <span class="hljs-number">0x1680</span> &amp;&amp; [<span class="hljs-number">0x1680</span>, <span class="hljs-number">0x180E</span>, <span class="hljs-number">0x2000</span>, <span class="hljs-number">0x2001</span>, <span class="hljs-number">0x2002</span>, <span class="hljs-number">0x2003</span>, <span class="hljs-number">0x2004</span>, <span class="hljs-number">0x2005</span>, <span class="hljs-number">0x2006</span>, <span class="hljs-number">0x2007</span>, <span class="hljs-number">0x2008</span>, <span class="hljs-number">0x2009</span>, <span class="hljs-number">0x200A</span>, <span class="hljs-number">0x202F</span>, <span class="hljs-number">0x205F</span>, <span class="hljs-number">0x3000</span>, <span class="hljs-number">0xFEFF</span>].indexOf(ch) &gt;= <span class="hljs-number">0</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>ECMA-262 11.3 Line Terminators</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLineTerminator</span>(<span class="hljs-params">ch</span>) </span>{
        <span class="hljs-keyword">return</span> (ch === <span class="hljs-number">0x0A</span>) || (ch === <span class="hljs-number">0x0D</span>) || (ch === <span class="hljs-number">0x2028</span>) || (ch === <span class="hljs-number">0x2029</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>ECMA-262 11.6 Identifier Names and Identifiers</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromCodePoint</span>(<span class="hljs-params">cp</span>) </span>{
        <span class="hljs-keyword">return</span> (cp &lt; <span class="hljs-number">0x10000</span>) ? <span class="hljs-built_in">String</span>.fromCharCode(cp) :
            <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xD800</span> + ((cp - <span class="hljs-number">0x10000</span>) &gt;&gt; <span class="hljs-number">10</span>)) +
            <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xDC00</span> + ((cp - <span class="hljs-number">0x10000</span>) &amp; <span class="hljs-number">1023</span>));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isIdentifierStart</span>(<span class="hljs-params">ch</span>) </span>{
        <span class="hljs-keyword">return</span> (ch === <span class="hljs-number">0x24</span>) || (ch === <span class="hljs-number">0x5F</span>) ||  <span class="hljs-comment">// $ (dollar) and _ (underscore)</span>
            (ch &gt;= <span class="hljs-number">0x41</span> &amp;&amp; ch &lt;= <span class="hljs-number">0x5A</span>) ||         <span class="hljs-comment">// A..Z</span>
            (ch &gt;= <span class="hljs-number">0x61</span> &amp;&amp; ch &lt;= <span class="hljs-number">0x7A</span>) ||         <span class="hljs-comment">// a..z</span>
            (ch === <span class="hljs-number">0x5C</span>) ||                      <span class="hljs-comment">// \ (backslash)</span>
            ((ch &gt;= <span class="hljs-number">0x80</span>) &amp;&amp; Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isIdentifierPart</span>(<span class="hljs-params">ch</span>) </span>{
        <span class="hljs-keyword">return</span> (ch === <span class="hljs-number">0x24</span>) || (ch === <span class="hljs-number">0x5F</span>) ||  <span class="hljs-comment">// $ (dollar) and _ (underscore)</span>
            (ch &gt;= <span class="hljs-number">0x41</span> &amp;&amp; ch &lt;= <span class="hljs-number">0x5A</span>) ||         <span class="hljs-comment">// A..Z</span>
            (ch &gt;= <span class="hljs-number">0x61</span> &amp;&amp; ch &lt;= <span class="hljs-number">0x7A</span>) ||         <span class="hljs-comment">// a..z</span>
            (ch &gt;= <span class="hljs-number">0x30</span> &amp;&amp; ch &lt;= <span class="hljs-number">0x39</span>) ||         <span class="hljs-comment">// 0..9</span>
            (ch === <span class="hljs-number">0x5C</span>) ||                      <span class="hljs-comment">// \ (backslash)</span>
            ((ch &gt;= <span class="hljs-number">0x80</span>) &amp;&amp; Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>ECMA-262 11.6.2.2 Future Reserved Words</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFutureReservedWord</span>(<span class="hljs-params">id</span>) </span>{
        <span class="hljs-keyword">switch</span> (id) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'enum'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'export'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'import'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'super'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStrictModeReservedWord</span>(<span class="hljs-params">id</span>) </span>{
        <span class="hljs-keyword">switch</span> (id) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'implements'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'interface'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'package'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'private'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'protected'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'public'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'static'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'yield'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'let'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRestrictedWord</span>(<span class="hljs-params">id</span>) </span>{
        <span class="hljs-keyword">return</span> id === <span class="hljs-string">'eval'</span> || id === <span class="hljs-string">'arguments'</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>ECMA-262 11.6.2.1 Keywords</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isKeyword</span>(<span class="hljs-params">id</span>) </span>{
        <span class="hljs-keyword">switch</span> (id.length) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> (id === <span class="hljs-string">'if'</span>) || (id === <span class="hljs-string">'in'</span>) || (id === <span class="hljs-string">'do'</span>);
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            <span class="hljs-keyword">return</span> (id === <span class="hljs-string">'var'</span>) || (id === <span class="hljs-string">'for'</span>) || (id === <span class="hljs-string">'new'</span>) ||
                (id === <span class="hljs-string">'try'</span>) || (id === <span class="hljs-string">'let'</span>);
        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
            <span class="hljs-keyword">return</span> (id === <span class="hljs-string">'this'</span>) || (id === <span class="hljs-string">'else'</span>) || (id === <span class="hljs-string">'case'</span>) ||
                (id === <span class="hljs-string">'void'</span>) || (id === <span class="hljs-string">'with'</span>) || (id === <span class="hljs-string">'enum'</span>);
        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
            <span class="hljs-keyword">return</span> (id === <span class="hljs-string">'while'</span>) || (id === <span class="hljs-string">'break'</span>) || (id === <span class="hljs-string">'catch'</span>) ||
                (id === <span class="hljs-string">'throw'</span>) || (id === <span class="hljs-string">'const'</span>) || (id === <span class="hljs-string">'yield'</span>) ||
                (id === <span class="hljs-string">'class'</span>) || (id === <span class="hljs-string">'super'</span>);
        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
            <span class="hljs-keyword">return</span> (id === <span class="hljs-string">'return'</span>) || (id === <span class="hljs-string">'typeof'</span>) || (id === <span class="hljs-string">'delete'</span>) ||
                (id === <span class="hljs-string">'switch'</span>) || (id === <span class="hljs-string">'export'</span>) || (id === <span class="hljs-string">'import'</span>);
        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:
            <span class="hljs-keyword">return</span> (id === <span class="hljs-string">'default'</span>) || (id === <span class="hljs-string">'finally'</span>) || (id === <span class="hljs-string">'extends'</span>);
        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:
            <span class="hljs-keyword">return</span> (id === <span class="hljs-string">'function'</span>) || (id === <span class="hljs-string">'continue'</span>) || (id === <span class="hljs-string">'debugger'</span>);
        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:
            <span class="hljs-keyword">return</span> (id === <span class="hljs-string">'instanceof'</span>);
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>ECMA-262 11.4 Comments</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addComment</span>(<span class="hljs-params">type, value, start, end, loc</span>) </span>{
        <span class="hljs-keyword">var</span> comment;

        assert(<span class="hljs-keyword">typeof</span> start === <span class="hljs-string">'number'</span>, <span class="hljs-string">'Comment must have valid position'</span>);

        state.lastCommentStart = start;

        comment = {
            <span class="hljs-attr">type</span>: type,
            <span class="hljs-attr">value</span>: value
        };
        <span class="hljs-keyword">if</span> (extra.range) {
            comment.range = [start, end];
        }
        <span class="hljs-keyword">if</span> (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        <span class="hljs-keyword">if</span> (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
        <span class="hljs-keyword">if</span> (extra.tokenize) {
            comment.type = comment.type + <span class="hljs-string">'Comment'</span>;
            <span class="hljs-keyword">if</span> (extra.delegate) {
                comment = extra.delegate(comment);
            }
            extra.tokens.push(comment);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipSingleLineComment</span>(<span class="hljs-params">offset</span>) </span>{
        <span class="hljs-keyword">var</span> start, loc, ch, comment;

        start = index - offset;
        loc = {
            <span class="hljs-attr">start</span>: {
                <span class="hljs-attr">line</span>: lineNumber,
                <span class="hljs-attr">column</span>: index - lineStart - offset
            }
        };

        <span class="hljs-keyword">while</span> (index &lt; length) {
            ch = source.charCodeAt(index);
            ++index;
            <span class="hljs-keyword">if</span> (isLineTerminator(ch)) {
                hasLineTerminator = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (extra.comments) {
                    comment = source.slice(start + offset, index - <span class="hljs-number">1</span>);
                    loc.end = {
                        <span class="hljs-attr">line</span>: lineNumber,
                        <span class="hljs-attr">column</span>: index - lineStart - <span class="hljs-number">1</span>
                    };
                    addComment(<span class="hljs-string">'Line'</span>, comment, start, index - <span class="hljs-number">1</span>, loc);
                }
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">13</span> &amp;&amp; source.charCodeAt(index) === <span class="hljs-number">10</span>) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                <span class="hljs-keyword">return</span>;
            }
        }

        <span class="hljs-keyword">if</span> (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                <span class="hljs-attr">line</span>: lineNumber,
                <span class="hljs-attr">column</span>: index - lineStart
            };
            addComment(<span class="hljs-string">'Line'</span>, comment, start, index, loc);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipMultiLineComment</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> start, loc, ch, comment;

        <span class="hljs-keyword">if</span> (extra.comments) {
            start = index - <span class="hljs-number">2</span>;
            loc = {
                <span class="hljs-attr">start</span>: {
                    <span class="hljs-attr">line</span>: lineNumber,
                    <span class="hljs-attr">column</span>: index - lineStart - <span class="hljs-number">2</span>
                }
            };
        }

        <span class="hljs-keyword">while</span> (index &lt; length) {
            ch = source.charCodeAt(index);
            <span class="hljs-keyword">if</span> (isLineTerminator(ch)) {
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">0x0D</span> &amp;&amp; source.charCodeAt(index + <span class="hljs-number">1</span>) === <span class="hljs-number">0x0A</span>) {
                    ++index;
                }
                hasLineTerminator = <span class="hljs-literal">true</span>;
                ++lineNumber;
                ++index;
                lineStart = index;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">0x2A</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>Block comment ends with '*/'.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">if</span> (source.charCodeAt(index + <span class="hljs-number">1</span>) === <span class="hljs-number">0x2F</span>) {
                    ++index;
                    ++index;
                    <span class="hljs-keyword">if</span> (extra.comments) {
                        comment = source.slice(start + <span class="hljs-number">2</span>, index - <span class="hljs-number">2</span>);
                        loc.end = {
                            <span class="hljs-attr">line</span>: lineNumber,
                            <span class="hljs-attr">column</span>: index - lineStart
                        };
                        addComment(<span class="hljs-string">'Block'</span>, comment, start, index, loc);
                    }
                    <span class="hljs-keyword">return</span>;
                }
                ++index;
            } <span class="hljs-keyword">else</span> {
                ++index;
            }
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Ran off the end of the file - the whole thing is a comment</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (extra.comments) {
            loc.end = {
                <span class="hljs-attr">line</span>: lineNumber,
                <span class="hljs-attr">column</span>: index - lineStart
            };
            comment = source.slice(start + <span class="hljs-number">2</span>, index);
            addComment(<span class="hljs-string">'Block'</span>, comment, start, index, loc);
        }
        tolerateUnexpectedToken();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipComment</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> ch, start;
        hasLineTerminator = <span class="hljs-literal">false</span>;

        start = (index === <span class="hljs-number">0</span>);
        <span class="hljs-keyword">while</span> (index &lt; length) {
            ch = source.charCodeAt(index);

            <span class="hljs-keyword">if</span> (isWhiteSpace(ch)) {
                ++index;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLineTerminator(ch)) {
                hasLineTerminator = <span class="hljs-literal">true</span>;
                ++index;
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">0x0D</span> &amp;&amp; source.charCodeAt(index) === <span class="hljs-number">0x0A</span>) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">0x2F</span>) { <span class="hljs-comment">// U+002F is '/'</span>
                ch = source.charCodeAt(index + <span class="hljs-number">1</span>);
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">0x2F</span>) {
                    ++index;
                    ++index;
                    skipSingleLineComment(<span class="hljs-number">2</span>);
                    start = <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">0x2A</span>) {  <span class="hljs-comment">// U+002A is '*'</span>
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">break</span>;
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start &amp;&amp; ch === <span class="hljs-number">0x2D</span>) { <span class="hljs-comment">// U+002D is '-'</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>U+003E is '&gt;'</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">if</span> ((source.charCodeAt(index + <span class="hljs-number">1</span>) === <span class="hljs-number">0x2D</span>) &amp;&amp; (source.charCodeAt(index + <span class="hljs-number">2</span>) === <span class="hljs-number">0x3E</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>'--&gt;' is a single-line comment</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    index += <span class="hljs-number">3</span>;
                    skipSingleLineComment(<span class="hljs-number">3</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">break</span>;
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">0x3C</span>) { <span class="hljs-comment">// U+003C is '&lt;'</span>
                <span class="hljs-keyword">if</span> (source.slice(index + <span class="hljs-number">1</span>, index + <span class="hljs-number">4</span>) === <span class="hljs-string">'!--'</span>) {
                    ++index; <span class="hljs-comment">// `&lt;`</span>
                    ++index; <span class="hljs-comment">// `!`</span>
                    ++index; <span class="hljs-comment">// `-`</span>
                    ++index; <span class="hljs-comment">// `-`</span>
                    skipSingleLineComment(<span class="hljs-number">4</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">break</span>;
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">break</span>;
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanHexEscape</span>(<span class="hljs-params">prefix</span>) </span>{
        <span class="hljs-keyword">var</span> i, len, ch, code = <span class="hljs-number">0</span>;

        len = (prefix === <span class="hljs-string">'u'</span>) ? <span class="hljs-number">4</span> : <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; ++i) {
            <span class="hljs-keyword">if</span> (index &lt; length &amp;&amp; isHexDigit(source[index])) {
                ch = source[index++];
                code = code * <span class="hljs-number">16</span> + <span class="hljs-string">'0123456789abcdef'</span>.indexOf(ch.toLowerCase());
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(code);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanUnicodeCodePointEscape</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> ch, code;

        ch = source[index];
        code = <span class="hljs-number">0</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>At least, one hex digit is required.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'}'</span>) {
            throwUnexpectedToken();
        }

        <span class="hljs-keyword">while</span> (index &lt; length) {
            ch = source[index++];
            <span class="hljs-keyword">if</span> (!isHexDigit(ch)) {
                <span class="hljs-keyword">break</span>;
            }
            code = code * <span class="hljs-number">16</span> + <span class="hljs-string">'0123456789abcdef'</span>.indexOf(ch.toLowerCase());
        }

        <span class="hljs-keyword">if</span> (code &gt; <span class="hljs-number">0x10FFFF</span> || ch !== <span class="hljs-string">'}'</span>) {
            throwUnexpectedToken();
        }

        <span class="hljs-keyword">return</span> fromCodePoint(code);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">codePointAt</span>(<span class="hljs-params">i</span>) </span>{
        <span class="hljs-keyword">var</span> cp, first, second;

        cp = source.charCodeAt(i);
        <span class="hljs-keyword">if</span> (cp &gt;= <span class="hljs-number">0xD800</span> &amp;&amp; cp &lt;= <span class="hljs-number">0xDBFF</span>) {
            second = source.charCodeAt(i + <span class="hljs-number">1</span>);
            <span class="hljs-keyword">if</span> (second &gt;= <span class="hljs-number">0xDC00</span> &amp;&amp; second &lt;= <span class="hljs-number">0xDFFF</span>) {
                first = cp;
                cp = (first - <span class="hljs-number">0xD800</span>) * <span class="hljs-number">0x400</span> + second - <span class="hljs-number">0xDC00</span> + <span class="hljs-number">0x10000</span>;
            }
        }

        <span class="hljs-keyword">return</span> cp;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getComplexIdentifier</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> cp, ch, id;

        cp = codePointAt(index);
        id = fromCodePoint(cp);
        index += id.length;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>'\u' (U+005C, U+0075) denotes an escaped character.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (cp === <span class="hljs-number">0x5C</span>) {
            <span class="hljs-keyword">if</span> (source.charCodeAt(index) !== <span class="hljs-number">0x75</span>) {
                throwUnexpectedToken();
            }
            ++index;
            <span class="hljs-keyword">if</span> (source[index] === <span class="hljs-string">'{'</span>) {
                ++index;
                ch = scanUnicodeCodePointEscape();
            } <span class="hljs-keyword">else</span> {
                ch = scanHexEscape(<span class="hljs-string">'u'</span>);
                cp = ch.charCodeAt(<span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span> (!ch || ch === <span class="hljs-string">'\\'</span> || !isIdentifierStart(cp)) {
                    throwUnexpectedToken();
                }
            }
            id = ch;
        }

        <span class="hljs-keyword">while</span> (index &lt; length) {
            cp = codePointAt(index);
            <span class="hljs-keyword">if</span> (!isIdentifierPart(cp)) {
                <span class="hljs-keyword">break</span>;
            }
            ch = fromCodePoint(cp);
            id += ch;
            index += ch.length;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>'\u' (U+005C, U+0075) denotes an escaped character.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (cp === <span class="hljs-number">0x5C</span>) {
                id = id.substr(<span class="hljs-number">0</span>, id.length - <span class="hljs-number">1</span>);
                <span class="hljs-keyword">if</span> (source.charCodeAt(index) !== <span class="hljs-number">0x75</span>) {
                    throwUnexpectedToken();
                }
                ++index;
                <span class="hljs-keyword">if</span> (source[index] === <span class="hljs-string">'{'</span>) {
                    ++index;
                    ch = scanUnicodeCodePointEscape();
                } <span class="hljs-keyword">else</span> {
                    ch = scanHexEscape(<span class="hljs-string">'u'</span>);
                    cp = ch.charCodeAt(<span class="hljs-number">0</span>);
                    <span class="hljs-keyword">if</span> (!ch || ch === <span class="hljs-string">'\\'</span> || !isIdentifierPart(cp)) {
                        throwUnexpectedToken();
                    }
                }
                id += ch;
            }
        }

        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIdentifier</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> start, ch;

        start = index++;
        <span class="hljs-keyword">while</span> (index &lt; length) {
            ch = source.charCodeAt(index);
            <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">0x5C</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>Blackslash (U+005C) marks Unicode escape sequence.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                index = start;
                <span class="hljs-keyword">return</span> getComplexIdentifier();
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-number">0xD800</span> &amp;&amp; ch &lt; <span class="hljs-number">0xDFFF</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>Need to handle surrogate pairs.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                index = start;
                <span class="hljs-keyword">return</span> getComplexIdentifier();
            }
            <span class="hljs-keyword">if</span> (isIdentifierPart(ch)) {
                ++index;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-keyword">return</span> source.slice(start, index);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanIdentifier</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> start, id, type;

        start = index;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>Backslash (U+005C) starts an escaped character.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        id = (source.charCodeAt(index) === <span class="hljs-number">0x5C</span>) ? getComplexIdentifier() : getIdentifier();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>There is no keyword or literal with only one character.
Thus, it must be an identifier.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (id.length === <span class="hljs-number">1</span>) {
            type = Token.Identifier;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isKeyword(id)) {
            type = Token.Keyword;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id === <span class="hljs-string">'null'</span>) {
            type = Token.NullLiteral;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id === <span class="hljs-string">'true'</span> || id === <span class="hljs-string">'false'</span>) {
            type = Token.BooleanLiteral;
        } <span class="hljs-keyword">else</span> {
            type = Token.Identifier;
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">type</span>: type,
            <span class="hljs-attr">value</span>: id,
            <span class="hljs-attr">lineNumber</span>: lineNumber,
            <span class="hljs-attr">lineStart</span>: lineStart,
            <span class="hljs-attr">start</span>: start,
            <span class="hljs-attr">end</span>: index
        };
    }


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>ECMA-262 11.7 Punctuators</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanPunctuator</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> token, str;

        token = {
            <span class="hljs-attr">type</span>: Token.Punctuator,
            <span class="hljs-attr">value</span>: <span class="hljs-string">''</span>,
            <span class="hljs-attr">lineNumber</span>: lineNumber,
            <span class="hljs-attr">lineStart</span>: lineStart,
            <span class="hljs-attr">start</span>: index,
            <span class="hljs-attr">end</span>: index
        };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>Check for most common single-character punctuators.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        str = source[index];
        <span class="hljs-keyword">switch</span> (str) {

        <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>:
            <span class="hljs-keyword">if</span> (extra.tokenize) {
                extra.openParenToken = extra.tokenValues.length;
            }
            ++index;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'{'</span>:
            <span class="hljs-keyword">if</span> (extra.tokenize) {
                extra.openCurlyToken = extra.tokenValues.length;
            }
            state.curlyStack.push(<span class="hljs-string">'{'</span>);
            ++index;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:
            ++index;
            <span class="hljs-keyword">if</span> (source[index] === <span class="hljs-string">'.'</span> &amp;&amp; source[index + <span class="hljs-number">1</span>] === <span class="hljs-string">'.'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>Spread operator: ...</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                index += <span class="hljs-number">2</span>;
                str = <span class="hljs-string">'...'</span>;
            }
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'}'</span>:
            ++index;
            state.curlyStack.pop();
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">';'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'['</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">']'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">':'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'?'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'~'</span>:
            ++index;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>4-character punctuator.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            str = source.substr(index, <span class="hljs-number">4</span>);
            <span class="hljs-keyword">if</span> (str === <span class="hljs-string">'&gt;&gt;&gt;='</span>) {
                index += <span class="hljs-number">4</span>;
            } <span class="hljs-keyword">else</span> {

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>3-character punctuators.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                str = str.substr(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
                <span class="hljs-keyword">if</span> (str === <span class="hljs-string">'==='</span> || str === <span class="hljs-string">'!=='</span> || str === <span class="hljs-string">'&gt;&gt;&gt;'</span> ||
                    str === <span class="hljs-string">'&lt;&lt;='</span> || str === <span class="hljs-string">'&gt;&gt;='</span>) {
                    index += <span class="hljs-number">3</span>;
                } <span class="hljs-keyword">else</span> {

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<p>2-character punctuators.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    str = str.substr(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">if</span> (str === <span class="hljs-string">'&amp;&amp;'</span> || str === <span class="hljs-string">'||'</span> || str === <span class="hljs-string">'=='</span> || str === <span class="hljs-string">'!='</span> ||
                        str === <span class="hljs-string">'+='</span> || str === <span class="hljs-string">'-='</span> || str === <span class="hljs-string">'*='</span> || str === <span class="hljs-string">'/='</span> ||
                        str === <span class="hljs-string">'++'</span> || str === <span class="hljs-string">'--'</span> || str === <span class="hljs-string">'&lt;&lt;'</span> || str === <span class="hljs-string">'&gt;&gt;'</span> ||
                        str === <span class="hljs-string">'&amp;='</span> || str === <span class="hljs-string">'|='</span> || str === <span class="hljs-string">'^='</span> || str === <span class="hljs-string">'%='</span> ||
                        str === <span class="hljs-string">'&lt;='</span> || str === <span class="hljs-string">'&gt;='</span> || str === <span class="hljs-string">'=&gt;'</span>) {
                        index += <span class="hljs-number">2</span>;
                    } <span class="hljs-keyword">else</span> {

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<p>1-character punctuators.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                        str = source[index];
                        <span class="hljs-keyword">if</span> (<span class="hljs-string">'&lt;&gt;=!+-*%&amp;|^/'</span>.indexOf(str) &gt;= <span class="hljs-number">0</span>) {
                            ++index;
                        }
                    }
                }
            }
        }

        <span class="hljs-keyword">if</span> (index === token.start) {
            throwUnexpectedToken();
        }

        token.end = index;
        token.value = str;
        <span class="hljs-keyword">return</span> token;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<p>ECMA-262 11.8.3 Numeric Literals</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanHexLiteral</span>(<span class="hljs-params">start</span>) </span>{
        <span class="hljs-keyword">var</span> number = <span class="hljs-string">''</span>;

        <span class="hljs-keyword">while</span> (index &lt; length) {
            <span class="hljs-keyword">if</span> (!isHexDigit(source[index])) {
                <span class="hljs-keyword">break</span>;
            }
            number += source[index++];
        }

        <span class="hljs-keyword">if</span> (number.length === <span class="hljs-number">0</span>) {
            throwUnexpectedToken();
        }

        <span class="hljs-keyword">if</span> (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">type</span>: Token.NumericLiteral,
            <span class="hljs-attr">value</span>: <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'0x'</span> + number, <span class="hljs-number">16</span>),
            <span class="hljs-attr">lineNumber</span>: lineNumber,
            <span class="hljs-attr">lineStart</span>: lineStart,
            <span class="hljs-attr">start</span>: start,
            <span class="hljs-attr">end</span>: index
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanBinaryLiteral</span>(<span class="hljs-params">start</span>) </span>{
        <span class="hljs-keyword">var</span> ch, number;

        number = <span class="hljs-string">''</span>;

        <span class="hljs-keyword">while</span> (index &lt; length) {
            ch = source[index];
            <span class="hljs-keyword">if</span> (ch !== <span class="hljs-string">'0'</span> &amp;&amp; ch !== <span class="hljs-string">'1'</span>) {
                <span class="hljs-keyword">break</span>;
            }
            number += source[index++];
        }

        <span class="hljs-keyword">if</span> (number.length === <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<p>only 0b or 0B</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            throwUnexpectedToken();
        }

        <span class="hljs-keyword">if</span> (index &lt; length) {
            ch = source.charCodeAt(index);
            <span class="hljs-comment">/* istanbul ignore else */</span>
            <span class="hljs-keyword">if</span> (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">type</span>: Token.NumericLiteral,
            <span class="hljs-attr">value</span>: <span class="hljs-built_in">parseInt</span>(number, <span class="hljs-number">2</span>),
            <span class="hljs-attr">lineNumber</span>: lineNumber,
            <span class="hljs-attr">lineStart</span>: lineStart,
            <span class="hljs-attr">start</span>: start,
            <span class="hljs-attr">end</span>: index
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanOctalLiteral</span>(<span class="hljs-params">prefix, start</span>) </span>{
        <span class="hljs-keyword">var</span> number, octal;

        <span class="hljs-keyword">if</span> (isOctalDigit(prefix)) {
            octal = <span class="hljs-literal">true</span>;
            number = <span class="hljs-string">'0'</span> + source[index++];
        } <span class="hljs-keyword">else</span> {
            octal = <span class="hljs-literal">false</span>;
            ++index;
            number = <span class="hljs-string">''</span>;
        }

        <span class="hljs-keyword">while</span> (index &lt; length) {
            <span class="hljs-keyword">if</span> (!isOctalDigit(source[index])) {
                <span class="hljs-keyword">break</span>;
            }
            number += source[index++];
        }

        <span class="hljs-keyword">if</span> (!octal &amp;&amp; number.length === <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>only 0o or 0O</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            throwUnexpectedToken();
        }

        <span class="hljs-keyword">if</span> (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">type</span>: Token.NumericLiteral,
            <span class="hljs-attr">value</span>: <span class="hljs-built_in">parseInt</span>(number, <span class="hljs-number">8</span>),
            <span class="hljs-attr">octal</span>: octal,
            <span class="hljs-attr">lineNumber</span>: lineNumber,
            <span class="hljs-attr">lineStart</span>: lineStart,
            <span class="hljs-attr">start</span>: start,
            <span class="hljs-attr">end</span>: index
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isImplicitOctalLiteral</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> i, ch;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<p>Implicit octal, unless there is a non-octal digit.
(Annex B.1.1 on Numeric Literals)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">for</span> (i = index + <span class="hljs-number">1</span>; i &lt; length; ++i) {
            ch = source[i];
            <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'8'</span> || ch === <span class="hljs-string">'9'</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
            <span class="hljs-keyword">if</span> (!isOctalDigit(ch)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanNumericLiteral</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(<span class="hljs-number">0</span>)) || (ch === <span class="hljs-string">'.'</span>),
            <span class="hljs-string">'Numeric literal must start with a decimal digit or a decimal point'</span>);

        start = index;
        number = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">if</span> (ch !== <span class="hljs-string">'.'</span>) {
            number = source[index++];
            ch = source[index];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<p>Hex number starts with '0x'.
Octal number starts with '0'.
Octal number in ES6 starts with '0o'.
Binary number in ES6 starts with '0b'.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (number === <span class="hljs-string">'0'</span>) {
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'x'</span> || ch === <span class="hljs-string">'X'</span>) {
                    ++index;
                    <span class="hljs-keyword">return</span> scanHexLiteral(start);
                }
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'b'</span> || ch === <span class="hljs-string">'B'</span>) {
                    ++index;
                    <span class="hljs-keyword">return</span> scanBinaryLiteral(start);
                }
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'o'</span> || ch === <span class="hljs-string">'O'</span>) {
                    <span class="hljs-keyword">return</span> scanOctalLiteral(ch, start);
                }

                <span class="hljs-keyword">if</span> (isOctalDigit(ch)) {
                    <span class="hljs-keyword">if</span> (isImplicitOctalLiteral()) {
                        <span class="hljs-keyword">return</span> scanOctalLiteral(ch, start);
                    }
                }
            }

            <span class="hljs-keyword">while</span> (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'.'</span>) {
            number += source[index++];
            <span class="hljs-keyword">while</span> (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'e'</span> || ch === <span class="hljs-string">'E'</span>) {
            number += source[index++];

            ch = source[index];
            <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'+'</span> || ch === <span class="hljs-string">'-'</span>) {
                number += source[index++];
            }
            <span class="hljs-keyword">if</span> (isDecimalDigit(source.charCodeAt(index))) {
                <span class="hljs-keyword">while</span> (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } <span class="hljs-keyword">else</span> {
                throwUnexpectedToken();
            }
        }

        <span class="hljs-keyword">if</span> (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">type</span>: Token.NumericLiteral,
            <span class="hljs-attr">value</span>: <span class="hljs-built_in">parseFloat</span>(number),
            <span class="hljs-attr">lineNumber</span>: lineNumber,
            <span class="hljs-attr">lineStart</span>: lineStart,
            <span class="hljs-attr">start</span>: start,
            <span class="hljs-attr">end</span>: index
        };
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<p>ECMA-262 11.8.4 String Literals</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanStringLiteral</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> str = <span class="hljs-string">''</span>, quote, start, ch, unescaped, octToDec, octal = <span class="hljs-literal">false</span>;

        quote = source[index];
        assert((quote === <span class="hljs-string">'\''</span> || quote === <span class="hljs-string">'"'</span>),
            <span class="hljs-string">'String literal must starts with a quote'</span>);

        start = index;
        ++index;

        <span class="hljs-keyword">while</span> (index &lt; length) {
            ch = source[index++];

            <span class="hljs-keyword">if</span> (ch === quote) {
                quote = <span class="hljs-string">''</span>;
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'\\'</span>) {
                ch = source[index++];
                <span class="hljs-keyword">if</span> (!ch || !isLineTerminator(ch.charCodeAt(<span class="hljs-number">0</span>))) {
                    <span class="hljs-keyword">switch</span> (ch) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'u'</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'x'</span>:
                        <span class="hljs-keyword">if</span> (source[index] === <span class="hljs-string">'{'</span>) {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } <span class="hljs-keyword">else</span> {
                            unescaped = scanHexEscape(ch);
                            <span class="hljs-keyword">if</span> (!unescaped) {
                                <span class="hljs-keyword">throw</span> throwUnexpectedToken();
                            }
                            str += unescaped;
                        }
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'n'</span>:
                        str += <span class="hljs-string">'\n'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'r'</span>:
                        str += <span class="hljs-string">'\r'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'t'</span>:
                        str += <span class="hljs-string">'\t'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'b'</span>:
                        str += <span class="hljs-string">'\b'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'f'</span>:
                        str += <span class="hljs-string">'\f'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'v'</span>:
                        str += <span class="hljs-string">'\x0B'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'8'</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'9'</span>:
                        str += ch;
                        tolerateUnexpectedToken();
                        <span class="hljs-keyword">break</span>;

                    <span class="hljs-keyword">default</span>:
                        <span class="hljs-keyword">if</span> (isOctalDigit(ch)) {
                            octToDec = octalToDecimal(ch);

                            octal = octToDec.octal || octal;
                            str += <span class="hljs-built_in">String</span>.fromCharCode(octToDec.code);
                        } <span class="hljs-keyword">else</span> {
                            str += ch;
                        }
                        <span class="hljs-keyword">break</span>;
                    }
                } <span class="hljs-keyword">else</span> {
                    ++lineNumber;
                    <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'\r'</span> &amp;&amp; source[index] === <span class="hljs-string">'\n'</span>) {
                        ++index;
                    }
                    lineStart = index;
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLineTerminator(ch.charCodeAt(<span class="hljs-number">0</span>))) {
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> {
                str += ch;
            }
        }

        <span class="hljs-keyword">if</span> (quote !== <span class="hljs-string">''</span>) {
            index = start;
            throwUnexpectedToken();
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">type</span>: Token.StringLiteral,
            <span class="hljs-attr">value</span>: str,
            <span class="hljs-attr">octal</span>: octal,
            <span class="hljs-attr">lineNumber</span>: startLineNumber,
            <span class="hljs-attr">lineStart</span>: startLineStart,
            <span class="hljs-attr">start</span>: start,
            <span class="hljs-attr">end</span>: index
        };
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<p>ECMA-262 11.8.6 Template Literal Lexical Components</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanTemplate</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> cooked = <span class="hljs-string">''</span>, ch, start, rawOffset, terminated, head, tail, restore, unescaped;

        terminated = <span class="hljs-literal">false</span>;
        tail = <span class="hljs-literal">false</span>;
        start = index;
        head = (source[index] === <span class="hljs-string">'`'</span>);
        rawOffset = <span class="hljs-number">2</span>;

        ++index;

        <span class="hljs-keyword">while</span> (index &lt; length) {
            ch = source[index++];
            <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'`'</span>) {
                rawOffset = <span class="hljs-number">1</span>;
                tail = <span class="hljs-literal">true</span>;
                terminated = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'$'</span>) {
                <span class="hljs-keyword">if</span> (source[index] === <span class="hljs-string">'{'</span>) {
                    state.curlyStack.push(<span class="hljs-string">'${'</span>);
                    ++index;
                    terminated = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                }
                cooked += ch;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'\\'</span>) {
                ch = source[index++];
                <span class="hljs-keyword">if</span> (!isLineTerminator(ch.charCodeAt(<span class="hljs-number">0</span>))) {
                    <span class="hljs-keyword">switch</span> (ch) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'n'</span>:
                        cooked += <span class="hljs-string">'\n'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'r'</span>:
                        cooked += <span class="hljs-string">'\r'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'t'</span>:
                        cooked += <span class="hljs-string">'\t'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'u'</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'x'</span>:
                        <span class="hljs-keyword">if</span> (source[index] === <span class="hljs-string">'{'</span>) {
                            ++index;
                            cooked += scanUnicodeCodePointEscape();
                        } <span class="hljs-keyword">else</span> {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            <span class="hljs-keyword">if</span> (unescaped) {
                                cooked += unescaped;
                            } <span class="hljs-keyword">else</span> {
                                index = restore;
                                cooked += ch;
                            }
                        }
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'b'</span>:
                        cooked += <span class="hljs-string">'\b'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'f'</span>:
                        cooked += <span class="hljs-string">'\f'</span>;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'v'</span>:
                        cooked += <span class="hljs-string">'\v'</span>;
                        <span class="hljs-keyword">break</span>;

                    <span class="hljs-keyword">default</span>:
                        <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'0'</span>) {
                            <span class="hljs-keyword">if</span> (isDecimalDigit(source.charCodeAt(index))) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<p>Illegal: \01 \02 and so on</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                                throwError(Messages.TemplateOctalLiteral);
                            }
                            cooked += <span class="hljs-string">'\0'</span>;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOctalDigit(ch)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<p>Illegal: \1 \2</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                            throwError(Messages.TemplateOctalLiteral);
                        } <span class="hljs-keyword">else</span> {
                            cooked += ch;
                        }
                        <span class="hljs-keyword">break</span>;
                    }
                } <span class="hljs-keyword">else</span> {
                    ++lineNumber;
                    <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'\r'</span> &amp;&amp; source[index] === <span class="hljs-string">'\n'</span>) {
                        ++index;
                    }
                    lineStart = index;
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLineTerminator(ch.charCodeAt(<span class="hljs-number">0</span>))) {
                ++lineNumber;
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'\r'</span> &amp;&amp; source[index] === <span class="hljs-string">'\n'</span>) {
                    ++index;
                }
                lineStart = index;
                cooked += <span class="hljs-string">'\n'</span>;
            } <span class="hljs-keyword">else</span> {
                cooked += ch;
            }
        }

        <span class="hljs-keyword">if</span> (!terminated) {
            throwUnexpectedToken();
        }

        <span class="hljs-keyword">if</span> (!head) {
            state.curlyStack.pop();
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">type</span>: Token.Template,
            <span class="hljs-attr">value</span>: {
                <span class="hljs-attr">cooked</span>: cooked,
                <span class="hljs-attr">raw</span>: source.slice(start + <span class="hljs-number">1</span>, index - rawOffset)
            },
            <span class="hljs-attr">head</span>: head,
            <span class="hljs-attr">tail</span>: tail,
            <span class="hljs-attr">lineNumber</span>: lineNumber,
            <span class="hljs-attr">lineStart</span>: lineStart,
            <span class="hljs-attr">start</span>: start,
            <span class="hljs-attr">end</span>: index
        };
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<p>ECMA-262 11.8.5 Regular Expression Literals</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testRegExp</span>(<span class="hljs-params">pattern, flags</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<p>The BMP character to use as a replacement for astral symbols when
translating an ES6 &quot;u&quot;-flagged pattern to an ES5-compatible
approximation.
Note: replacing with '\uFFFF' enables false positives in unlikely
scenarios. For example, <code>[\u{1044f}-\u{10440}]</code> is an invalid
pattern that would not be detected by this substitution.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> astralSubstitute = <span class="hljs-string">'\uFFFF'</span>,
            tmp = pattern;

        <span class="hljs-keyword">if</span> (flags.indexOf(<span class="hljs-string">'u'</span>) &gt;= <span class="hljs-number">0</span>) {
            tmp = tmp
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<p>Replace every Unicode escape sequence with the equivalent
BMP character or a constant ASCII code point in the case of
astral symbols. (See the above note on <code>astralSubstitute</code>
for more information.)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                .replace(<span class="hljs-regexp">/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$<span class="hljs-number">0</span>, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) </span>{
                    <span class="hljs-keyword">var</span> codePoint = <span class="hljs-built_in">parseInt</span>($<span class="hljs-number">1</span> || $<span class="hljs-number">2</span>, <span class="hljs-number">16</span>);
                    <span class="hljs-keyword">if</span> (codePoint &gt; <span class="hljs-number">0x10FFFF</span>) {
                        throwUnexpectedToken(<span class="hljs-literal">null</span>, Messages.InvalidRegExp);
                    }
                    <span class="hljs-keyword">if</span> (codePoint &lt;= <span class="hljs-number">0xFFFF</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(codePoint);
                    }
                    <span class="hljs-keyword">return</span> astralSubstitute;
                })
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-49" id="section-49"></a>
</div>
<p>Replace each paired surrogate with a single ASCII symbol to
avoid throwing on regular expressions that are only valid in
combination with the &quot;u&quot; flag.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                .replace(
                    <span class="hljs-regexp">/[\uD800-\uDBFF][\uDC00-\uDFFF]/g</span>,
                    astralSubstitute
                );
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-50" id="section-50"></a>
</div>
<p>First, detect invalid regular expressions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">try</span> {
            <span class="hljs-built_in">RegExp</span>(tmp);
        } <span class="hljs-keyword">catch</span> (e) {
            throwUnexpectedToken(<span class="hljs-literal">null</span>, Messages.InvalidRegExp);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-51" id="section-51"></a>
</div>
<p>Return a regular expression object for this pattern-flag pair, or
<code>null</code> in case the current environment doesn't support the flags it
uses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(pattern, flags);
        } <span class="hljs-keyword">catch</span> (exception) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanRegExpBody</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === <span class="hljs-string">'/'</span>, <span class="hljs-string">'Regular expression literal must start with a slash'</span>);
        str = source[index++];

        classMarker = <span class="hljs-literal">false</span>;
        terminated = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">while</span> (index &lt; length) {
            ch = source[index++];
            str += ch;
            <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'\\'</span>) {
                ch = source[index++];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-52" id="section-52"></a>
</div>
<p>ECMA-262 7.8.5</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">if</span> (isLineTerminator(ch.charCodeAt(<span class="hljs-number">0</span>))) {
                    throwUnexpectedToken(<span class="hljs-literal">null</span>, Messages.UnterminatedRegExp);
                }
                str += ch;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLineTerminator(ch.charCodeAt(<span class="hljs-number">0</span>))) {
                throwUnexpectedToken(<span class="hljs-literal">null</span>, Messages.UnterminatedRegExp);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (classMarker) {
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">']'</span>) {
                    classMarker = <span class="hljs-literal">false</span>;
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'/'</span>) {
                    terminated = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'['</span>) {
                    classMarker = <span class="hljs-literal">true</span>;
                }
            }
        }

        <span class="hljs-keyword">if</span> (!terminated) {
            throwUnexpectedToken(<span class="hljs-literal">null</span>, Messages.UnterminatedRegExp);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-53" id="section-53"></a>
</div>
<p>Exclude leading and trailing slash.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        body = str.substr(<span class="hljs-number">1</span>, str.length - <span class="hljs-number">2</span>);
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">value</span>: body,
            <span class="hljs-attr">literal</span>: str
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanRegExpFlags</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> ch, str, flags, restore;

        str = <span class="hljs-string">''</span>;
        flags = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">while</span> (index &lt; length) {
            ch = source[index];
            <span class="hljs-keyword">if</span> (!isIdentifierPart(ch.charCodeAt(<span class="hljs-number">0</span>))) {
                <span class="hljs-keyword">break</span>;
            }

            ++index;
            <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'\\'</span> &amp;&amp; index &lt; length) {
                ch = source[index];
                <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'u'</span>) {
                    ++index;
                    restore = index;
                    ch = scanHexEscape(<span class="hljs-string">'u'</span>);
                    <span class="hljs-keyword">if</span> (ch) {
                        flags += ch;
                        <span class="hljs-keyword">for</span> (str += <span class="hljs-string">'\\u'</span>; restore &lt; index; ++restore) {
                            str += source[restore];
                        }
                    } <span class="hljs-keyword">else</span> {
                        index = restore;
                        flags += <span class="hljs-string">'u'</span>;
                        str += <span class="hljs-string">'\\u'</span>;
                    }
                    tolerateUnexpectedToken();
                } <span class="hljs-keyword">else</span> {
                    str += <span class="hljs-string">'\\'</span>;
                    tolerateUnexpectedToken();
                }
            } <span class="hljs-keyword">else</span> {
                flags += ch;
                str += ch;
            }
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">value</span>: flags,
            <span class="hljs-attr">literal</span>: str
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanRegExp</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> start, body, flags, value;
        scanning = <span class="hljs-literal">true</span>;

        lookahead = <span class="hljs-literal">null</span>;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        scanning = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (extra.tokenize) {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">type</span>: Token.RegularExpression,
                <span class="hljs-attr">value</span>: value,
                <span class="hljs-attr">regex</span>: {
                    <span class="hljs-attr">pattern</span>: body.value,
                    <span class="hljs-attr">flags</span>: flags.value
                },
                <span class="hljs-attr">lineNumber</span>: lineNumber,
                <span class="hljs-attr">lineStart</span>: lineStart,
                <span class="hljs-attr">start</span>: start,
                <span class="hljs-attr">end</span>: index
            };
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">literal</span>: body.literal + flags.literal,
            <span class="hljs-attr">value</span>: value,
            <span class="hljs-attr">regex</span>: {
                <span class="hljs-attr">pattern</span>: body.value,
                <span class="hljs-attr">flags</span>: flags.value
            },
            <span class="hljs-attr">start</span>: start,
            <span class="hljs-attr">end</span>: index
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectRegex</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            <span class="hljs-attr">start</span>: {
                <span class="hljs-attr">line</span>: lineNumber,
                <span class="hljs-attr">column</span>: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            <span class="hljs-attr">line</span>: lineNumber,
            <span class="hljs-attr">column</span>: index - lineStart
        };

        <span class="hljs-comment">/* istanbul ignore next */</span>
        <span class="hljs-keyword">if</span> (!extra.tokenize) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-54" id="section-54"></a>
</div>
<p>Pop the previous token, which is likely '/' or '/='</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (extra.tokens.length &gt; <span class="hljs-number">0</span>) {
                token = extra.tokens[extra.tokens.length - <span class="hljs-number">1</span>];
                <span class="hljs-keyword">if</span> (token.range[<span class="hljs-number">0</span>] === pos &amp;&amp; token.type === <span class="hljs-string">'Punctuator'</span>) {
                    <span class="hljs-keyword">if</span> (token.value === <span class="hljs-string">'/'</span> || token.value === <span class="hljs-string">'/='</span>) {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                <span class="hljs-attr">type</span>: <span class="hljs-string">'RegularExpression'</span>,
                <span class="hljs-attr">value</span>: regex.literal,
                <span class="hljs-attr">regex</span>: regex.regex,
                <span class="hljs-attr">range</span>: [pos, index],
                <span class="hljs-attr">loc</span>: loc
            });
        }

        <span class="hljs-keyword">return</span> regex;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isIdentifierName</span>(<span class="hljs-params">token</span>) </span>{
        <span class="hljs-keyword">return</span> token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-55" id="section-55"></a>
</div>
<p>Using the following algorithm:
https://github.com/mozilla/sweet.js/wiki/design</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">advanceSlash</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> regex, previous, check;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testKeyword</span>(<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">return</span> value &amp;&amp; (value.length &gt; <span class="hljs-number">1</span>) &amp;&amp; (value[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">'a'</span>) &amp;&amp; (value[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">'z'</span>);
        }

        previous = extra.tokenValues[extra.tokens.length - <span class="hljs-number">1</span>];
        regex = (previous !== <span class="hljs-literal">null</span>);

        <span class="hljs-keyword">switch</span> (previous) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'this'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">']'</span>:
            regex = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>:
            check = extra.tokenValues[extra.openParenToken - <span class="hljs-number">1</span>];
            regex = (check === <span class="hljs-string">'if'</span> || check === <span class="hljs-string">'while'</span> || check === <span class="hljs-string">'for'</span> || check === <span class="hljs-string">'with'</span>);
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'}'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-56" id="section-56"></a>
</div>
<p>Dividing a function by anything makes little sense,
but we have to check for that.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            regex = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (testKeyword(extra.tokenValues[extra.openCurlyToken - <span class="hljs-number">3</span>])) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-57" id="section-57"></a>
</div>
<p>Anonymous function, e.g. function(){} /42</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                check = extra.tokenValues[extra.openCurlyToken - <span class="hljs-number">4</span>];
                regex = check ? (FnExprTokens.indexOf(check) &lt; <span class="hljs-number">0</span>) : <span class="hljs-literal">false</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (testKeyword(extra.tokenValues[extra.openCurlyToken - <span class="hljs-number">4</span>])) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-58" id="section-58"></a>
</div>
<p>Named function, e.g. function f(){} /42/</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                check = extra.tokenValues[extra.openCurlyToken - <span class="hljs-number">5</span>];
                regex = check ? (FnExprTokens.indexOf(check) &lt; <span class="hljs-number">0</span>) : <span class="hljs-literal">true</span>;
            }
        }

        <span class="hljs-keyword">return</span> regex ? collectRegex() : scanPunctuator();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">advance</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> cp, token;

        <span class="hljs-keyword">if</span> (index &gt;= length) {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">type</span>: Token.EOF,
                <span class="hljs-attr">lineNumber</span>: lineNumber,
                <span class="hljs-attr">lineStart</span>: lineStart,
                <span class="hljs-attr">start</span>: index,
                <span class="hljs-attr">end</span>: index
            };
        }

        cp = source.charCodeAt(index);

        <span class="hljs-keyword">if</span> (isIdentifierStart(cp)) {
            token = scanIdentifier();
            <span class="hljs-keyword">if</span> (strict &amp;&amp; isStrictModeReservedWord(token.value)) {
                token.type = Token.Keyword;
            }
            <span class="hljs-keyword">return</span> token;
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-59" id="section-59"></a>
</div>
<p>Very common: ( and ) and ;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (cp === <span class="hljs-number">0x28</span> || cp === <span class="hljs-number">0x29</span> || cp === <span class="hljs-number">0x3B</span>) {
            <span class="hljs-keyword">return</span> scanPunctuator();
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-60" id="section-60"></a>
</div>
<p>String literal starts with single quote (U+0027) or double quote (U+0022).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (cp === <span class="hljs-number">0x27</span> || cp === <span class="hljs-number">0x22</span>) {
            <span class="hljs-keyword">return</span> scanStringLiteral();
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-61" id="section-61"></a>
</div>
<p>Dot (.) U+002E can also start a floating-point number, hence the need
to check the next character.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (cp === <span class="hljs-number">0x2E</span>) {
            <span class="hljs-keyword">if</span> (isDecimalDigit(source.charCodeAt(index + <span class="hljs-number">1</span>))) {
                <span class="hljs-keyword">return</span> scanNumericLiteral();
            }
            <span class="hljs-keyword">return</span> scanPunctuator();
        }

        <span class="hljs-keyword">if</span> (isDecimalDigit(cp)) {
            <span class="hljs-keyword">return</span> scanNumericLiteral();
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-62" id="section-62"></a>
</div>
<p>Slash (/) U+002F can also start a regex.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (extra.tokenize &amp;&amp; cp === <span class="hljs-number">0x2F</span>) {
            <span class="hljs-keyword">return</span> advanceSlash();
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-63" id="section-63"></a>
</div>
<p>Template literals start with ` (U+0060) for template head
or } (U+007D) for template middle or template tail.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (cp === <span class="hljs-number">0x60</span> || (cp === <span class="hljs-number">0x7D</span> &amp;&amp; state.curlyStack[state.curlyStack.length - <span class="hljs-number">1</span>] === <span class="hljs-string">'${'</span>)) {
            <span class="hljs-keyword">return</span> scanTemplate();
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-64" id="section-64"></a>
</div>
<p>Possible identifier start in a surrogate pair.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (cp &gt;= <span class="hljs-number">0xD800</span> &amp;&amp; cp &lt; <span class="hljs-number">0xDFFF</span>) {
            cp = codePointAt(index);
            <span class="hljs-keyword">if</span> (isIdentifierStart(cp)) {
                <span class="hljs-keyword">return</span> scanIdentifier();
            }
        }

        <span class="hljs-keyword">return</span> scanPunctuator();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectToken</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> loc, token, value, entry;

        loc = {
            <span class="hljs-attr">start</span>: {
                <span class="hljs-attr">line</span>: lineNumber,
                <span class="hljs-attr">column</span>: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            <span class="hljs-attr">line</span>: lineNumber,
            <span class="hljs-attr">column</span>: index - lineStart
        };

        <span class="hljs-keyword">if</span> (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                <span class="hljs-attr">type</span>: TokenName[token.type],
                <span class="hljs-attr">value</span>: value,
                <span class="hljs-attr">range</span>: [token.start, token.end],
                <span class="hljs-attr">loc</span>: loc
            };
            <span class="hljs-keyword">if</span> (token.regex) {
                entry.regex = {
                    <span class="hljs-attr">pattern</span>: token.regex.pattern,
                    <span class="hljs-attr">flags</span>: token.regex.flags
                };
            }
            <span class="hljs-keyword">if</span> (extra.tokenValues) {
                extra.tokenValues.push((entry.type === <span class="hljs-string">'Punctuator'</span> || entry.type === <span class="hljs-string">'Keyword'</span>) ? entry.value : <span class="hljs-literal">null</span>);
            }
            <span class="hljs-keyword">if</span> (extra.tokenize) {
                <span class="hljs-keyword">if</span> (!extra.range) {
                    <span class="hljs-keyword">delete</span> entry.range;
                }
                <span class="hljs-keyword">if</span> (!extra.loc) {
                    <span class="hljs-keyword">delete</span> entry.loc;
                }
                <span class="hljs-keyword">if</span> (extra.delegate) {
                    entry = extra.delegate(entry);
                }
            }
            extra.tokens.push(entry);
        }

        <span class="hljs-keyword">return</span> token;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lex</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> token;
        scanning = <span class="hljs-literal">true</span>;

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        skipComment();

        token = lookahead;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (<span class="hljs-keyword">typeof</span> extra.tokens !== <span class="hljs-string">'undefined'</span>) ? collectToken() : advance();
        scanning = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> token;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peek</span>(<span class="hljs-params"></span>) </span>{
        scanning = <span class="hljs-literal">true</span>;

        skipComment();

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (<span class="hljs-keyword">typeof</span> extra.tokens !== <span class="hljs-string">'undefined'</span>) ? collectToken() : advance();
        scanning = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Position</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.line = startLineNumber;
        <span class="hljs-keyword">this</span>.column = startIndex - startLineStart;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceLocation</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.start = <span class="hljs-keyword">new</span> Position();
        <span class="hljs-keyword">this</span>.end = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WrappingSourceLocation</span>(<span class="hljs-params">startToken</span>) </span>{
        <span class="hljs-keyword">this</span>.start = {
            <span class="hljs-attr">line</span>: startToken.lineNumber,
            <span class="hljs-attr">column</span>: startToken.start - startToken.lineStart
        };
        <span class="hljs-keyword">this</span>.end = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (extra.range) {
            <span class="hljs-keyword">this</span>.range = [startIndex, <span class="hljs-number">0</span>];
        }
        <span class="hljs-keyword">if</span> (extra.loc) {
            <span class="hljs-keyword">this</span>.loc = <span class="hljs-keyword">new</span> SourceLocation();
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WrappingNode</span>(<span class="hljs-params">startToken</span>) </span>{
        <span class="hljs-keyword">if</span> (extra.range) {
            <span class="hljs-keyword">this</span>.range = [startToken.start, <span class="hljs-number">0</span>];
        }
        <span class="hljs-keyword">if</span> (extra.loc) {
            <span class="hljs-keyword">this</span>.loc = <span class="hljs-keyword">new</span> WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        <span class="hljs-attr">processComment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> lastChild,
                innerComments,
                leadingComments,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                i,
                comment,
                last = bottomRight[bottomRight.length - <span class="hljs-number">1</span>];

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === Syntax.Program) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.body.length &gt; <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">return</span>;
                }
            }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-65" id="section-65"></a>
</div>
<div class="dox">
<div class="summary">
<p>patch innnerComments for properties empty block
<code>function a() {/** comments **\/}</code></p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === Syntax.BlockStatement &amp;&amp; <span class="hljs-keyword">this</span>.body.length === <span class="hljs-number">0</span>) {
                innerComments = [];
                <span class="hljs-keyword">for</span> (i = extra.leadingComments.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
                    comment = extra.leadingComments[i];
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.range[<span class="hljs-number">1</span>] &gt;= comment.range[<span class="hljs-number">1</span>]) {
                        innerComments.unshift(comment);
                        extra.leadingComments.splice(i, <span class="hljs-number">1</span>);
                        extra.trailingComments.splice(i, <span class="hljs-number">1</span>);
                    }
                }
                <span class="hljs-keyword">if</span> (innerComments.length) {
                    <span class="hljs-keyword">this</span>.innerComments = innerComments;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-66" id="section-66"></a>
</div>
<p>bottomRight.push(this);</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    <span class="hljs-keyword">return</span>;
                }
            }

            <span class="hljs-keyword">if</span> (extra.trailingComments.length &gt; <span class="hljs-number">0</span>) {
                trailingComments = [];
                <span class="hljs-keyword">for</span> (i = extra.trailingComments.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
                    comment = extra.trailingComments[i];
                    <span class="hljs-keyword">if</span> (comment.range[<span class="hljs-number">0</span>] &gt;= <span class="hljs-keyword">this</span>.range[<span class="hljs-number">1</span>]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, <span class="hljs-number">1</span>);
                    }
                }
                extra.trailingComments = [];
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (last &amp;&amp; last.trailingComments &amp;&amp; last.trailingComments[<span class="hljs-number">0</span>].range[<span class="hljs-number">0</span>] &gt;= <span class="hljs-keyword">this</span>.range[<span class="hljs-number">1</span>]) {
                    trailingComments = last.trailingComments;
                    <span class="hljs-keyword">delete</span> last.trailingComments;
                }
            }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-67" id="section-67"></a>
</div>
<p>Eating the stack.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">while</span> (last &amp;&amp; last.range[<span class="hljs-number">0</span>] &gt;= <span class="hljs-keyword">this</span>.range[<span class="hljs-number">0</span>]) {
                lastChild = bottomRight.pop();
                last = bottomRight[bottomRight.length - <span class="hljs-number">1</span>];
            }

            <span class="hljs-keyword">if</span> (lastChild) {
                <span class="hljs-keyword">if</span> (lastChild.leadingComments) {
                    leadingComments = [];
                    <span class="hljs-keyword">for</span> (i = lastChild.leadingComments.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
                        comment = lastChild.leadingComments[i];
                        <span class="hljs-keyword">if</span> (comment.range[<span class="hljs-number">1</span>] &lt;= <span class="hljs-keyword">this</span>.range[<span class="hljs-number">0</span>]) {
                            leadingComments.unshift(comment);
                            lastChild.leadingComments.splice(i, <span class="hljs-number">1</span>);
                        }
                    }

                    <span class="hljs-keyword">if</span> (!lastChild.leadingComments.length) {
                        lastChild.leadingComments = <span class="hljs-literal">undefined</span>;
                    }
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (extra.leadingComments.length &gt; <span class="hljs-number">0</span>) {
                leadingComments = [];
                <span class="hljs-keyword">for</span> (i = extra.leadingComments.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
                    comment = extra.leadingComments[i];
                    <span class="hljs-keyword">if</span> (comment.range[<span class="hljs-number">1</span>] &lt;= <span class="hljs-keyword">this</span>.range[<span class="hljs-number">0</span>]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, <span class="hljs-number">1</span>);
                    }
                }
            }


            <span class="hljs-keyword">if</span> (leadingComments &amp;&amp; leadingComments.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">this</span>.leadingComments = leadingComments;
            }
            <span class="hljs-keyword">if</span> (trailingComments &amp;&amp; trailingComments.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">this</span>.trailingComments = trailingComments;
            }

            bottomRight.push(<span class="hljs-keyword">this</span>);
        },

        <span class="hljs-attr">finish</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (extra.range) {
                <span class="hljs-keyword">this</span>.range[<span class="hljs-number">1</span>] = lastIndex;
            }
            <span class="hljs-keyword">if</span> (extra.loc) {
                <span class="hljs-keyword">this</span>.loc.end = {
                    <span class="hljs-attr">line</span>: lastLineNumber,
                    <span class="hljs-attr">column</span>: lastIndex - lastLineStart
                };
                <span class="hljs-keyword">if</span> (extra.source) {
                    <span class="hljs-keyword">this</span>.loc.source = extra.source;
                }
            }

            <span class="hljs-keyword">if</span> (extra.attachComment) {
                <span class="hljs-keyword">this</span>.processComment();
            }
        },

        <span class="hljs-attr">finishArrayExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elements</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ArrayExpression;
            <span class="hljs-keyword">this</span>.elements = elements;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishArrayPattern</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elements</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ArrayPattern;
            <span class="hljs-keyword">this</span>.elements = elements;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishArrowFunctionExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params, defaults, body, expression</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ArrowFunctionExpression;
            <span class="hljs-keyword">this</span>.id = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">this</span>.params = params;
            <span class="hljs-keyword">this</span>.defaults = defaults;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.generator = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">this</span>.expression = expression;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishAssignmentExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">operator, left, right</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.AssignmentExpression;
            <span class="hljs-keyword">this</span>.operator = operator;
            <span class="hljs-keyword">this</span>.left = left;
            <span class="hljs-keyword">this</span>.right = right;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishAssignmentPattern</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.AssignmentPattern;
            <span class="hljs-keyword">this</span>.left = left;
            <span class="hljs-keyword">this</span>.right = right;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishBinaryExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">operator, left, right</span>) </span>{
            <span class="hljs-keyword">this</span>.type = (operator === <span class="hljs-string">'||'</span> || operator === <span class="hljs-string">'&amp;&amp;'</span>) ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            <span class="hljs-keyword">this</span>.operator = operator;
            <span class="hljs-keyword">this</span>.left = left;
            <span class="hljs-keyword">this</span>.right = right;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishBlockStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.BlockStatement;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishBreakStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">label</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.BreakStatement;
            <span class="hljs-keyword">this</span>.label = label;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishCallExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callee, args</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.CallExpression;
            <span class="hljs-keyword">this</span>.callee = callee;
            <span class="hljs-keyword">this</span>.arguments = args;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishCatchClause</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param, body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.CatchClause;
            <span class="hljs-keyword">this</span>.param = param;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishClassBody</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ClassBody;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishClassDeclaration</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, superClass, body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ClassDeclaration;
            <span class="hljs-keyword">this</span>.id = id;
            <span class="hljs-keyword">this</span>.superClass = superClass;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishClassExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, superClass, body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ClassExpression;
            <span class="hljs-keyword">this</span>.id = id;
            <span class="hljs-keyword">this</span>.superClass = superClass;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishConditionalExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">test, consequent, alternate</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ConditionalExpression;
            <span class="hljs-keyword">this</span>.test = test;
            <span class="hljs-keyword">this</span>.consequent = consequent;
            <span class="hljs-keyword">this</span>.alternate = alternate;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishContinueStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">label</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ContinueStatement;
            <span class="hljs-keyword">this</span>.label = label;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishDebuggerStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.DebuggerStatement;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishDoWhileStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">body, test</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.DoWhileStatement;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.test = test;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishEmptyStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.EmptyStatement;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishExpressionStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">expression</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ExpressionStatement;
            <span class="hljs-keyword">this</span>.expression = expression;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishForStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">init, test, update, body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ForStatement;
            <span class="hljs-keyword">this</span>.init = init;
            <span class="hljs-keyword">this</span>.test = test;
            <span class="hljs-keyword">this</span>.update = update;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishForOfStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right, body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ForOfStatement;
            <span class="hljs-keyword">this</span>.left = left;
            <span class="hljs-keyword">this</span>.right = right;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishForInStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right, body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ForInStatement;
            <span class="hljs-keyword">this</span>.left = left;
            <span class="hljs-keyword">this</span>.right = right;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.each = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishFunctionDeclaration</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, params, defaults, body, generator</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.FunctionDeclaration;
            <span class="hljs-keyword">this</span>.id = id;
            <span class="hljs-keyword">this</span>.params = params;
            <span class="hljs-keyword">this</span>.defaults = defaults;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.generator = generator;
            <span class="hljs-keyword">this</span>.expression = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishFunctionExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, params, defaults, body, generator</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.FunctionExpression;
            <span class="hljs-keyword">this</span>.id = id;
            <span class="hljs-keyword">this</span>.params = params;
            <span class="hljs-keyword">this</span>.defaults = defaults;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.generator = generator;
            <span class="hljs-keyword">this</span>.expression = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishIdentifier</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.Identifier;
            <span class="hljs-keyword">this</span>.name = name;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishIfStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">test, consequent, alternate</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.IfStatement;
            <span class="hljs-keyword">this</span>.test = test;
            <span class="hljs-keyword">this</span>.consequent = consequent;
            <span class="hljs-keyword">this</span>.alternate = alternate;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishLabeledStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">label, body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.LabeledStatement;
            <span class="hljs-keyword">this</span>.label = label;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">token</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.Literal;
            <span class="hljs-keyword">this</span>.value = token.value;
            <span class="hljs-keyword">this</span>.raw = source.slice(token.start, token.end);
            <span class="hljs-keyword">if</span> (token.regex) {
                <span class="hljs-keyword">this</span>.regex = token.regex;
            }
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishMemberExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">accessor, object, property</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.MemberExpression;
            <span class="hljs-keyword">this</span>.computed = accessor === <span class="hljs-string">'['</span>;
            <span class="hljs-keyword">this</span>.object = object;
            <span class="hljs-keyword">this</span>.property = property;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishMetaProperty</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">meta, property</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.MetaProperty;
            <span class="hljs-keyword">this</span>.meta = meta;
            <span class="hljs-keyword">this</span>.property = property;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishNewExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callee, args</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.NewExpression;
            <span class="hljs-keyword">this</span>.callee = callee;
            <span class="hljs-keyword">this</span>.arguments = args;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishObjectExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">properties</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ObjectExpression;
            <span class="hljs-keyword">this</span>.properties = properties;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishObjectPattern</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">properties</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ObjectPattern;
            <span class="hljs-keyword">this</span>.properties = properties;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishPostfixExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">operator, argument</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.UpdateExpression;
            <span class="hljs-keyword">this</span>.operator = operator;
            <span class="hljs-keyword">this</span>.argument = argument;
            <span class="hljs-keyword">this</span>.prefix = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishProgram</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">body, sourceType</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.Program;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.sourceType = sourceType;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishProperty</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">kind, key, computed, value, method, shorthand</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.Property;
            <span class="hljs-keyword">this</span>.key = key;
            <span class="hljs-keyword">this</span>.computed = computed;
            <span class="hljs-keyword">this</span>.value = value;
            <span class="hljs-keyword">this</span>.kind = kind;
            <span class="hljs-keyword">this</span>.method = method;
            <span class="hljs-keyword">this</span>.shorthand = shorthand;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishRestElement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argument</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.RestElement;
            <span class="hljs-keyword">this</span>.argument = argument;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishReturnStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argument</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ReturnStatement;
            <span class="hljs-keyword">this</span>.argument = argument;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishSequenceExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">expressions</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.SequenceExpression;
            <span class="hljs-keyword">this</span>.expressions = expressions;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishSpreadElement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argument</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.SpreadElement;
            <span class="hljs-keyword">this</span>.argument = argument;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishSwitchCase</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">test, consequent</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.SwitchCase;
            <span class="hljs-keyword">this</span>.test = test;
            <span class="hljs-keyword">this</span>.consequent = consequent;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishSuper</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.Super;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishSwitchStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">discriminant, cases</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.SwitchStatement;
            <span class="hljs-keyword">this</span>.discriminant = discriminant;
            <span class="hljs-keyword">this</span>.cases = cases;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishTaggedTemplateExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tag, quasi</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.TaggedTemplateExpression;
            <span class="hljs-keyword">this</span>.tag = tag;
            <span class="hljs-keyword">this</span>.quasi = quasi;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishTemplateElement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, tail</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.TemplateElement;
            <span class="hljs-keyword">this</span>.value = value;
            <span class="hljs-keyword">this</span>.tail = tail;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishTemplateLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">quasis, expressions</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.TemplateLiteral;
            <span class="hljs-keyword">this</span>.quasis = quasis;
            <span class="hljs-keyword">this</span>.expressions = expressions;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishThisExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ThisExpression;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishThrowStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argument</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ThrowStatement;
            <span class="hljs-keyword">this</span>.argument = argument;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishTryStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">block, handler, finalizer</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.TryStatement;
            <span class="hljs-keyword">this</span>.block = block;
            <span class="hljs-keyword">this</span>.guardedHandlers = [];
            <span class="hljs-keyword">this</span>.handlers = handler ? [handler] : [];
            <span class="hljs-keyword">this</span>.handler = handler;
            <span class="hljs-keyword">this</span>.finalizer = finalizer;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishUnaryExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">operator, argument</span>) </span>{
            <span class="hljs-keyword">this</span>.type = (operator === <span class="hljs-string">'++'</span> || operator === <span class="hljs-string">'--'</span>) ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            <span class="hljs-keyword">this</span>.operator = operator;
            <span class="hljs-keyword">this</span>.argument = argument;
            <span class="hljs-keyword">this</span>.prefix = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishVariableDeclaration</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">declarations</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.VariableDeclaration;
            <span class="hljs-keyword">this</span>.declarations = declarations;
            <span class="hljs-keyword">this</span>.kind = <span class="hljs-string">'var'</span>;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishLexicalDeclaration</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">declarations, kind</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.VariableDeclaration;
            <span class="hljs-keyword">this</span>.declarations = declarations;
            <span class="hljs-keyword">this</span>.kind = kind;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishVariableDeclarator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, init</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.VariableDeclarator;
            <span class="hljs-keyword">this</span>.id = id;
            <span class="hljs-keyword">this</span>.init = init;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishWhileStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">test, body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.WhileStatement;
            <span class="hljs-keyword">this</span>.test = test;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishWithStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">object, body</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.WithStatement;
            <span class="hljs-keyword">this</span>.object = object;
            <span class="hljs-keyword">this</span>.body = body;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishExportSpecifier</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">local, exported</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ExportSpecifier;
            <span class="hljs-keyword">this</span>.exported = exported || local;
            <span class="hljs-keyword">this</span>.local = local;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishImportDefaultSpecifier</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">local</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ImportDefaultSpecifier;
            <span class="hljs-keyword">this</span>.local = local;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishImportNamespaceSpecifier</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">local</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ImportNamespaceSpecifier;
            <span class="hljs-keyword">this</span>.local = local;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishExportNamedDeclaration</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">declaration, specifiers, src</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ExportNamedDeclaration;
            <span class="hljs-keyword">this</span>.declaration = declaration;
            <span class="hljs-keyword">this</span>.specifiers = specifiers;
            <span class="hljs-keyword">this</span>.source = src;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishExportDefaultDeclaration</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">declaration</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ExportDefaultDeclaration;
            <span class="hljs-keyword">this</span>.declaration = declaration;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishExportAllDeclaration</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">src</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ExportAllDeclaration;
            <span class="hljs-keyword">this</span>.source = src;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishImportSpecifier</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">local, imported</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ImportSpecifier;
            <span class="hljs-keyword">this</span>.local = local || imported;
            <span class="hljs-keyword">this</span>.imported = imported;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishImportDeclaration</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">specifiers, src</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.ImportDeclaration;
            <span class="hljs-keyword">this</span>.specifiers = specifiers;
            <span class="hljs-keyword">this</span>.source = src;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },

        <span class="hljs-attr">finishYieldExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argument, delegate</span>) </span>{
            <span class="hljs-keyword">this</span>.type = Syntax.YieldExpression;
            <span class="hljs-keyword">this</span>.argument = argument;
            <span class="hljs-keyword">this</span>.delegate = delegate;
            <span class="hljs-keyword">this</span>.finish();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        }
    };


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recordError</span>(<span class="hljs-params">error</span>) </span>{
        <span class="hljs-keyword">var</span> e, existing;

        <span class="hljs-keyword">for</span> (e = <span class="hljs-number">0</span>; e &lt; extra.errors.length; e++) {
            existing = extra.errors[e];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-68" id="section-68"></a>
</div>
<p>Prevent duplicated error.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-comment">/* istanbul ignore next */</span>
            <span class="hljs-keyword">if</span> (existing.index === error.index &amp;&amp; existing.message === error.message) {
                <span class="hljs-keyword">return</span>;
            }
        }

        extra.errors.push(error);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructError</span>(<span class="hljs-params">msg, column</span>) </span>{
        <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(msg);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> error;
        } <span class="hljs-keyword">catch</span> (base) {
            <span class="hljs-comment">/* istanbul ignore else */</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.create &amp;&amp; <span class="hljs-built_in">Object</span>.defineProperty) {
                error = <span class="hljs-built_in">Object</span>.create(base);
                <span class="hljs-built_in">Object</span>.defineProperty(error, <span class="hljs-string">'column'</span>, { <span class="hljs-attr">value</span>: column });
            }
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">return</span> error;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createError</span>(<span class="hljs-params">line, pos, description</span>) </span>{
        <span class="hljs-keyword">var</span> msg, column, error;

        msg = <span class="hljs-string">'Line '</span> + line + <span class="hljs-string">': '</span> + description;
        column = pos - (scanning ? lineStart : lastLineStart) + <span class="hljs-number">1</span>;
        error = constructError(msg, column);
        error.lineNumber = line;
        error.description = description;
        error.index = pos;
        <span class="hljs-keyword">return</span> error;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-69" id="section-69"></a>
</div>
<p>Throw an exception</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwError</span>(<span class="hljs-params">messageFormat</span>) </span>{
        <span class="hljs-keyword">var</span> args, msg;

        args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
        msg = messageFormat.replace(<span class="hljs-regexp">/%(\d)/g</span>,
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">whole, idx</span>) </span>{
                assert(idx &lt; args.length, <span class="hljs-string">'Message reference must be in range'</span>);
                <span class="hljs-keyword">return</span> args[idx];
            }
        );

        <span class="hljs-keyword">throw</span> createError(lastLineNumber, lastIndex, msg);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tolerateError</span>(<span class="hljs-params">messageFormat</span>) </span>{
        <span class="hljs-keyword">var</span> args, msg, error;

        args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
        <span class="hljs-comment">/* istanbul ignore next */</span>
        msg = messageFormat.replace(<span class="hljs-regexp">/%(\d)/g</span>,
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">whole, idx</span>) </span>{
                assert(idx &lt; args.length, <span class="hljs-string">'Message reference must be in range'</span>);
                <span class="hljs-keyword">return</span> args[idx];
            }
        );

        error = createError(lineNumber, lastIndex, msg);
        <span class="hljs-keyword">if</span> (extra.errors) {
            recordError(error);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> error;
        }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-70" id="section-70"></a>
</div>
<p>Throw an exception because of the token.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unexpectedTokenError</span>(<span class="hljs-params">token, message</span>) </span>{
        <span class="hljs-keyword">var</span> value, msg = message || Messages.UnexpectedToken;

        <span class="hljs-keyword">if</span> (token) {
            <span class="hljs-keyword">if</span> (!message) {
                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
                    Messages.UnexpectedToken;

                <span class="hljs-keyword">if</span> (token.type === Token.Keyword) {
                    <span class="hljs-keyword">if</span> (isFutureReservedWord(token.value)) {
                        msg = Messages.UnexpectedReserved;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strict &amp;&amp; isStrictModeReservedWord(token.value)) {
                        msg = Messages.StrictReservedWord;
                    }
                }
            }

            value = (token.type === Token.Template) ? token.value.raw : token.value;
        } <span class="hljs-keyword">else</span> {
            value = <span class="hljs-string">'ILLEGAL'</span>;
        }

        msg = msg.replace(<span class="hljs-string">'%0'</span>, value);

        <span class="hljs-keyword">return</span> (token &amp;&amp; <span class="hljs-keyword">typeof</span> token.lineNumber === <span class="hljs-string">'number'</span>) ?
            createError(token.lineNumber, token.start, msg) :
            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwUnexpectedToken</span>(<span class="hljs-params">token, message</span>) </span>{
        <span class="hljs-keyword">throw</span> unexpectedTokenError(token, message);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tolerateUnexpectedToken</span>(<span class="hljs-params">token, message</span>) </span>{
        <span class="hljs-keyword">var</span> error = unexpectedTokenError(token, message);
        <span class="hljs-keyword">if</span> (extra.errors) {
            recordError(error);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> error;
        }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-71" id="section-71"></a>
</div>
<p>Expect the next token to match the specified punctuator.
If not, an exception will be thrown.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expect</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">var</span> token = lex();
        <span class="hljs-keyword">if</span> (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-72" id="section-72"></a>
</div>
<div class="dox">
<div class="summary">
<p>Quietly expect a comma when in tolerant mode, otherwise delegates to <code>expect(value)</code></p>
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectCommaSeparator</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> token;

        <span class="hljs-keyword">if</span> (extra.errors) {
            token = lookahead;
            <span class="hljs-keyword">if</span> (token.type === Token.Punctuator &amp;&amp; token.value === <span class="hljs-string">','</span>) {
                lex();
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token.type === Token.Punctuator &amp;&amp; token.value === <span class="hljs-string">';'</span>) {
                lex();
                tolerateUnexpectedToken(token);
            } <span class="hljs-keyword">else</span> {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        } <span class="hljs-keyword">else</span> {
            expect(<span class="hljs-string">','</span>);
        }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-73" id="section-73"></a>
</div>
<p>Expect the next token to match the specified keyword.
If not, an exception will be thrown.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectKeyword</span>(<span class="hljs-params">keyword</span>) </span>{
        <span class="hljs-keyword">var</span> token = lex();
        <span class="hljs-keyword">if</span> (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-74" id="section-74"></a>
</div>
<p>Return true if the next token matches the specified punctuator.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> lookahead.type === Token.Punctuator &amp;&amp; lookahead.value === value;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-75" id="section-75"></a>
</div>
<p>Return true if the next token matches the specified keyword</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchKeyword</span>(<span class="hljs-params">keyword</span>) </span>{
        <span class="hljs-keyword">return</span> lookahead.type === Token.Keyword &amp;&amp; lookahead.value === keyword;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-76" id="section-76"></a>
</div>
<p>Return true if the next token matches the specified contextual keyword
(where an identifier is sometimes a keyword depending on the context)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchContextualKeyword</span>(<span class="hljs-params">keyword</span>) </span>{
        <span class="hljs-keyword">return</span> lookahead.type === Token.Identifier &amp;&amp; lookahead.value === keyword;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-77" id="section-77"></a>
</div>
<p>Return true if the next token is an assignment operator</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchAssign</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> op;

        <span class="hljs-keyword">if</span> (lookahead.type !== Token.Punctuator) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        op = lookahead.value;
        <span class="hljs-keyword">return</span> op === <span class="hljs-string">'='</span> ||
            op === <span class="hljs-string">'*='</span> ||
            op === <span class="hljs-string">'/='</span> ||
            op === <span class="hljs-string">'%='</span> ||
            op === <span class="hljs-string">'+='</span> ||
            op === <span class="hljs-string">'-='</span> ||
            op === <span class="hljs-string">'&lt;&lt;='</span> ||
            op === <span class="hljs-string">'&gt;&gt;='</span> ||
            op === <span class="hljs-string">'&gt;&gt;&gt;='</span> ||
            op === <span class="hljs-string">'&amp;='</span> ||
            op === <span class="hljs-string">'^='</span> ||
            op === <span class="hljs-string">'|='</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">consumeSemicolon</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-78" id="section-78"></a>
</div>
<p>Catch the very common case first: immediately a semicolon (U+003B).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (source.charCodeAt(startIndex) === <span class="hljs-number">0x3B</span> || match(<span class="hljs-string">';'</span>)) {
            lex();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (hasLineTerminator) {
            <span class="hljs-keyword">return</span>;
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-79" id="section-79"></a>
</div>
<p>FIXME(ikarienator): this is seemingly an issue in the previous location info convention.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        lastIndex = startIndex;
        lastLineNumber = startLineNumber;
        lastLineStart = startLineStart;

        <span class="hljs-keyword">if</span> (lookahead.type !== Token.EOF &amp;&amp; !match(<span class="hljs-string">'}'</span>)) {
            throwUnexpectedToken(lookahead);
        }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-80" id="section-80"></a>
</div>
<p>Cover grammar support.</p>
<p>When an assignment expression position starts with an left parenthesis, the determination of the type
of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
or the first comma. This situation also defers the determination of all the expressions nested in the pair.</p>
<p>There are three productions that can be parsed in a parentheses pair that needs to be determined
after the outermost pair is closed. They are:</p>
<ol>
<li>AssignmentExpression</li>
<li>BindingElements</li>
<li>AssignmentTargets</li>
</ol>
<p>In order to avoid exponential backtracking, we use two flags to denote if the production can be
binding element or assignment target.</p>
<p>The three productions have the relationship:</p>
<p>BindingElements  AssignmentTargets  AssignmentExpression</p>
<p>with a single exception that CoverInitializedName when used directly in an Expression, generates
an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.</p>
<p>isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
effect the current flags. This means the production the parser parses is only used as an expression. Therefore
the CoverInitializedName check is conducted.</p>
<p>inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
the flags outside of the parser. This means the production the parser parses is used as a part of a potential
pattern. The CoverInitializedName check is deferred.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isolateCoverGrammar</span>(<span class="hljs-params">parser</span>) </span>{
        <span class="hljs-keyword">var</span> oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = <span class="hljs-literal">true</span>;
        isAssignmentTarget = <span class="hljs-literal">true</span>;
        firstCoverInitializedNameError = <span class="hljs-literal">null</span>;
        result = parser();
        <span class="hljs-keyword">if</span> (firstCoverInitializedNameError !== <span class="hljs-literal">null</span>) {
            throwUnexpectedToken(firstCoverInitializedNameError);
        }
        isBindingElement = oldIsBindingElement;
        isAssignmentTarget = oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritCoverGrammar</span>(<span class="hljs-params">parser</span>) </span>{
        <span class="hljs-keyword">var</span> oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = <span class="hljs-literal">true</span>;
        isAssignmentTarget = <span class="hljs-literal">true</span>;
        firstCoverInitializedNameError = <span class="hljs-literal">null</span>;
        result = parser();
        isBindingElement = isBindingElement &amp;&amp; oldIsBindingElement;
        isAssignmentTarget = isAssignmentTarget &amp;&amp; oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
        <span class="hljs-keyword">return</span> result;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-81" id="section-81"></a>
</div>
<p>ECMA-262 13.3.3 Destructuring Binding Patterns</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseArrayPattern</span>(<span class="hljs-params">params, kind</span>) </span>{
        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(), elements = [], rest, restNode;
        expect(<span class="hljs-string">'['</span>);

        <span class="hljs-keyword">while</span> (!match(<span class="hljs-string">']'</span>)) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">','</span>)) {
                lex();
                elements.push(<span class="hljs-literal">null</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'...'</span>)) {
                    restNode = <span class="hljs-keyword">new</span> Node();
                    lex();
                    params.push(lookahead);
                    rest = parseVariableIdentifier(kind);
                    elements.push(restNode.finishRestElement(rest));
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> {
                    elements.push(parsePatternWithDefault(params, kind));
                }
                <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">']'</span>)) {
                    expect(<span class="hljs-string">','</span>);
                }
            }

        }

        expect(<span class="hljs-string">']'</span>);

        <span class="hljs-keyword">return</span> node.finishArrayPattern(elements);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePropertyPattern</span>(<span class="hljs-params">params, kind</span>) </span>{
        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(), key, keyToken, computed = match(<span class="hljs-string">'['</span>), init;
        <span class="hljs-keyword">if</span> (lookahead.type === Token.Identifier) {
            keyToken = lookahead;
            key = parseVariableIdentifier();
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'='</span>)) {
                params.push(keyToken);
                lex();
                init = parseAssignmentExpression();

                <span class="hljs-keyword">return</span> node.finishProperty(
                    <span class="hljs-string">'init'</span>, key, <span class="hljs-literal">false</span>,
                    <span class="hljs-keyword">new</span> WrappingNode(keyToken).finishAssignmentPattern(key, init), <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">':'</span>)) {
                params.push(keyToken);
                <span class="hljs-keyword">return</span> node.finishProperty(<span class="hljs-string">'init'</span>, key, <span class="hljs-literal">false</span>, key, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
            }
        } <span class="hljs-keyword">else</span> {
            key = parseObjectPropertyKey();
        }
        expect(<span class="hljs-string">':'</span>);
        init = parsePatternWithDefault(params, kind);
        <span class="hljs-keyword">return</span> node.finishProperty(<span class="hljs-string">'init'</span>, key, computed, init, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseObjectPattern</span>(<span class="hljs-params">params, kind</span>) </span>{
        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(), properties = [];

        expect(<span class="hljs-string">'{'</span>);

        <span class="hljs-keyword">while</span> (!match(<span class="hljs-string">'}'</span>)) {
            properties.push(parsePropertyPattern(params, kind));
            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'}'</span>)) {
                expect(<span class="hljs-string">','</span>);
            }
        }

        lex();

        <span class="hljs-keyword">return</span> node.finishObjectPattern(properties);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePattern</span>(<span class="hljs-params">params, kind</span>) </span>{
        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'['</span>)) {
            <span class="hljs-keyword">return</span> parseArrayPattern(params, kind);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'{'</span>)) {
            <span class="hljs-keyword">return</span> parseObjectPattern(params, kind);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'let'</span>)) {
            <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'const'</span> || kind === <span class="hljs-string">'let'</span>) {
                tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);
            }
        }

        params.push(lookahead);
        <span class="hljs-keyword">return</span> parseVariableIdentifier(kind);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePatternWithDefault</span>(<span class="hljs-params">params, kind</span>) </span>{
        <span class="hljs-keyword">var</span> startToken = lookahead, pattern, previousAllowYield, right;
        pattern = parsePattern(params, kind);
        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'='</span>)) {
            lex();
            previousAllowYield = state.allowYield;
            state.allowYield = <span class="hljs-literal">true</span>;
            right = isolateCoverGrammar(parseAssignmentExpression);
            state.allowYield = previousAllowYield;
            pattern = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishAssignmentPattern(pattern, right);
        }
        <span class="hljs-keyword">return</span> pattern;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-82" id="section-82"></a>
</div>
<p>ECMA-262 12.2.5 Array Initializer</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseArrayInitializer</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> elements = [], node = <span class="hljs-keyword">new</span> Node(), restSpread;

        expect(<span class="hljs-string">'['</span>);

        <span class="hljs-keyword">while</span> (!match(<span class="hljs-string">']'</span>)) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">','</span>)) {
                lex();
                elements.push(<span class="hljs-literal">null</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'...'</span>)) {
                restSpread = <span class="hljs-keyword">new</span> Node();
                lex();
                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

                <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">']'</span>)) {
                    isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
                    expect(<span class="hljs-string">','</span>);
                }
                elements.push(restSpread);
            } <span class="hljs-keyword">else</span> {
                elements.push(inheritCoverGrammar(parseAssignmentExpression));

                <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">']'</span>)) {
                    expect(<span class="hljs-string">','</span>);
                }
            }
        }

        lex();

        <span class="hljs-keyword">return</span> node.finishArrayExpression(elements);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-83" id="section-83"></a>
</div>
<p>ECMA-262 12.2.6 Object Initializer</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePropertyFunction</span>(<span class="hljs-params">node, paramInfo, isGenerator</span>) </span>{
        <span class="hljs-keyword">var</span> previousStrict, body;

        isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;

        previousStrict = strict;
        body = isolateCoverGrammar(parseFunctionSourceElements);

        <span class="hljs-keyword">if</span> (strict &amp;&amp; paramInfo.firstRestricted) {
            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
        }
        <span class="hljs-keyword">if</span> (strict &amp;&amp; paramInfo.stricted) {
            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
        }

        strict = previousStrict;
        <span class="hljs-keyword">return</span> node.finishFunctionExpression(<span class="hljs-literal">null</span>, paramInfo.params, paramInfo.defaults, body, isGenerator);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePropertyMethodFunction</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> params, method, node = <span class="hljs-keyword">new</span> Node(),
            previousAllowYield = state.allowYield;

        state.allowYield = <span class="hljs-literal">false</span>;
        params = parseParams();
        state.allowYield = previousAllowYield;

        state.allowYield = <span class="hljs-literal">false</span>;
        method = parsePropertyFunction(node, params, <span class="hljs-literal">false</span>);
        state.allowYield = previousAllowYield;

        <span class="hljs-keyword">return</span> method;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseObjectPropertyKey</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> token, node = <span class="hljs-keyword">new</span> Node(), expr;

        token = lex();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-84" id="section-84"></a>
</div>
<p>Note: This function is called only from parseObjectProperty(), where
EOF and Punctuator tokens are already filtered out.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">switch</span> (token.type) {
        <span class="hljs-keyword">case</span> Token.StringLiteral:
        <span class="hljs-keyword">case</span> Token.NumericLiteral:
            <span class="hljs-keyword">if</span> (strict &amp;&amp; token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            <span class="hljs-keyword">return</span> node.finishLiteral(token);
        <span class="hljs-keyword">case</span> Token.Identifier:
        <span class="hljs-keyword">case</span> Token.BooleanLiteral:
        <span class="hljs-keyword">case</span> Token.NullLiteral:
        <span class="hljs-keyword">case</span> Token.Keyword:
            <span class="hljs-keyword">return</span> node.finishIdentifier(token.value);
        <span class="hljs-keyword">case</span> Token.Punctuator:
            <span class="hljs-keyword">if</span> (token.value === <span class="hljs-string">'['</span>) {
                expr = isolateCoverGrammar(parseAssignmentExpression);
                expect(<span class="hljs-string">']'</span>);
                <span class="hljs-keyword">return</span> expr;
            }
            <span class="hljs-keyword">break</span>;
        }
        throwUnexpectedToken(token);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookaheadPropertyName</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">switch</span> (lookahead.type) {
        <span class="hljs-keyword">case</span> Token.Identifier:
        <span class="hljs-keyword">case</span> Token.StringLiteral:
        <span class="hljs-keyword">case</span> Token.BooleanLiteral:
        <span class="hljs-keyword">case</span> Token.NullLiteral:
        <span class="hljs-keyword">case</span> Token.NumericLiteral:
        <span class="hljs-keyword">case</span> Token.Keyword:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">case</span> Token.Punctuator:
            <span class="hljs-keyword">return</span> lookahead.value === <span class="hljs-string">'['</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-85" id="section-85"></a>
</div>
<p>This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
it might be called at a position where there is in fact a short hand identifier pattern or a data property.
This can only be determined after we consumed up to the left parentheses.</p>
<p>In order to avoid back tracking, it returns <code>null</code> if the position is not a MethodDefinition and the caller
is responsible to visit other options.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryParseMethodDefinition</span>(<span class="hljs-params">token, key, computed, node</span>) </span>{
        <span class="hljs-keyword">var</span> value, options, methodNode, params,
            previousAllowYield = state.allowYield;

        <span class="hljs-keyword">if</span> (token.type === Token.Identifier) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-86" id="section-86"></a>
</div>
<p>check for <code>get</code> and <code>set</code>;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">if</span> (token.value === <span class="hljs-string">'get'</span> &amp;&amp; lookaheadPropertyName()) {
                computed = match(<span class="hljs-string">'['</span>);
                key = parseObjectPropertyKey();
                methodNode = <span class="hljs-keyword">new</span> Node();
                expect(<span class="hljs-string">'('</span>);
                expect(<span class="hljs-string">')'</span>);

                state.allowYield = <span class="hljs-literal">false</span>;
                value = parsePropertyFunction(methodNode, {
                    <span class="hljs-attr">params</span>: [],
                    <span class="hljs-attr">defaults</span>: [],
                    <span class="hljs-attr">stricted</span>: <span class="hljs-literal">null</span>,
                    <span class="hljs-attr">firstRestricted</span>: <span class="hljs-literal">null</span>,
                    <span class="hljs-attr">message</span>: <span class="hljs-literal">null</span>
                }, <span class="hljs-literal">false</span>);
                state.allowYield = previousAllowYield;

                <span class="hljs-keyword">return</span> node.finishProperty(<span class="hljs-string">'get'</span>, key, computed, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token.value === <span class="hljs-string">'set'</span> &amp;&amp; lookaheadPropertyName()) {
                computed = match(<span class="hljs-string">'['</span>);
                key = parseObjectPropertyKey();
                methodNode = <span class="hljs-keyword">new</span> Node();
                expect(<span class="hljs-string">'('</span>);

                options = {
                    <span class="hljs-attr">params</span>: [],
                    <span class="hljs-attr">defaultCount</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">defaults</span>: [],
                    <span class="hljs-attr">firstRestricted</span>: <span class="hljs-literal">null</span>,
                    <span class="hljs-attr">paramSet</span>: {}
                };
                <span class="hljs-keyword">if</span> (match(<span class="hljs-string">')'</span>)) {
                    tolerateUnexpectedToken(lookahead);
                } <span class="hljs-keyword">else</span> {
                    state.allowYield = <span class="hljs-literal">false</span>;
                    parseParam(options);
                    state.allowYield = previousAllowYield;
                    <span class="hljs-keyword">if</span> (options.defaultCount === <span class="hljs-number">0</span>) {
                        options.defaults = [];
                    }
                }
                expect(<span class="hljs-string">')'</span>);

                state.allowYield = <span class="hljs-literal">false</span>;
                value = parsePropertyFunction(methodNode, options, <span class="hljs-literal">false</span>);
                state.allowYield = previousAllowYield;

                <span class="hljs-keyword">return</span> node.finishProperty(<span class="hljs-string">'set'</span>, key, computed, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token.type === Token.Punctuator &amp;&amp; token.value === <span class="hljs-string">'*'</span> &amp;&amp; lookaheadPropertyName()) {
            computed = match(<span class="hljs-string">'['</span>);
            key = parseObjectPropertyKey();
            methodNode = <span class="hljs-keyword">new</span> Node();

            state.allowYield = <span class="hljs-literal">true</span>;
            params = parseParams();
            state.allowYield = previousAllowYield;

            state.allowYield = <span class="hljs-literal">false</span>;
            value = parsePropertyFunction(methodNode, params, <span class="hljs-literal">true</span>);
            state.allowYield = previousAllowYield;

            <span class="hljs-keyword">return</span> node.finishProperty(<span class="hljs-string">'init'</span>, key, computed, value, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);
        }

        <span class="hljs-keyword">if</span> (key &amp;&amp; match(<span class="hljs-string">'('</span>)) {
            value = parsePropertyMethodFunction();
            <span class="hljs-keyword">return</span> node.finishProperty(<span class="hljs-string">'init'</span>, key, computed, value, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-87" id="section-87"></a>
</div>
<p>Not a MethodDefinition.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseObjectProperty</span>(<span class="hljs-params">hasProto</span>) </span>{
        <span class="hljs-keyword">var</span> token = lookahead, node = <span class="hljs-keyword">new</span> Node(), computed, key, maybeMethod, proto, value;

        computed = match(<span class="hljs-string">'['</span>);
        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'*'</span>)) {
            lex();
        } <span class="hljs-keyword">else</span> {
            key = parseObjectPropertyKey();
        }
        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
        <span class="hljs-keyword">if</span> (maybeMethod) {
            <span class="hljs-keyword">return</span> maybeMethod;
        }

        <span class="hljs-keyword">if</span> (!key) {
            throwUnexpectedToken(lookahead);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-88" id="section-88"></a>
</div>
<p>Check for duplicated <strong>proto</strong></p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!computed) {
            proto = (key.type === Syntax.Identifier &amp;&amp; key.name === <span class="hljs-string">'__proto__'</span>) ||
                (key.type === Syntax.Literal &amp;&amp; key.value === <span class="hljs-string">'__proto__'</span>);
            <span class="hljs-keyword">if</span> (hasProto.value &amp;&amp; proto) {
                tolerateError(Messages.DuplicateProtoProperty);
            }
            hasProto.value |= proto;
        }

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">':'</span>)) {
            lex();
            value = inheritCoverGrammar(parseAssignmentExpression);
            <span class="hljs-keyword">return</span> node.finishProperty(<span class="hljs-string">'init'</span>, key, computed, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
        }

        <span class="hljs-keyword">if</span> (token.type === Token.Identifier) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'='</span>)) {
                firstCoverInitializedNameError = lookahead;
                lex();
                value = isolateCoverGrammar(parseAssignmentExpression);
                <span class="hljs-keyword">return</span> node.finishProperty(<span class="hljs-string">'init'</span>, key, computed,
                    <span class="hljs-keyword">new</span> WrappingNode(token).finishAssignmentPattern(key, value), <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
            }
            <span class="hljs-keyword">return</span> node.finishProperty(<span class="hljs-string">'init'</span>, key, computed, key, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
        }

        throwUnexpectedToken(lookahead);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseObjectInitializer</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> properties = [], hasProto = {<span class="hljs-attr">value</span>: <span class="hljs-literal">false</span>}, node = <span class="hljs-keyword">new</span> Node();

        expect(<span class="hljs-string">'{'</span>);

        <span class="hljs-keyword">while</span> (!match(<span class="hljs-string">'}'</span>)) {
            properties.push(parseObjectProperty(hasProto));

            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'}'</span>)) {
                expectCommaSeparator();
            }
        }

        expect(<span class="hljs-string">'}'</span>);

        <span class="hljs-keyword">return</span> node.finishObjectExpression(properties);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reinterpretExpressionAsPattern</span>(<span class="hljs-params">expr</span>) </span>{
        <span class="hljs-keyword">var</span> i;
        <span class="hljs-keyword">switch</span> (expr.type) {
        <span class="hljs-keyword">case</span> Syntax.Identifier:
        <span class="hljs-keyword">case</span> Syntax.MemberExpression:
        <span class="hljs-keyword">case</span> Syntax.RestElement:
        <span class="hljs-keyword">case</span> Syntax.AssignmentPattern:
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> Syntax.SpreadElement:
            expr.type = Syntax.RestElement;
            reinterpretExpressionAsPattern(expr.argument);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> Syntax.ArrayExpression:
            expr.type = Syntax.ArrayPattern;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; expr.elements.length; i++) {
                <span class="hljs-keyword">if</span> (expr.elements[i] !== <span class="hljs-literal">null</span>) {
                    reinterpretExpressionAsPattern(expr.elements[i]);
                }
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> Syntax.ObjectExpression:
            expr.type = Syntax.ObjectPattern;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; expr.properties.length; i++) {
                reinterpretExpressionAsPattern(expr.properties[i].value);
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> Syntax.AssignmentExpression:
            expr.type = Syntax.AssignmentPattern;
            reinterpretExpressionAsPattern(expr.left);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-89" id="section-89"></a>
</div>
<p>Allow other node type for tolerant parsing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">break</span>;
        }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-90" id="section-90"></a>
</div>
<p>ECMA-262 12.2.9 Template Literals</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseTemplateElement</span>(<span class="hljs-params">option</span>) </span>{
        <span class="hljs-keyword">var</span> node, token;

        <span class="hljs-keyword">if</span> (lookahead.type !== Token.Template || (option.head &amp;&amp; !lookahead.head)) {
            throwUnexpectedToken();
        }

        node = <span class="hljs-keyword">new</span> Node();
        token = lex();

        <span class="hljs-keyword">return</span> node.finishTemplateElement({ <span class="hljs-attr">raw</span>: token.value.raw, <span class="hljs-attr">cooked</span>: token.value.cooked }, token.tail);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseTemplateLiteral</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> quasi, quasis, expressions, node = <span class="hljs-keyword">new</span> Node();

        quasi = parseTemplateElement({ <span class="hljs-attr">head</span>: <span class="hljs-literal">true</span> });
        quasis = [quasi];
        expressions = [];

        <span class="hljs-keyword">while</span> (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({ <span class="hljs-attr">head</span>: <span class="hljs-literal">false</span> });
            quasis.push(quasi);
        }

        <span class="hljs-keyword">return</span> node.finishTemplateLiteral(quasis, expressions);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-91" id="section-91"></a>
</div>
<p>ECMA-262 12.2.10 The Grouping Operator</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseGroupExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> expr, expressions, startToken, i, params = [];

        expect(<span class="hljs-string">'('</span>);

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">')'</span>)) {
            lex();
            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'=&gt;'</span>)) {
                expect(<span class="hljs-string">'=&gt;'</span>);
            }
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">type</span>: PlaceHolders.ArrowParameterPlaceHolder,
                <span class="hljs-attr">params</span>: [],
                <span class="hljs-attr">rawParams</span>: []
            };
        }

        startToken = lookahead;
        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'...'</span>)) {
            expr = parseRestElement(params);
            expect(<span class="hljs-string">')'</span>);
            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'=&gt;'</span>)) {
                expect(<span class="hljs-string">'=&gt;'</span>);
            }
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">type</span>: PlaceHolders.ArrowParameterPlaceHolder,
                <span class="hljs-attr">params</span>: [expr]
            };
        }

        isBindingElement = <span class="hljs-literal">true</span>;
        expr = inheritCoverGrammar(parseAssignmentExpression);

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">','</span>)) {
            isAssignmentTarget = <span class="hljs-literal">false</span>;
            expressions = [expr];

            <span class="hljs-keyword">while</span> (startIndex &lt; length) {
                <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">','</span>)) {
                    <span class="hljs-keyword">break</span>;
                }
                lex();

                <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'...'</span>)) {
                    <span class="hljs-keyword">if</span> (!isBindingElement) {
                        throwUnexpectedToken(lookahead);
                    }
                    expressions.push(parseRestElement(params));
                    expect(<span class="hljs-string">')'</span>);
                    <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'=&gt;'</span>)) {
                        expect(<span class="hljs-string">'=&gt;'</span>);
                    }
                    isBindingElement = <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; expressions.length; i++) {
                        reinterpretExpressionAsPattern(expressions[i]);
                    }
                    <span class="hljs-keyword">return</span> {
                        <span class="hljs-attr">type</span>: PlaceHolders.ArrowParameterPlaceHolder,
                        <span class="hljs-attr">params</span>: expressions
                    };
                }

                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
            }

            expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishSequenceExpression(expressions);
        }


        expect(<span class="hljs-string">')'</span>);

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'=&gt;'</span>)) {
            <span class="hljs-keyword">if</span> (expr.type === Syntax.Identifier &amp;&amp; expr.name === <span class="hljs-string">'yield'</span>) {
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">type</span>: PlaceHolders.ArrowParameterPlaceHolder,
                    <span class="hljs-attr">params</span>: [expr]
                };
            }

            <span class="hljs-keyword">if</span> (!isBindingElement) {
                throwUnexpectedToken(lookahead);
            }

            <span class="hljs-keyword">if</span> (expr.type === Syntax.SequenceExpression) {
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; expr.expressions.length; i++) {
                    reinterpretExpressionAsPattern(expr.expressions[i]);
                }
            } <span class="hljs-keyword">else</span> {
                reinterpretExpressionAsPattern(expr);
            }

            expr = {
                <span class="hljs-attr">type</span>: PlaceHolders.ArrowParameterPlaceHolder,
                <span class="hljs-attr">params</span>: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
            };
        }
        isBindingElement = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> expr;
    }


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-92" id="section-92"></a>
</div>
<p>ECMA-262 12.2 Primary Expressions</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePrimaryExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> type, token, expr, node;

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'('</span>)) {
            isBindingElement = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">return</span> inheritCoverGrammar(parseGroupExpression);
        }

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'['</span>)) {
            <span class="hljs-keyword">return</span> inheritCoverGrammar(parseArrayInitializer);
        }

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'{'</span>)) {
            <span class="hljs-keyword">return</span> inheritCoverGrammar(parseObjectInitializer);
        }

        type = lookahead.type;
        node = <span class="hljs-keyword">new</span> Node();

        <span class="hljs-keyword">if</span> (type === Token.Identifier) {
            <span class="hljs-keyword">if</span> (state.sourceType === <span class="hljs-string">'module'</span> &amp;&amp; lookahead.value === <span class="hljs-string">'await'</span>) {
                tolerateUnexpectedToken(lookahead);
            }
            expr = node.finishIdentifier(lex().value);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === Token.StringLiteral || type === Token.NumericLiteral) {
            isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (strict &amp;&amp; lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === Token.Keyword) {
            <span class="hljs-keyword">if</span> (!strict &amp;&amp; state.allowYield &amp;&amp; matchKeyword(<span class="hljs-string">'yield'</span>)) {
                <span class="hljs-keyword">return</span> parseNonComputedProperty();
            }
            <span class="hljs-keyword">if</span> (!strict &amp;&amp; matchKeyword(<span class="hljs-string">'let'</span>)) {
                <span class="hljs-keyword">return</span> node.finishIdentifier(lex().value);
            }
            isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'function'</span>)) {
                <span class="hljs-keyword">return</span> parseFunctionExpression();
            }
            <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'this'</span>)) {
                lex();
                <span class="hljs-keyword">return</span> node.finishThisExpression();
            }
            <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'class'</span>)) {
                <span class="hljs-keyword">return</span> parseClassExpression();
            }
            throwUnexpectedToken(lex());
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === Token.BooleanLiteral) {
            isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
            token = lex();
            token.value = (token.value === <span class="hljs-string">'true'</span>);
            expr = node.finishLiteral(token);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === Token.NullLiteral) {
            isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
            token = lex();
            token.value = <span class="hljs-literal">null</span>;
            expr = node.finishLiteral(token);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'/'</span>) || match(<span class="hljs-string">'/='</span>)) {
            isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
            index = startIndex;

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> extra.tokens !== <span class="hljs-string">'undefined'</span>) {
                token = collectRegex();
            } <span class="hljs-keyword">else</span> {
                token = scanRegExp();
            }
            lex();
            expr = node.finishLiteral(token);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === Token.Template) {
            expr = parseTemplateLiteral();
        } <span class="hljs-keyword">else</span> {
            throwUnexpectedToken(lex());
        }

        <span class="hljs-keyword">return</span> expr;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-93" id="section-93"></a>
</div>
<p>ECMA-262 12.3 Left-Hand-Side Expressions</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseArguments</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> args = [], expr;

        expect(<span class="hljs-string">'('</span>);

        <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">')'</span>)) {
            <span class="hljs-keyword">while</span> (startIndex &lt; length) {
                <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'...'</span>)) {
                    expr = <span class="hljs-keyword">new</span> Node();
                    lex();
                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
                } <span class="hljs-keyword">else</span> {
                    expr = isolateCoverGrammar(parseAssignmentExpression);
                }
                args.push(expr);
                <span class="hljs-keyword">if</span> (match(<span class="hljs-string">')'</span>)) {
                    <span class="hljs-keyword">break</span>;
                }
                expectCommaSeparator();
            }
        }

        expect(<span class="hljs-string">')'</span>);

        <span class="hljs-keyword">return</span> args;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseNonComputedProperty</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> token, node = <span class="hljs-keyword">new</span> Node();

        token = lex();

        <span class="hljs-keyword">if</span> (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }

        <span class="hljs-keyword">return</span> node.finishIdentifier(token.value);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseNonComputedMember</span>(<span class="hljs-params"></span>) </span>{
        expect(<span class="hljs-string">'.'</span>);

        <span class="hljs-keyword">return</span> parseNonComputedProperty();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseComputedMember</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> expr;

        expect(<span class="hljs-string">'['</span>);

        expr = isolateCoverGrammar(parseExpression);

        expect(<span class="hljs-string">']'</span>);

        <span class="hljs-keyword">return</span> expr;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-94" id="section-94"></a>
</div>
<p>ECMA-262 12.3.3 The new Operator</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseNewExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> callee, args, node = <span class="hljs-keyword">new</span> Node();

        expectKeyword(<span class="hljs-string">'new'</span>);

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'.'</span>)) {
            lex();
            <span class="hljs-keyword">if</span> (lookahead.type === Token.Identifier &amp;&amp; lookahead.value === <span class="hljs-string">'target'</span>) {
                <span class="hljs-keyword">if</span> (state.inFunctionBody) {
                    lex();
                    <span class="hljs-keyword">return</span> node.finishMetaProperty(<span class="hljs-string">'new'</span>, <span class="hljs-string">'target'</span>);
                }
            }
            throwUnexpectedToken(lookahead);
        }

        callee = isolateCoverGrammar(parseLeftHandSideExpression);
        args = match(<span class="hljs-string">'('</span>) ? parseArguments() : [];

        isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">return</span> node.finishNewExpression(callee, args);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-95" id="section-95"></a>
</div>
<p>ECMA-262 12.3.4 Function Calls</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseLeftHandSideExpressionAllowCall</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'super'</span>) &amp;&amp; state.inFunctionBody) {
            expr = <span class="hljs-keyword">new</span> Node();
            lex();
            expr = expr.finishSuper();
            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'('</span>) &amp;&amp; !match(<span class="hljs-string">'.'</span>) &amp;&amp; !match(<span class="hljs-string">'['</span>)) {
                throwUnexpectedToken(lookahead);
            }
        } <span class="hljs-keyword">else</span> {
            expr = inheritCoverGrammar(matchKeyword(<span class="hljs-string">'new'</span>) ? parseNewExpression : parsePrimaryExpression);
        }

        <span class="hljs-keyword">for</span> (;;) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'.'</span>)) {
                isBindingElement = <span class="hljs-literal">false</span>;
                isAssignmentTarget = <span class="hljs-literal">true</span>;
                property = parseNonComputedMember();
                expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishMemberExpression(<span class="hljs-string">'.'</span>, expr, property);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'('</span>)) {
                isBindingElement = <span class="hljs-literal">false</span>;
                isAssignmentTarget = <span class="hljs-literal">false</span>;
                args = parseArguments();
                expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishCallExpression(expr, args);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'['</span>)) {
                isBindingElement = <span class="hljs-literal">false</span>;
                isAssignmentTarget = <span class="hljs-literal">true</span>;
                property = parseComputedMember();
                expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishMemberExpression(<span class="hljs-string">'['</span>, expr, property);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lookahead.type === Token.Template &amp;&amp; lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">break</span>;
            }
        }
        state.allowIn = previousAllowIn;

        <span class="hljs-keyword">return</span> expr;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-96" id="section-96"></a>
</div>
<p>ECMA-262 12.3 Left-Hand-Side Expressions</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseLeftHandSideExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> quasi, expr, property, startToken;
        assert(state.allowIn, <span class="hljs-string">'callee of new expression always allow in keyword.'</span>);

        startToken = lookahead;

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'super'</span>) &amp;&amp; state.inFunctionBody) {
            expr = <span class="hljs-keyword">new</span> Node();
            lex();
            expr = expr.finishSuper();
            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'['</span>) &amp;&amp; !match(<span class="hljs-string">'.'</span>)) {
                throwUnexpectedToken(lookahead);
            }
        } <span class="hljs-keyword">else</span> {
            expr = inheritCoverGrammar(matchKeyword(<span class="hljs-string">'new'</span>) ? parseNewExpression : parsePrimaryExpression);
        }

        <span class="hljs-keyword">for</span> (;;) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'['</span>)) {
                isBindingElement = <span class="hljs-literal">false</span>;
                isAssignmentTarget = <span class="hljs-literal">true</span>;
                property = parseComputedMember();
                expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishMemberExpression(<span class="hljs-string">'['</span>, expr, property);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'.'</span>)) {
                isBindingElement = <span class="hljs-literal">false</span>;
                isAssignmentTarget = <span class="hljs-literal">true</span>;
                property = parseNonComputedMember();
                expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishMemberExpression(<span class="hljs-string">'.'</span>, expr, property);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lookahead.type === Token.Template &amp;&amp; lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> expr;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-97" id="section-97"></a>
</div>
<p>ECMA-262 12.4 Postfix Expressions</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePostfixExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> expr, token, startToken = lookahead;

        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

        <span class="hljs-keyword">if</span> (!hasLineTerminator &amp;&amp; lookahead.type === Token.Punctuator) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'++'</span>) || match(<span class="hljs-string">'--'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-98" id="section-98"></a>
</div>
<p>ECMA-262 11.3.1, 11.3.2</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">if</span> (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }

                <span class="hljs-keyword">if</span> (!isAssignmentTarget) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }

                isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;

                token = lex();
                expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        <span class="hljs-keyword">return</span> expr;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-99" id="section-99"></a>
</div>
<p>ECMA-262 12.5 Unary Operators</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseUnaryExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> token, expr, startToken;

        <span class="hljs-keyword">if</span> (lookahead.type !== Token.Punctuator &amp;&amp; lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'++'</span>) || match(<span class="hljs-string">'--'</span>)) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-100" id="section-100"></a>
</div>
<p>ECMA-262 11.4.4, 11.4.5</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }

            <span class="hljs-keyword">if</span> (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }
            expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'+'</span>) || match(<span class="hljs-string">'-'</span>) || match(<span class="hljs-string">'~'</span>) || match(<span class="hljs-string">'!'</span>)) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'delete'</span>) || matchKeyword(<span class="hljs-string">'void'</span>) || matchKeyword(<span class="hljs-string">'typeof'</span>)) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            <span class="hljs-keyword">if</span> (strict &amp;&amp; expr.operator === <span class="hljs-string">'delete'</span> &amp;&amp; expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
            isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">else</span> {
            expr = parsePostfixExpression();
        }

        <span class="hljs-keyword">return</span> expr;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryPrecedence</span>(<span class="hljs-params">token, allowIn</span>) </span>{
        <span class="hljs-keyword">var</span> prec = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (token.type !== Token.Punctuator &amp;&amp; token.type !== Token.Keyword) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">switch</span> (token.value) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'||'</span>:
            prec = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'&amp;&amp;'</span>:
            prec = <span class="hljs-number">2</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'|'</span>:
            prec = <span class="hljs-number">3</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:
            prec = <span class="hljs-number">4</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'&amp;'</span>:
            prec = <span class="hljs-number">5</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'=='</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'!='</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'==='</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'!=='</span>:
            prec = <span class="hljs-number">6</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;='</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;='</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'instanceof'</span>:
            prec = <span class="hljs-number">7</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'in'</span>:
            prec = allowIn ? <span class="hljs-number">7</span> : <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;&lt;'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;&gt;'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;&gt;&gt;'</span>:
            prec = <span class="hljs-number">8</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
            prec = <span class="hljs-number">9</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:
            prec = <span class="hljs-number">11</span>;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">return</span> prec;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-101" id="section-101"></a>
</div>
<p>ECMA-262 12.6 Multiplicative Operators
ECMA-262 12.7 Additive Operators
ECMA-262 12.8 Bitwise Shift Operators
ECMA-262 12.9 Relational Operators
ECMA-262 12.10 Equality Operators
ECMA-262 12.11 Binary Bitwise Operators
ECMA-262 12.12 Binary Logical Operators</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseBinaryExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = inheritCoverGrammar(parseUnaryExpression);

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        <span class="hljs-keyword">if</span> (prec === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> left;
        }
        isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = isolateCoverGrammar(parseUnaryExpression);

        stack = [left, token, right];

        <span class="hljs-keyword">while</span> ((prec = binaryPrecedence(lookahead, state.allowIn)) &gt; <span class="hljs-number">0</span>) {

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-102" id="section-102"></a>
</div>
<p>Reduce: make a binary expression from the three topmost entries.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">while</span> ((stack.length &gt; <span class="hljs-number">2</span>) &amp;&amp; (prec &lt;= stack[stack.length - <span class="hljs-number">2</span>].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = <span class="hljs-keyword">new</span> WrappingNode(markers[markers.length - <span class="hljs-number">1</span>]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-103" id="section-103"></a>
</div>
<p>Shift.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = isolateCoverGrammar(parseUnaryExpression);
            stack.push(expr);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-104" id="section-104"></a>
</div>
<p>Final reduce to clean-up the stack.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        i = stack.length - <span class="hljs-number">1</span>;
        expr = stack[i];
        markers.pop();
        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">1</span>) {
            expr = <span class="hljs-keyword">new</span> WrappingNode(markers.pop()).finishBinaryExpression(stack[i - <span class="hljs-number">1</span>].value, stack[i - <span class="hljs-number">2</span>], expr);
            i -= <span class="hljs-number">2</span>;
        }

        <span class="hljs-keyword">return</span> expr;
    }


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-105" id="section-105"></a>
</div>
<p>ECMA-262 12.13 Conditional Operator</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseConditionalExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = inheritCoverGrammar(parseBinaryExpression);
        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'?'</span>)) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = <span class="hljs-literal">true</span>;
            consequent = isolateCoverGrammar(parseAssignmentExpression);
            state.allowIn = previousAllowIn;
            expect(<span class="hljs-string">':'</span>);
            alternate = isolateCoverGrammar(parseAssignmentExpression);

            expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
            isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">return</span> expr;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-106" id="section-106"></a>
</div>
<p>ECMA-262 14.2 Arrow Function Definitions</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseConciseBody</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'{'</span>)) {
            <span class="hljs-keyword">return</span> parseFunctionSourceElements();
        }
        <span class="hljs-keyword">return</span> isolateCoverGrammar(parseAssignmentExpression);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkPatternParam</span>(<span class="hljs-params">options, param</span>) </span>{
        <span class="hljs-keyword">var</span> i;
        <span class="hljs-keyword">switch</span> (param.type) {
        <span class="hljs-keyword">case</span> Syntax.Identifier:
            validateParam(options, param, param.name);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> Syntax.RestElement:
            checkPatternParam(options, param.argument);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> Syntax.AssignmentPattern:
            checkPatternParam(options, param.left);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> Syntax.ArrayPattern:
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; param.elements.length; i++) {
                <span class="hljs-keyword">if</span> (param.elements[i] !== <span class="hljs-literal">null</span>) {
                    checkPatternParam(options, param.elements[i]);
                }
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> Syntax.YieldExpression:
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            assert(param.type === Syntax.ObjectPattern, <span class="hljs-string">'Invalid type'</span>);
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; param.properties.length; i++) {
                checkPatternParam(options, param.properties[i].value);
            }
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reinterpretAsCoverFormalsList</span>(<span class="hljs-params">expr</span>) </span>{
        <span class="hljs-keyword">var</span> i, len, param, params, defaults, defaultCount, options, token;

        defaults = [];
        defaultCount = <span class="hljs-number">0</span>;
        params = [expr];

        <span class="hljs-keyword">switch</span> (expr.type) {
        <span class="hljs-keyword">case</span> Syntax.Identifier:
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> PlaceHolders.ArrowParameterPlaceHolder:
            params = expr.params;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        options = {
            <span class="hljs-attr">paramSet</span>: {}
        };

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = params.length; i &lt; len; i += <span class="hljs-number">1</span>) {
            param = params[i];
            <span class="hljs-keyword">switch</span> (param.type) {
            <span class="hljs-keyword">case</span> Syntax.AssignmentPattern:
                params[i] = param.left;
                <span class="hljs-keyword">if</span> (param.right.type === Syntax.YieldExpression) {
                    <span class="hljs-keyword">if</span> (param.right.argument) {
                        throwUnexpectedToken(lookahead);
                    }
                    param.right.type = Syntax.Identifier;
                    param.right.name = <span class="hljs-string">'yield'</span>;
                    <span class="hljs-keyword">delete</span> param.right.argument;
                    <span class="hljs-keyword">delete</span> param.right.delegate;
                }
                defaults.push(param.right);
                ++defaultCount;
                checkPatternParam(options, param.left);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                checkPatternParam(options, param);
                params[i] = param;
                defaults.push(<span class="hljs-literal">null</span>);
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-keyword">if</span> (strict || !state.allowYield) {
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = params.length; i &lt; len; i += <span class="hljs-number">1</span>) {
                param = params[i];
                <span class="hljs-keyword">if</span> (param.type === Syntax.YieldExpression) {
                    throwUnexpectedToken(lookahead);
                }
            }
        }

        <span class="hljs-keyword">if</span> (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }

        <span class="hljs-keyword">if</span> (defaultCount === <span class="hljs-number">0</span>) {
            defaults = [];
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">params</span>: params,
            <span class="hljs-attr">defaults</span>: defaults,
            <span class="hljs-attr">stricted</span>: options.stricted,
            <span class="hljs-attr">firstRestricted</span>: options.firstRestricted,
            <span class="hljs-attr">message</span>: options.message
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseArrowFunctionExpression</span>(<span class="hljs-params">options, node</span>) </span>{
        <span class="hljs-keyword">var</span> previousStrict, previousAllowYield, body;

        <span class="hljs-keyword">if</span> (hasLineTerminator) {
            tolerateUnexpectedToken(lookahead);
        }
        expect(<span class="hljs-string">'=&gt;'</span>);

        previousStrict = strict;
        previousAllowYield = state.allowYield;
        state.allowYield = <span class="hljs-literal">true</span>;

        body = parseConciseBody();

        <span class="hljs-keyword">if</span> (strict &amp;&amp; options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        <span class="hljs-keyword">if</span> (strict &amp;&amp; options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        <span class="hljs-keyword">return</span> node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-107" id="section-107"></a>
</div>
<p>ECMA-262 14.4 Yield expression</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseYieldExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> argument, expr, delegate, previousAllowYield;

        argument = <span class="hljs-literal">null</span>;
        expr = <span class="hljs-keyword">new</span> Node();
        delegate = <span class="hljs-literal">false</span>;

        expectKeyword(<span class="hljs-string">'yield'</span>);

        <span class="hljs-keyword">if</span> (!hasLineTerminator) {
            previousAllowYield = state.allowYield;
            state.allowYield = <span class="hljs-literal">false</span>;
            delegate = match(<span class="hljs-string">'*'</span>);
            <span class="hljs-keyword">if</span> (delegate) {
                lex();
                argument = parseAssignmentExpression();
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">';'</span>) &amp;&amp; !match(<span class="hljs-string">'}'</span>) &amp;&amp; !match(<span class="hljs-string">')'</span>) &amp;&amp; lookahead.type !== Token.EOF) {
                    argument = parseAssignmentExpression();
                }
            }
            state.allowYield = previousAllowYield;
        }

        <span class="hljs-keyword">return</span> expr.finishYieldExpression(argument, delegate);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-108" id="section-108"></a>
</div>
<p>ECMA-262 12.14 Assignment Operators</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseAssignmentExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> token, expr, right, list, startToken;

        startToken = lookahead;
        token = lookahead;

        <span class="hljs-keyword">if</span> (!state.allowYield &amp;&amp; matchKeyword(<span class="hljs-string">'yield'</span>)) {
            <span class="hljs-keyword">return</span> parseYieldExpression();
        }

        expr = parseConditionalExpression();

        <span class="hljs-keyword">if</span> (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match(<span class="hljs-string">'=&gt;'</span>)) {
            isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
            list = reinterpretAsCoverFormalsList(expr);

            <span class="hljs-keyword">if</span> (list) {
                firstCoverInitializedNameError = <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">return</span> parseArrowFunctionExpression(list, <span class="hljs-keyword">new</span> WrappingNode(startToken));
            }

            <span class="hljs-keyword">return</span> expr;
        }

        <span class="hljs-keyword">if</span> (matchAssign()) {
            <span class="hljs-keyword">if</span> (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-109" id="section-109"></a>
</div>
<p>ECMA-262 12.1.1</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (strict &amp;&amp; expr.type === Syntax.Identifier) {
                <span class="hljs-keyword">if</span> (isRestrictedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
                }
                <span class="hljs-keyword">if</span> (isStrictModeReservedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
                }
            }

            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'='</span>)) {
                isAssignmentTarget = isBindingElement = <span class="hljs-literal">false</span>;
            } <span class="hljs-keyword">else</span> {
                reinterpretExpressionAsPattern(expr);
            }

            token = lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
            firstCoverInitializedNameError = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> expr;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-110" id="section-110"></a>
</div>
<p>ECMA-262 12.15 Comma Operator</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> expr, startToken = lookahead, expressions;

        expr = isolateCoverGrammar(parseAssignmentExpression);

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">','</span>)) {
            expressions = [expr];

            <span class="hljs-keyword">while</span> (startIndex &lt; length) {
                <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">','</span>)) {
                    <span class="hljs-keyword">break</span>;
                }
                lex();
                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
            }

            expr = <span class="hljs-keyword">new</span> WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        <span class="hljs-keyword">return</span> expr;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-111" id="section-111"></a>
</div>
<p>ECMA-262 13.2 Block</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseStatementListItem</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (lookahead.type === Token.Keyword) {
            <span class="hljs-keyword">switch</span> (lookahead.value) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">'export'</span>:
                <span class="hljs-keyword">if</span> (state.sourceType !== <span class="hljs-string">'module'</span>) {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                }
                <span class="hljs-keyword">return</span> parseExportDeclaration();
            <span class="hljs-keyword">case</span> <span class="hljs-string">'import'</span>:
                <span class="hljs-keyword">if</span> (state.sourceType !== <span class="hljs-string">'module'</span>) {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                }
                <span class="hljs-keyword">return</span> parseImportDeclaration();
            <span class="hljs-keyword">case</span> <span class="hljs-string">'const'</span>:
                <span class="hljs-keyword">return</span> parseLexicalDeclaration({<span class="hljs-attr">inFor</span>: <span class="hljs-literal">false</span>});
            <span class="hljs-keyword">case</span> <span class="hljs-string">'function'</span>:
                <span class="hljs-keyword">return</span> parseFunctionDeclaration(<span class="hljs-keyword">new</span> Node());
            <span class="hljs-keyword">case</span> <span class="hljs-string">'class'</span>:
                <span class="hljs-keyword">return</span> parseClassDeclaration();
            }
        }

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'let'</span>) &amp;&amp; isLexicalDeclaration()) {
            <span class="hljs-keyword">return</span> parseLexicalDeclaration({<span class="hljs-attr">inFor</span>: <span class="hljs-literal">false</span>});
        }

        <span class="hljs-keyword">return</span> parseStatement();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseStatementList</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> list = [];
        <span class="hljs-keyword">while</span> (startIndex &lt; length) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'}'</span>)) {
                <span class="hljs-keyword">break</span>;
            }
            list.push(parseStatementListItem());
        }

        <span class="hljs-keyword">return</span> list;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseBlock</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> block, node = <span class="hljs-keyword">new</span> Node();

        expect(<span class="hljs-string">'{'</span>);

        block = parseStatementList();

        expect(<span class="hljs-string">'}'</span>);

        <span class="hljs-keyword">return</span> node.finishBlockStatement(block);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-112" id="section-112"></a>
</div>
<p>ECMA-262 13.3.2 Variable Statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseVariableIdentifier</span>(<span class="hljs-params">kind</span>) </span>{
        <span class="hljs-keyword">var</span> token, node = <span class="hljs-keyword">new</span> Node();

        token = lex();

        <span class="hljs-keyword">if</span> (token.type === Token.Keyword &amp;&amp; token.value === <span class="hljs-string">'yield'</span>) {
            <span class="hljs-keyword">if</span> (strict) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } <span class="hljs-keyword">if</span> (!state.allowYield) {
                throwUnexpectedToken(token);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token.type !== Token.Identifier) {
            <span class="hljs-keyword">if</span> (strict &amp;&amp; token.type === Token.Keyword &amp;&amp; isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (strict || token.value !== <span class="hljs-string">'let'</span> || kind !== <span class="hljs-string">'var'</span>) {
                    throwUnexpectedToken(token);
                }
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.sourceType === <span class="hljs-string">'module'</span> &amp;&amp; token.type === Token.Identifier &amp;&amp; token.value === <span class="hljs-string">'await'</span>) {
            tolerateUnexpectedToken(token);
        }

        <span class="hljs-keyword">return</span> node.finishIdentifier(token.value);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseVariableDeclaration</span>(<span class="hljs-params">options</span>) </span>{
        <span class="hljs-keyword">var</span> init = <span class="hljs-literal">null</span>, id, node = <span class="hljs-keyword">new</span> Node(), params = [];

        id = parsePattern(params, <span class="hljs-string">'var'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-113" id="section-113"></a>
</div>
<p>ECMA-262 12.2.1</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (strict &amp;&amp; isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'='</span>)) {
            lex();
            init = isolateCoverGrammar(parseAssignmentExpression);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id.type !== Syntax.Identifier &amp;&amp; !options.inFor) {
            expect(<span class="hljs-string">'='</span>);
        }

        <span class="hljs-keyword">return</span> node.finishVariableDeclarator(id, init);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseVariableDeclarationList</span>(<span class="hljs-params">options</span>) </span>{
        <span class="hljs-keyword">var</span> opt, list;

        opt = { <span class="hljs-attr">inFor</span>: options.inFor };
        list = [parseVariableDeclaration(opt)];

        <span class="hljs-keyword">while</span> (match(<span class="hljs-string">','</span>)) {
            lex();
            list.push(parseVariableDeclaration(opt));
        }

        <span class="hljs-keyword">return</span> list;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseVariableStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> declarations;

        expectKeyword(<span class="hljs-string">'var'</span>);

        declarations = parseVariableDeclarationList({ <span class="hljs-attr">inFor</span>: <span class="hljs-literal">false</span> });

        consumeSemicolon();

        <span class="hljs-keyword">return</span> node.finishVariableDeclaration(declarations);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-114" id="section-114"></a>
</div>
<p>ECMA-262 13.3.1 Let and Const Declarations</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseLexicalBinding</span>(<span class="hljs-params">kind, options</span>) </span>{
        <span class="hljs-keyword">var</span> init = <span class="hljs-literal">null</span>, id, node = <span class="hljs-keyword">new</span> Node(), params = [];

        id = parsePattern(params, kind);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-115" id="section-115"></a>
</div>
<p>ECMA-262 12.2.1</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (strict &amp;&amp; id.type === Syntax.Identifier &amp;&amp; isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'const'</span>) {
            <span class="hljs-keyword">if</span> (!matchKeyword(<span class="hljs-string">'in'</span>) &amp;&amp; !matchContextualKeyword(<span class="hljs-string">'of'</span>)) {
                expect(<span class="hljs-string">'='</span>);
                init = isolateCoverGrammar(parseAssignmentExpression);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((!options.inFor &amp;&amp; id.type !== Syntax.Identifier) || match(<span class="hljs-string">'='</span>)) {
            expect(<span class="hljs-string">'='</span>);
            init = isolateCoverGrammar(parseAssignmentExpression);
        }

        <span class="hljs-keyword">return</span> node.finishVariableDeclarator(id, init);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseBindingList</span>(<span class="hljs-params">kind, options</span>) </span>{
        <span class="hljs-keyword">var</span> list = [parseLexicalBinding(kind, options)];

        <span class="hljs-keyword">while</span> (match(<span class="hljs-string">','</span>)) {
            lex();
            list.push(parseLexicalBinding(kind, options));
        }

        <span class="hljs-keyword">return</span> list;
    }


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokenizerState</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">index</span>: index,
            <span class="hljs-attr">lineNumber</span>: lineNumber,
            <span class="hljs-attr">lineStart</span>: lineStart,
            <span class="hljs-attr">hasLineTerminator</span>: hasLineTerminator,
            <span class="hljs-attr">lastIndex</span>: lastIndex,
            <span class="hljs-attr">lastLineNumber</span>: lastLineNumber,
            <span class="hljs-attr">lastLineStart</span>: lastLineStart,
            <span class="hljs-attr">startIndex</span>: startIndex,
            <span class="hljs-attr">startLineNumber</span>: startLineNumber,
            <span class="hljs-attr">startLineStart</span>: startLineStart,
            <span class="hljs-attr">lookahead</span>: lookahead,
            <span class="hljs-attr">tokenCount</span>: extra.tokens ? extra.tokens.length : <span class="hljs-number">0</span>
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetTokenizerState</span>(<span class="hljs-params">ts</span>) </span>{
        index = ts.index;
        lineNumber = ts.lineNumber;
        lineStart = ts.lineStart;
        hasLineTerminator = ts.hasLineTerminator;
        lastIndex = ts.lastIndex;
        lastLineNumber = ts.lastLineNumber;
        lastLineStart = ts.lastLineStart;
        startIndex = ts.startIndex;
        startLineNumber = ts.startLineNumber;
        startLineStart = ts.startLineStart;
        lookahead = ts.lookahead;
        <span class="hljs-keyword">if</span> (extra.tokens) {
            extra.tokens.splice(ts.tokenCount, extra.tokens.length);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLexicalDeclaration</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> lexical, ts;

        ts = tokenizerState();

        lex();
        lexical = (lookahead.type === Token.Identifier) || match(<span class="hljs-string">'['</span>) || match(<span class="hljs-string">'{'</span>) ||
            matchKeyword(<span class="hljs-string">'let'</span>) || matchKeyword(<span class="hljs-string">'yield'</span>);

        resetTokenizerState(ts);

        <span class="hljs-keyword">return</span> lexical;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseLexicalDeclaration</span>(<span class="hljs-params">options</span>) </span>{
        <span class="hljs-keyword">var</span> kind, declarations, node = <span class="hljs-keyword">new</span> Node();

        kind = lex().value;
        assert(kind === <span class="hljs-string">'let'</span> || kind === <span class="hljs-string">'const'</span>, <span class="hljs-string">'Lexical declaration must be either let or const'</span>);

        declarations = parseBindingList(kind, options);

        consumeSemicolon();

        <span class="hljs-keyword">return</span> node.finishLexicalDeclaration(declarations, kind);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseRestElement</span>(<span class="hljs-params">params</span>) </span>{
        <span class="hljs-keyword">var</span> param, node = <span class="hljs-keyword">new</span> Node();

        lex();

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'{'</span>)) {
            throwError(Messages.ObjectPatternAsRestParameter);
        }

        params.push(lookahead);

        param = parseVariableIdentifier();

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'='</span>)) {
            throwError(Messages.DefaultRestParameter);
        }

        <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">')'</span>)) {
            throwError(Messages.ParameterAfterRestParameter);
        }

        <span class="hljs-keyword">return</span> node.finishRestElement(param);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-116" id="section-116"></a>
</div>
<p>ECMA-262 13.4 Empty Statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseEmptyStatement</span>(<span class="hljs-params">node</span>) </span>{
        expect(<span class="hljs-string">';'</span>);
        <span class="hljs-keyword">return</span> node.finishEmptyStatement();
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-117" id="section-117"></a>
</div>
<p>ECMA-262 12.4 Expression Statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseExpressionStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> expr = parseExpression();
        consumeSemicolon();
        <span class="hljs-keyword">return</span> node.finishExpressionStatement(expr);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-118" id="section-118"></a>
</div>
<p>ECMA-262 13.6 If statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseIfStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> test, consequent, alternate;

        expectKeyword(<span class="hljs-string">'if'</span>);

        expect(<span class="hljs-string">'('</span>);

        test = parseExpression();

        expect(<span class="hljs-string">')'</span>);

        consequent = parseStatement();

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'else'</span>)) {
            lex();
            alternate = parseStatement();
        } <span class="hljs-keyword">else</span> {
            alternate = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> node.finishIfStatement(test, consequent, alternate);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-119" id="section-119"></a>
</div>
<p>ECMA-262 13.7 Iteration Statements</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseDoWhileStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> body, test, oldInIteration;

        expectKeyword(<span class="hljs-string">'do'</span>);

        oldInIteration = state.inIteration;
        state.inIteration = <span class="hljs-literal">true</span>;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword(<span class="hljs-string">'while'</span>);

        expect(<span class="hljs-string">'('</span>);

        test = parseExpression();

        expect(<span class="hljs-string">')'</span>);

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">';'</span>)) {
            lex();
        }

        <span class="hljs-keyword">return</span> node.finishDoWhileStatement(body, test);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseWhileStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> test, body, oldInIteration;

        expectKeyword(<span class="hljs-string">'while'</span>);

        expect(<span class="hljs-string">'('</span>);

        test = parseExpression();

        expect(<span class="hljs-string">')'</span>);

        oldInIteration = state.inIteration;
        state.inIteration = <span class="hljs-literal">true</span>;

        body = parseStatement();

        state.inIteration = oldInIteration;

        <span class="hljs-keyword">return</span> node.finishWhileStatement(test, body);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseForStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
            body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = <span class="hljs-literal">null</span>;
        forIn = <span class="hljs-literal">true</span>;

        expectKeyword(<span class="hljs-string">'for'</span>);

        expect(<span class="hljs-string">'('</span>);

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">';'</span>)) {
            lex();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'var'</span>)) {
                init = <span class="hljs-keyword">new</span> Node();
                lex();

                state.allowIn = <span class="hljs-literal">false</span>;
                declarations = parseVariableDeclarationList({ <span class="hljs-attr">inFor</span>: <span class="hljs-literal">true</span> });
                state.allowIn = previousAllowIn;

                <span class="hljs-keyword">if</span> (declarations.length === <span class="hljs-number">1</span> &amp;&amp; matchKeyword(<span class="hljs-string">'in'</span>)) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = <span class="hljs-literal">null</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (declarations.length === <span class="hljs-number">1</span> &amp;&amp; declarations[<span class="hljs-number">0</span>].init === <span class="hljs-literal">null</span> &amp;&amp; matchContextualKeyword(<span class="hljs-string">'of'</span>)) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseAssignmentExpression();
                    init = <span class="hljs-literal">null</span>;
                    forIn = <span class="hljs-literal">false</span>;
                } <span class="hljs-keyword">else</span> {
                    init = init.finishVariableDeclaration(declarations);
                    expect(<span class="hljs-string">';'</span>);
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'const'</span>) || matchKeyword(<span class="hljs-string">'let'</span>)) {
                init = <span class="hljs-keyword">new</span> Node();
                kind = lex().value;

                <span class="hljs-keyword">if</span> (!strict &amp;&amp; lookahead.value === <span class="hljs-string">'in'</span>) {
                    init = init.finishIdentifier(kind);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = <span class="hljs-literal">null</span>;
                } <span class="hljs-keyword">else</span> {
                    state.allowIn = <span class="hljs-literal">false</span>;
                    declarations = parseBindingList(kind, {<span class="hljs-attr">inFor</span>: <span class="hljs-literal">true</span>});
                    state.allowIn = previousAllowIn;

                    <span class="hljs-keyword">if</span> (declarations.length === <span class="hljs-number">1</span> &amp;&amp; declarations[<span class="hljs-number">0</span>].init === <span class="hljs-literal">null</span> &amp;&amp; matchKeyword(<span class="hljs-string">'in'</span>)) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseExpression();
                        init = <span class="hljs-literal">null</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (declarations.length === <span class="hljs-number">1</span> &amp;&amp; declarations[<span class="hljs-number">0</span>].init === <span class="hljs-literal">null</span> &amp;&amp; matchContextualKeyword(<span class="hljs-string">'of'</span>)) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseAssignmentExpression();
                        init = <span class="hljs-literal">null</span>;
                        forIn = <span class="hljs-literal">false</span>;
                    } <span class="hljs-keyword">else</span> {
                        consumeSemicolon();
                        init = init.finishLexicalDeclaration(declarations, kind);
                    }
                }
            } <span class="hljs-keyword">else</span> {
                initStartToken = lookahead;
                state.allowIn = <span class="hljs-literal">false</span>;
                init = inheritCoverGrammar(parseAssignmentExpression);
                state.allowIn = previousAllowIn;

                <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'in'</span>)) {
                    <span class="hljs-keyword">if</span> (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseExpression();
                    init = <span class="hljs-literal">null</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchContextualKeyword(<span class="hljs-string">'of'</span>)) {
                    <span class="hljs-keyword">if</span> (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForLoop);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseAssignmentExpression();
                    init = <span class="hljs-literal">null</span>;
                    forIn = <span class="hljs-literal">false</span>;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (match(<span class="hljs-string">','</span>)) {
                        initSeq = [init];
                        <span class="hljs-keyword">while</span> (match(<span class="hljs-string">','</span>)) {
                            lex();
                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
                        }
                        init = <span class="hljs-keyword">new</span> WrappingNode(initStartToken).finishSequenceExpression(initSeq);
                    }
                    expect(<span class="hljs-string">';'</span>);
                }
            }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> left === <span class="hljs-string">'undefined'</span>) {

            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">';'</span>)) {
                test = parseExpression();
            }
            expect(<span class="hljs-string">';'</span>);

            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">')'</span>)) {
                update = parseExpression();
            }
        }

        expect(<span class="hljs-string">')'</span>);

        oldInIteration = state.inIteration;
        state.inIteration = <span class="hljs-literal">true</span>;

        body = isolateCoverGrammar(parseStatement);

        state.inIteration = oldInIteration;

        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> left === <span class="hljs-string">'undefined'</span>) ?
                node.finishForStatement(init, test, update, body) :
                forIn ? node.finishForInStatement(left, right, body) :
                    node.finishForOfStatement(left, right, body);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-120" id="section-120"></a>
</div>
<p>ECMA-262 13.8 The continue statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseContinueStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> label = <span class="hljs-literal">null</span>, key;

        expectKeyword(<span class="hljs-string">'continue'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-121" id="section-121"></a>
</div>
<p>Optimize the most common form: 'continue;'.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (source.charCodeAt(startIndex) === <span class="hljs-number">0x3B</span>) {
            lex();

            <span class="hljs-keyword">if</span> (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            <span class="hljs-keyword">return</span> node.finishContinueStatement(<span class="hljs-literal">null</span>);
        }

        <span class="hljs-keyword">if</span> (hasLineTerminator) {
            <span class="hljs-keyword">if</span> (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            <span class="hljs-keyword">return</span> node.finishContinueStatement(<span class="hljs-literal">null</span>);
        }

        <span class="hljs-keyword">if</span> (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = <span class="hljs-string">'$'</span> + label.name;
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        <span class="hljs-keyword">if</span> (label === <span class="hljs-literal">null</span> &amp;&amp; !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }

        <span class="hljs-keyword">return</span> node.finishContinueStatement(label);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-122" id="section-122"></a>
</div>
<p>ECMA-262 13.9 The break statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseBreakStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> label = <span class="hljs-literal">null</span>, key;

        expectKeyword(<span class="hljs-string">'break'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-123" id="section-123"></a>
</div>
<p>Catch the very common case first: immediately a semicolon (U+003B).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (source.charCodeAt(lastIndex) === <span class="hljs-number">0x3B</span>) {
            lex();

            <span class="hljs-keyword">if</span> (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            <span class="hljs-keyword">return</span> node.finishBreakStatement(<span class="hljs-literal">null</span>);
        }

        <span class="hljs-keyword">if</span> (hasLineTerminator) {
            <span class="hljs-keyword">if</span> (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = <span class="hljs-string">'$'</span> + label.name;
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        <span class="hljs-keyword">if</span> (label === <span class="hljs-literal">null</span> &amp;&amp; !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }

        <span class="hljs-keyword">return</span> node.finishBreakStatement(label);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-124" id="section-124"></a>
</div>
<p>ECMA-262 13.10 The return statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseReturnStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> argument = <span class="hljs-literal">null</span>;

        expectKeyword(<span class="hljs-string">'return'</span>);

        <span class="hljs-keyword">if</span> (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-125" id="section-125"></a>
</div>
<p>'return' followed by a space and an identifier is very common.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (source.charCodeAt(lastIndex) === <span class="hljs-number">0x20</span>) {
            <span class="hljs-keyword">if</span> (isIdentifierStart(source.charCodeAt(lastIndex + <span class="hljs-number">1</span>))) {
                argument = parseExpression();
                consumeSemicolon();
                <span class="hljs-keyword">return</span> node.finishReturnStatement(argument);
            }
        }

        <span class="hljs-keyword">if</span> (hasLineTerminator) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-126" id="section-126"></a>
</div>
<p>HACK</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> node.finishReturnStatement(<span class="hljs-literal">null</span>);
        }

        <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">';'</span>)) {
            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'}'</span>) &amp;&amp; lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        <span class="hljs-keyword">return</span> node.finishReturnStatement(argument);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-127" id="section-127"></a>
</div>
<p>ECMA-262 13.11 The with statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseWithStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> object, body;

        <span class="hljs-keyword">if</span> (strict) {
            tolerateError(Messages.StrictModeWith);
        }

        expectKeyword(<span class="hljs-string">'with'</span>);

        expect(<span class="hljs-string">'('</span>);

        object = parseExpression();

        expect(<span class="hljs-string">')'</span>);

        body = parseStatement();

        <span class="hljs-keyword">return</span> node.finishWithStatement(object, body);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-128" id="section-128"></a>
</div>
<p>ECMA-262 13.12 The switch statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseSwitchCase</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> test, consequent = [], statement, node = <span class="hljs-keyword">new</span> Node();

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'default'</span>)) {
            lex();
            test = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
            expectKeyword(<span class="hljs-string">'case'</span>);
            test = parseExpression();
        }
        expect(<span class="hljs-string">':'</span>);

        <span class="hljs-keyword">while</span> (startIndex &lt; length) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'}'</span>) || matchKeyword(<span class="hljs-string">'default'</span>) || matchKeyword(<span class="hljs-string">'case'</span>)) {
                <span class="hljs-keyword">break</span>;
            }
            statement = parseStatementListItem();
            consequent.push(statement);
        }

        <span class="hljs-keyword">return</span> node.finishSwitchCase(test, consequent);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseSwitchStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword(<span class="hljs-string">'switch'</span>);

        expect(<span class="hljs-string">'('</span>);

        discriminant = parseExpression();

        expect(<span class="hljs-string">')'</span>);

        expect(<span class="hljs-string">'{'</span>);

        cases = [];

        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'}'</span>)) {
            lex();
            <span class="hljs-keyword">return</span> node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = <span class="hljs-literal">true</span>;
        defaultFound = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">while</span> (startIndex &lt; length) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'}'</span>)) {
                <span class="hljs-keyword">break</span>;
            }
            clause = parseSwitchCase();
            <span class="hljs-keyword">if</span> (clause.test === <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">if</span> (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = <span class="hljs-literal">true</span>;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect(<span class="hljs-string">'}'</span>);

        <span class="hljs-keyword">return</span> node.finishSwitchStatement(discriminant, cases);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-129" id="section-129"></a>
</div>
<p>ECMA-262 13.14 The throw statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseThrowStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> argument;

        expectKeyword(<span class="hljs-string">'throw'</span>);

        <span class="hljs-keyword">if</span> (hasLineTerminator) {
            throwError(Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        <span class="hljs-keyword">return</span> node.finishThrowStatement(argument);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-130" id="section-130"></a>
</div>
<p>ECMA-262 13.15 The try statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseCatchClause</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> param, params = [], paramMap = {}, key, i, body, node = <span class="hljs-keyword">new</span> Node();

        expectKeyword(<span class="hljs-string">'catch'</span>);

        expect(<span class="hljs-string">'('</span>);
        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">')'</span>)) {
            throwUnexpectedToken(lookahead);
        }

        param = parsePattern(params);
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; params.length; i++) {
            key = <span class="hljs-string">'$'</span> + params[i].value;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(paramMap, key)) {
                tolerateError(Messages.DuplicateBinding, params[i].value);
            }
            paramMap[key] = <span class="hljs-literal">true</span>;
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-131" id="section-131"></a>
</div>
<p>ECMA-262 12.14.1</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (strict &amp;&amp; isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }

        expect(<span class="hljs-string">')'</span>);
        body = parseBlock();
        <span class="hljs-keyword">return</span> node.finishCatchClause(param, body);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseTryStatement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> block, handler = <span class="hljs-literal">null</span>, finalizer = <span class="hljs-literal">null</span>;

        expectKeyword(<span class="hljs-string">'try'</span>);

        block = parseBlock();

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'catch'</span>)) {
            handler = parseCatchClause();
        }

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'finally'</span>)) {
            lex();
            finalizer = parseBlock();
        }

        <span class="hljs-keyword">if</span> (!handler &amp;&amp; !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }

        <span class="hljs-keyword">return</span> node.finishTryStatement(block, handler, finalizer);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-132" id="section-132"></a>
</div>
<p>ECMA-262 13.16 The debugger statement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseDebuggerStatement</span>(<span class="hljs-params">node</span>) </span>{
        expectKeyword(<span class="hljs-string">'debugger'</span>);

        consumeSemicolon();

        <span class="hljs-keyword">return</span> node.finishDebuggerStatement();
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-133" id="section-133"></a>
</div>
<p>13 Statements</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseStatement</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        <span class="hljs-keyword">if</span> (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }

        <span class="hljs-keyword">if</span> (type === Token.Punctuator &amp;&amp; lookahead.value === <span class="hljs-string">'{'</span>) {
            <span class="hljs-keyword">return</span> parseBlock();
        }
        isAssignmentTarget = isBindingElement = <span class="hljs-literal">true</span>;
        node = <span class="hljs-keyword">new</span> Node();

        <span class="hljs-keyword">if</span> (type === Token.Punctuator) {
            <span class="hljs-keyword">switch</span> (lookahead.value) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">';'</span>:
                <span class="hljs-keyword">return</span> parseEmptyStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>:
                <span class="hljs-keyword">return</span> parseExpressionStatement(node);
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">break</span>;
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === Token.Keyword) {
            <span class="hljs-keyword">switch</span> (lookahead.value) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">'break'</span>:
                <span class="hljs-keyword">return</span> parseBreakStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'continue'</span>:
                <span class="hljs-keyword">return</span> parseContinueStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'debugger'</span>:
                <span class="hljs-keyword">return</span> parseDebuggerStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'do'</span>:
                <span class="hljs-keyword">return</span> parseDoWhileStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'for'</span>:
                <span class="hljs-keyword">return</span> parseForStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'function'</span>:
                <span class="hljs-keyword">return</span> parseFunctionDeclaration(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'if'</span>:
                <span class="hljs-keyword">return</span> parseIfStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'return'</span>:
                <span class="hljs-keyword">return</span> parseReturnStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'switch'</span>:
                <span class="hljs-keyword">return</span> parseSwitchStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'throw'</span>:
                <span class="hljs-keyword">return</span> parseThrowStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'try'</span>:
                <span class="hljs-keyword">return</span> parseTryStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'var'</span>:
                <span class="hljs-keyword">return</span> parseVariableStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'while'</span>:
                <span class="hljs-keyword">return</span> parseWhileStatement(node);
            <span class="hljs-keyword">case</span> <span class="hljs-string">'with'</span>:
                <span class="hljs-keyword">return</span> parseWithStatement(node);
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">break</span>;
            }
        }

        expr = parseExpression();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-134" id="section-134"></a>
</div>
<p>ECMA-262 12.12 Labelled Statements</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> ((expr.type === Syntax.Identifier) &amp;&amp; match(<span class="hljs-string">':'</span>)) {
            lex();

            key = <span class="hljs-string">'$'</span> + expr.name;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, <span class="hljs-string">'Label'</span>, expr.name);
            }

            state.labelSet[key] = <span class="hljs-literal">true</span>;
            labeledBody = parseStatement();
            <span class="hljs-keyword">delete</span> state.labelSet[key];
            <span class="hljs-keyword">return</span> node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        <span class="hljs-keyword">return</span> node.finishExpressionStatement(expr);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-135" id="section-135"></a>
</div>
<p>ECMA-262 14.1 Function Definition</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFunctionSourceElements</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> statement, body = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody,
            node = <span class="hljs-keyword">new</span> Node();

        expect(<span class="hljs-string">'{'</span>);

        <span class="hljs-keyword">while</span> (startIndex &lt; length) {
            <span class="hljs-keyword">if</span> (lookahead.type !== Token.StringLiteral) {
                <span class="hljs-keyword">break</span>;
            }
            token = lookahead;

            statement = parseStatementListItem();
            body.push(statement);
            <span class="hljs-keyword">if</span> (statement.expression.type !== Syntax.Literal) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-136" id="section-136"></a>
</div>
<p>this is not directive</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">break</span>;
            }
            directive = source.slice(token.start + <span class="hljs-number">1</span>, token.end - <span class="hljs-number">1</span>);
            <span class="hljs-keyword">if</span> (directive === <span class="hljs-string">'use strict'</span>) {
                strict = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (!firstRestricted &amp;&amp; token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = <span class="hljs-literal">false</span>;
        state.inSwitch = <span class="hljs-literal">false</span>;
        state.inFunctionBody = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">while</span> (startIndex &lt; length) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'}'</span>)) {
                <span class="hljs-keyword">break</span>;
            }
            body.push(parseStatementListItem());
        }

        expect(<span class="hljs-string">'}'</span>);

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        <span class="hljs-keyword">return</span> node.finishBlockStatement(body);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateParam</span>(<span class="hljs-params">options, param, name</span>) </span>{
        <span class="hljs-keyword">var</span> key = <span class="hljs-string">'$'</span> + name;
        <span class="hljs-keyword">if</span> (strict) {
            <span class="hljs-keyword">if</span> (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!options.firstRestricted) {
            <span class="hljs-keyword">if</span> (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseParam</span>(<span class="hljs-params">options</span>) </span>{
        <span class="hljs-keyword">var</span> token, param, params = [], i, def;

        token = lookahead;
        <span class="hljs-keyword">if</span> (token.value === <span class="hljs-string">'...'</span>) {
            param = parseRestElement(params);
            validateParam(options, param.argument, param.argument.name);
            options.params.push(param);
            options.defaults.push(<span class="hljs-literal">null</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        param = parsePatternWithDefault(params);
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; params.length; i++) {
            validateParam(options, params[i], params[i].value);
        }

        <span class="hljs-keyword">if</span> (param.type === Syntax.AssignmentPattern) {
            def = param.right;
            param = param.left;
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        <span class="hljs-keyword">return</span> !match(<span class="hljs-string">')'</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseParams</span>(<span class="hljs-params">firstRestricted</span>) </span>{
        <span class="hljs-keyword">var</span> options;

        options = {
            <span class="hljs-attr">params</span>: [],
            <span class="hljs-attr">defaultCount</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">defaults</span>: [],
            <span class="hljs-attr">firstRestricted</span>: firstRestricted
        };

        expect(<span class="hljs-string">'('</span>);

        <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">')'</span>)) {
            options.paramSet = {};
            <span class="hljs-keyword">while</span> (startIndex &lt; length) {
                <span class="hljs-keyword">if</span> (!parseParam(options)) {
                    <span class="hljs-keyword">break</span>;
                }
                expect(<span class="hljs-string">','</span>);
            }
        }

        expect(<span class="hljs-string">')'</span>);

        <span class="hljs-keyword">if</span> (options.defaultCount === <span class="hljs-number">0</span>) {
            options.defaults = [];
        }

        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">params</span>: options.params,
            <span class="hljs-attr">defaults</span>: options.defaults,
            <span class="hljs-attr">stricted</span>: options.stricted,
            <span class="hljs-attr">firstRestricted</span>: options.firstRestricted,
            <span class="hljs-attr">message</span>: options.message
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFunctionDeclaration</span>(<span class="hljs-params">node, identifierIsOptional</span>) </span>{
        <span class="hljs-keyword">var</span> id = <span class="hljs-literal">null</span>, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword(<span class="hljs-string">'function'</span>);

        isGenerator = match(<span class="hljs-string">'*'</span>);
        <span class="hljs-keyword">if</span> (isGenerator) {
            lex();
        }

        <span class="hljs-keyword">if</span> (!identifierIsOptional || !match(<span class="hljs-string">'('</span>)) {
            token = lookahead;
            id = parseVariableIdentifier();
            <span class="hljs-keyword">if</span> (strict) {
                <span class="hljs-keyword">if</span> (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        state.allowYield = !isGenerator;
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        <span class="hljs-keyword">if</span> (tmp.message) {
            message = tmp.message;
        }


        previousStrict = strict;
        body = parseFunctionSourceElements();
        <span class="hljs-keyword">if</span> (strict &amp;&amp; firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        <span class="hljs-keyword">if</span> (strict &amp;&amp; stricted) {
            tolerateUnexpectedToken(stricted, message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        <span class="hljs-keyword">return</span> node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFunctionExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> token, id = <span class="hljs-literal">null</span>, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = <span class="hljs-keyword">new</span> Node(),
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword(<span class="hljs-string">'function'</span>);

        isGenerator = match(<span class="hljs-string">'*'</span>);
        <span class="hljs-keyword">if</span> (isGenerator) {
            lex();
        }

        state.allowYield = !isGenerator;
        <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'('</span>)) {
            token = lookahead;
            id = (!strict &amp;&amp; !isGenerator &amp;&amp; matchKeyword(<span class="hljs-string">'yield'</span>)) ? parseNonComputedProperty() : parseVariableIdentifier();
            <span class="hljs-keyword">if</span> (strict) {
                <span class="hljs-keyword">if</span> (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        <span class="hljs-keyword">if</span> (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        <span class="hljs-keyword">if</span> (strict &amp;&amp; firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        <span class="hljs-keyword">if</span> (strict &amp;&amp; stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;
        state.allowYield = previousAllowYield;

        <span class="hljs-keyword">return</span> node.finishFunctionExpression(id, params, defaults, body, isGenerator);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-137" id="section-137"></a>
</div>
<p>ECMA-262 14.5 Class Definitions</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseClassBody</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> classBody, token, isStatic, hasConstructor = <span class="hljs-literal">false</span>, body, method, computed, key;

        classBody = <span class="hljs-keyword">new</span> Node();

        expect(<span class="hljs-string">'{'</span>);
        body = [];
        <span class="hljs-keyword">while</span> (!match(<span class="hljs-string">'}'</span>)) {
            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">';'</span>)) {
                lex();
            } <span class="hljs-keyword">else</span> {
                method = <span class="hljs-keyword">new</span> Node();
                token = lookahead;
                isStatic = <span class="hljs-literal">false</span>;
                computed = match(<span class="hljs-string">'['</span>);
                <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'*'</span>)) {
                    lex();
                } <span class="hljs-keyword">else</span> {
                    key = parseObjectPropertyKey();
                    <span class="hljs-keyword">if</span> (key.name === <span class="hljs-string">'static'</span> &amp;&amp; (lookaheadPropertyName() || match(<span class="hljs-string">'*'</span>))) {
                        token = lookahead;
                        isStatic = <span class="hljs-literal">true</span>;
                        computed = match(<span class="hljs-string">'['</span>);
                        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'*'</span>)) {
                            lex();
                        } <span class="hljs-keyword">else</span> {
                            key = parseObjectPropertyKey();
                        }
                    }
                }
                method = tryParseMethodDefinition(token, key, computed, method);
                <span class="hljs-keyword">if</span> (method) {
                    method[<span class="hljs-string">'static'</span>] = isStatic; <span class="hljs-comment">// jscs:ignore requireDotNotation</span>
                    <span class="hljs-keyword">if</span> (method.kind === <span class="hljs-string">'init'</span>) {
                        method.kind = <span class="hljs-string">'method'</span>;
                    }
                    <span class="hljs-keyword">if</span> (!isStatic) {
                        <span class="hljs-keyword">if</span> (!method.computed &amp;&amp; (method.key.name || method.key.value.toString()) === <span class="hljs-string">'constructor'</span>) {
                            <span class="hljs-keyword">if</span> (method.kind !== <span class="hljs-string">'method'</span> || !method.method || method.value.generator) {
                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                            }
                            <span class="hljs-keyword">if</span> (hasConstructor) {
                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
                            } <span class="hljs-keyword">else</span> {
                                hasConstructor = <span class="hljs-literal">true</span>;
                            }
                            method.kind = <span class="hljs-string">'constructor'</span>;
                        }
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">if</span> (!method.computed &amp;&amp; (method.key.name || method.key.value.toString()) === <span class="hljs-string">'prototype'</span>) {
                            throwUnexpectedToken(token, Messages.StaticPrototype);
                        }
                    }
                    method.type = Syntax.MethodDefinition;
                    <span class="hljs-keyword">delete</span> method.method;
                    <span class="hljs-keyword">delete</span> method.shorthand;
                    body.push(method);
                } <span class="hljs-keyword">else</span> {
                    throwUnexpectedToken(lookahead);
                }
            }
        }
        lex();
        <span class="hljs-keyword">return</span> classBody.finishClassBody(body);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseClassDeclaration</span>(<span class="hljs-params">identifierIsOptional</span>) </span>{
        <span class="hljs-keyword">var</span> id = <span class="hljs-literal">null</span>, superClass = <span class="hljs-literal">null</span>, classNode = <span class="hljs-keyword">new</span> Node(), classBody, previousStrict = strict;
        strict = <span class="hljs-literal">true</span>;

        expectKeyword(<span class="hljs-string">'class'</span>);

        <span class="hljs-keyword">if</span> (!identifierIsOptional || lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'extends'</span>)) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        <span class="hljs-keyword">return</span> classNode.finishClassDeclaration(id, superClass, classBody);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseClassExpression</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> id = <span class="hljs-literal">null</span>, superClass = <span class="hljs-literal">null</span>, classNode = <span class="hljs-keyword">new</span> Node(), classBody, previousStrict = strict;
        strict = <span class="hljs-literal">true</span>;

        expectKeyword(<span class="hljs-string">'class'</span>);

        <span class="hljs-keyword">if</span> (lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'extends'</span>)) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        <span class="hljs-keyword">return</span> classNode.finishClassExpression(id, superClass, classBody);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-138" id="section-138"></a>
</div>
<p>ECMA-262 15.2 Modules</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseModuleSpecifier</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node();

        <span class="hljs-keyword">if</span> (lookahead.type !== Token.StringLiteral) {
            throwError(Messages.InvalidModuleSpecifier);
        }
        <span class="hljs-keyword">return</span> node.finishLiteral(lex());
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-139" id="section-139"></a>
</div>
<p>ECMA-262 15.2.3 Exports</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseExportSpecifier</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> exported, local, node = <span class="hljs-keyword">new</span> Node(), def;
        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'default'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-140" id="section-140"></a>
</div>
<p>export {default} from 'something';</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            def = <span class="hljs-keyword">new</span> Node();
            lex();
            local = def.finishIdentifier(<span class="hljs-string">'default'</span>);
        } <span class="hljs-keyword">else</span> {
            local = parseVariableIdentifier();
        }
        <span class="hljs-keyword">if</span> (matchContextualKeyword(<span class="hljs-string">'as'</span>)) {
            lex();
            exported = parseNonComputedProperty();
        }
        <span class="hljs-keyword">return</span> node.finishExportSpecifier(local, exported);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseExportNamedDeclaration</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> declaration = <span class="hljs-literal">null</span>,
            isExportFromIdentifier,
            src = <span class="hljs-literal">null</span>, specifiers = [];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-141" id="section-141"></a>
</div>
<p>non-default export</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (lookahead.type === Token.Keyword) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-142" id="section-142"></a>
</div>
<p>covers:
export var f = 1;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">switch</span> (lookahead.value) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'let'</span>:
                <span class="hljs-keyword">case</span> <span class="hljs-string">'const'</span>:
                    declaration = parseLexicalDeclaration({<span class="hljs-attr">inFor</span>: <span class="hljs-literal">false</span>});
                    <span class="hljs-keyword">return</span> node.finishExportNamedDeclaration(declaration, specifiers, <span class="hljs-literal">null</span>);
                <span class="hljs-keyword">case</span> <span class="hljs-string">'var'</span>:
                <span class="hljs-keyword">case</span> <span class="hljs-string">'class'</span>:
                <span class="hljs-keyword">case</span> <span class="hljs-string">'function'</span>:
                    declaration = parseStatementListItem();
                    <span class="hljs-keyword">return</span> node.finishExportNamedDeclaration(declaration, specifiers, <span class="hljs-literal">null</span>);
            }
        }

        expect(<span class="hljs-string">'{'</span>);
        <span class="hljs-keyword">while</span> (!match(<span class="hljs-string">'}'</span>)) {
            isExportFromIdentifier = isExportFromIdentifier || matchKeyword(<span class="hljs-string">'default'</span>);
            specifiers.push(parseExportSpecifier());
            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'}'</span>)) {
                expect(<span class="hljs-string">','</span>);
                <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'}'</span>)) {
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
        expect(<span class="hljs-string">'}'</span>);

        <span class="hljs-keyword">if</span> (matchContextualKeyword(<span class="hljs-string">'from'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-143" id="section-143"></a>
</div>
<p>covering:
export {default} from 'foo';
export {foo} from 'foo';</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isExportFromIdentifier) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-144" id="section-144"></a>
</div>
<p>covering:
export {default}; // missing fromClause</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-145" id="section-145"></a>
</div>
<p>cover
export {foo};</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            consumeSemicolon();
        }
        <span class="hljs-keyword">return</span> node.finishExportNamedDeclaration(declaration, specifiers, src);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseExportDefaultDeclaration</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> declaration = <span class="hljs-literal">null</span>,
            expression = <span class="hljs-literal">null</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-146" id="section-146"></a>
</div>
<p>covers:
export default ...</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        expectKeyword(<span class="hljs-string">'default'</span>);

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'function'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-147" id="section-147"></a>
</div>
<p>covers:
export default function foo () {}
export default function () {}</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            declaration = parseFunctionDeclaration(<span class="hljs-keyword">new</span> Node(), <span class="hljs-literal">true</span>);
            <span class="hljs-keyword">return</span> node.finishExportDefaultDeclaration(declaration);
        }
        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'class'</span>)) {
            declaration = parseClassDeclaration(<span class="hljs-literal">true</span>);
            <span class="hljs-keyword">return</span> node.finishExportDefaultDeclaration(declaration);
        }

        <span class="hljs-keyword">if</span> (matchContextualKeyword(<span class="hljs-string">'from'</span>)) {
            throwError(Messages.UnexpectedToken, lookahead.value);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-148" id="section-148"></a>
</div>
<p>covers:
export default {};
export default [];
export default (1 + 2);</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'{'</span>)) {
            expression = parseObjectInitializer();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'['</span>)) {
            expression = parseArrayInitializer();
        } <span class="hljs-keyword">else</span> {
            expression = parseAssignmentExpression();
        }
        consumeSemicolon();
        <span class="hljs-keyword">return</span> node.finishExportDefaultDeclaration(expression);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseExportAllDeclaration</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> src;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-149" id="section-149"></a>
</div>
<p>covers:
export * from 'foo';</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        expect(<span class="hljs-string">'*'</span>);
        <span class="hljs-keyword">if</span> (!matchContextualKeyword(<span class="hljs-string">'from'</span>)) {
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        <span class="hljs-keyword">return</span> node.finishExportAllDeclaration(src);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseExportDeclaration</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node();
        <span class="hljs-keyword">if</span> (state.inFunctionBody) {
            throwError(Messages.IllegalExportDeclaration);
        }

        expectKeyword(<span class="hljs-string">'export'</span>);

        <span class="hljs-keyword">if</span> (matchKeyword(<span class="hljs-string">'default'</span>)) {
            <span class="hljs-keyword">return</span> parseExportDefaultDeclaration(node);
        }
        <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'*'</span>)) {
            <span class="hljs-keyword">return</span> parseExportAllDeclaration(node);
        }
        <span class="hljs-keyword">return</span> parseExportNamedDeclaration(node);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-150" id="section-150"></a>
</div>
<p>ECMA-262 15.2.2 Imports</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseImportSpecifier</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-151" id="section-151"></a>
</div>
<p>import {<foo as bar>} ...;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> local, imported, node = <span class="hljs-keyword">new</span> Node();

        imported = parseNonComputedProperty();
        <span class="hljs-keyword">if</span> (matchContextualKeyword(<span class="hljs-string">'as'</span>)) {
            lex();
            local = parseVariableIdentifier();
        }

        <span class="hljs-keyword">return</span> node.finishImportSpecifier(local, imported);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseNamedImports</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> specifiers = [];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-152" id="section-152"></a>
</div>
<p>{foo, bar as bas}</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        expect(<span class="hljs-string">'{'</span>);
        <span class="hljs-keyword">while</span> (!match(<span class="hljs-string">'}'</span>)) {
            specifiers.push(parseImportSpecifier());
            <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">'}'</span>)) {
                expect(<span class="hljs-string">','</span>);
                <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'}'</span>)) {
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
        expect(<span class="hljs-string">'}'</span>);
        <span class="hljs-keyword">return</span> specifiers;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseImportDefaultSpecifier</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-153" id="section-153"></a>
</div>
<p>import <foo> ...;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> local, node = <span class="hljs-keyword">new</span> Node();

        local = parseNonComputedProperty();

        <span class="hljs-keyword">return</span> node.finishImportDefaultSpecifier(local);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseImportNamespaceSpecifier</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-154" id="section-154"></a>
</div>
<p>import &lt;* as foo&gt; ...;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> local, node = <span class="hljs-keyword">new</span> Node();

        expect(<span class="hljs-string">'*'</span>);
        <span class="hljs-keyword">if</span> (!matchContextualKeyword(<span class="hljs-string">'as'</span>)) {
            throwError(Messages.NoAsAfterImportNamespace);
        }
        lex();
        local = parseNonComputedProperty();

        <span class="hljs-keyword">return</span> node.finishImportNamespaceSpecifier(local);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseImportDeclaration</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> specifiers = [], src, node = <span class="hljs-keyword">new</span> Node();

        <span class="hljs-keyword">if</span> (state.inFunctionBody) {
            throwError(Messages.IllegalImportDeclaration);
        }

        expectKeyword(<span class="hljs-string">'import'</span>);

        <span class="hljs-keyword">if</span> (lookahead.type === Token.StringLiteral) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-155" id="section-155"></a>
</div>
<p>import 'foo';</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            src = parseModuleSpecifier();
        } <span class="hljs-keyword">else</span> {

            <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'{'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-156" id="section-156"></a>
</div>
<p>import {bar}</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                specifiers = specifiers.concat(parseNamedImports());
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'*'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-157" id="section-157"></a>
</div>
<p>import * as foo</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                specifiers.push(parseImportNamespaceSpecifier());
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isIdentifierName(lookahead) &amp;&amp; !matchKeyword(<span class="hljs-string">'default'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-158" id="section-158"></a>
</div>
<p>import foo</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                specifiers.push(parseImportDefaultSpecifier());
                <span class="hljs-keyword">if</span> (match(<span class="hljs-string">','</span>)) {
                    lex();
                    <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'*'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-159" id="section-159"></a>
</div>
<p>import foo, * as foo</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                        specifiers.push(parseImportNamespaceSpecifier());
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match(<span class="hljs-string">'{'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-160" id="section-160"></a>
</div>
<p>import foo, {bar}</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                        specifiers = specifiers.concat(parseNamedImports());
                    } <span class="hljs-keyword">else</span> {
                        throwUnexpectedToken(lookahead);
                    }
                }
            } <span class="hljs-keyword">else</span> {
                throwUnexpectedToken(lex());
            }

            <span class="hljs-keyword">if</span> (!matchContextualKeyword(<span class="hljs-string">'from'</span>)) {
                throwError(lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            }
            lex();
            src = parseModuleSpecifier();
        }

        consumeSemicolon();
        <span class="hljs-keyword">return</span> node.finishImportDeclaration(specifiers, src);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-161" id="section-161"></a>
</div>
<p>ECMA-262 15.1 Scripts</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseScriptBody</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> statement, body = [], token, directive, firstRestricted;

        <span class="hljs-keyword">while</span> (startIndex &lt; length) {
            token = lookahead;
            <span class="hljs-keyword">if</span> (token.type !== Token.StringLiteral) {
                <span class="hljs-keyword">break</span>;
            }

            statement = parseStatementListItem();
            body.push(statement);
            <span class="hljs-keyword">if</span> (statement.expression.type !== Syntax.Literal) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-162" id="section-162"></a>
</div>
<p>this is not directive</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">break</span>;
            }
            directive = source.slice(token.start + <span class="hljs-number">1</span>, token.end - <span class="hljs-number">1</span>);
            <span class="hljs-keyword">if</span> (directive === <span class="hljs-string">'use strict'</span>) {
                strict = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (!firstRestricted &amp;&amp; token.octal) {
                    firstRestricted = token;
                }
            }
        }

        <span class="hljs-keyword">while</span> (startIndex &lt; length) {
            statement = parseStatementListItem();
            <span class="hljs-comment">/* istanbul ignore if */</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> statement === <span class="hljs-string">'undefined'</span>) {
                <span class="hljs-keyword">break</span>;
            }
            body.push(statement);
        }
        <span class="hljs-keyword">return</span> body;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseProgram</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> body, node;

        peek();
        node = <span class="hljs-keyword">new</span> Node();

        body = parseScriptBody();
        <span class="hljs-keyword">return</span> node.finishProgram(body, state.sourceType);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterTokenLocation</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> i, entry, token, tokens = [];

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                <span class="hljs-attr">type</span>: entry.type,
                <span class="hljs-attr">value</span>: entry.value
            };
            <span class="hljs-keyword">if</span> (entry.regex) {
                token.regex = {
                    <span class="hljs-attr">pattern</span>: entry.regex.pattern,
                    <span class="hljs-attr">flags</span>: entry.regex.flags
                };
            }
            <span class="hljs-keyword">if</span> (extra.range) {
                token.range = entry.range;
            }
            <span class="hljs-keyword">if</span> (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokenize</span>(<span class="hljs-params">code, options, delegate</span>) </span>{
        <span class="hljs-keyword">var</span> toString,
            tokens;

        toString = <span class="hljs-built_in">String</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> code !== <span class="hljs-string">'string'</span> &amp;&amp; !(code <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>)) {
            code = toString(code);
        }

        source = code;
        index = <span class="hljs-number">0</span>;
        lineNumber = (source.length &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        lineStart = <span class="hljs-number">0</span>;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = <span class="hljs-literal">null</span>;
        state = {
            <span class="hljs-attr">allowIn</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">allowYield</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">labelSet</span>: {},
            <span class="hljs-attr">inFunctionBody</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">inIteration</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">inSwitch</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">lastCommentStart</span>: <span class="hljs-number">-1</span>,
            <span class="hljs-attr">curlyStack</span>: []
        };

        extra = {};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-163" id="section-163"></a>
</div>
<p>Options matching.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        options = options || {};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-164" id="section-164"></a>
</div>
<p>Of course we collect tokens here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        options.tokens = <span class="hljs-literal">true</span>;
        extra.tokens = [];
        extra.tokenValues = [];
        extra.tokenize = <span class="hljs-literal">true</span>;
        extra.delegate = delegate;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-165" id="section-165"></a>
</div>
<p>The following two fields are necessary to compute the Regex tokens.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        extra.openParenToken = <span class="hljs-number">-1</span>;
        extra.openCurlyToken = <span class="hljs-number">-1</span>;

        extra.range = (<span class="hljs-keyword">typeof</span> options.range === <span class="hljs-string">'boolean'</span>) &amp;&amp; options.range;
        extra.loc = (<span class="hljs-keyword">typeof</span> options.loc === <span class="hljs-string">'boolean'</span>) &amp;&amp; options.loc;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options.comment === <span class="hljs-string">'boolean'</span> &amp;&amp; options.comment) {
            extra.comments = [];
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options.tolerant === <span class="hljs-string">'boolean'</span> &amp;&amp; options.tolerant) {
            extra.errors = [];
        }

        <span class="hljs-keyword">try</span> {
            peek();
            <span class="hljs-keyword">if</span> (lookahead.type === Token.EOF) {
                <span class="hljs-keyword">return</span> extra.tokens;
            }

            lex();
            <span class="hljs-keyword">while</span> (lookahead.type !== Token.EOF) {
                <span class="hljs-keyword">try</span> {
                    lex();
                } <span class="hljs-keyword">catch</span> (lexError) {
                    <span class="hljs-keyword">if</span> (extra.errors) {
                        recordError(lexError);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-166" id="section-166"></a>
</div>
<p>We have to break on the first error
to avoid infinite loops.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                        <span class="hljs-keyword">break</span>;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">throw</span> lexError;
                    }
                }
            }

            tokens = extra.tokens;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> extra.errors !== <span class="hljs-string">'undefined'</span>) {
                tokens.errors = extra.errors;
            }
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-keyword">throw</span> e;
        } <span class="hljs-keyword">finally</span> {
            extra = {};
        }
        <span class="hljs-keyword">return</span> tokens;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">code, options</span>) </span>{
        <span class="hljs-keyword">var</span> program, toString;

        toString = <span class="hljs-built_in">String</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> code !== <span class="hljs-string">'string'</span> &amp;&amp; !(code <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>)) {
            code = toString(code);
        }

        source = code;
        index = <span class="hljs-number">0</span>;
        lineNumber = (source.length &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        lineStart = <span class="hljs-number">0</span>;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = <span class="hljs-literal">null</span>;
        state = {
            <span class="hljs-attr">allowIn</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">allowYield</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">labelSet</span>: {},
            <span class="hljs-attr">inFunctionBody</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">inIteration</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">inSwitch</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">lastCommentStart</span>: <span class="hljs-number">-1</span>,
            <span class="hljs-attr">curlyStack</span>: [],
            <span class="hljs-attr">sourceType</span>: <span class="hljs-string">'script'</span>
        };
        strict = <span class="hljs-literal">false</span>;

        extra = {};
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options !== <span class="hljs-string">'undefined'</span>) {
            extra.range = (<span class="hljs-keyword">typeof</span> options.range === <span class="hljs-string">'boolean'</span>) &amp;&amp; options.range;
            extra.loc = (<span class="hljs-keyword">typeof</span> options.loc === <span class="hljs-string">'boolean'</span>) &amp;&amp; options.loc;
            extra.attachComment = (<span class="hljs-keyword">typeof</span> options.attachComment === <span class="hljs-string">'boolean'</span>) &amp;&amp; options.attachComment;

            <span class="hljs-keyword">if</span> (extra.loc &amp;&amp; options.source !== <span class="hljs-literal">null</span> &amp;&amp; options.source !== <span class="hljs-literal">undefined</span>) {
                extra.source = toString(options.source);
            }

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options.tokens === <span class="hljs-string">'boolean'</span> &amp;&amp; options.tokens) {
                extra.tokens = [];
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options.comment === <span class="hljs-string">'boolean'</span> &amp;&amp; options.comment) {
                extra.comments = [];
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options.tolerant === <span class="hljs-string">'boolean'</span> &amp;&amp; options.tolerant) {
                extra.errors = [];
            }
            <span class="hljs-keyword">if</span> (extra.attachComment) {
                extra.range = <span class="hljs-literal">true</span>;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
            <span class="hljs-keyword">if</span> (options.sourceType === <span class="hljs-string">'module'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-167" id="section-167"></a>
</div>
<p>very restrictive condition for now</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                state.sourceType = options.sourceType;
                strict = <span class="hljs-literal">true</span>;
            }
        }

        <span class="hljs-keyword">try</span> {
            program = parseProgram();
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> extra.comments !== <span class="hljs-string">'undefined'</span>) {
                program.comments = extra.comments;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> extra.tokens !== <span class="hljs-string">'undefined'</span>) {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> extra.errors !== <span class="hljs-string">'undefined'</span>) {
                program.errors = extra.errors;
            }
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-keyword">throw</span> e;
        } <span class="hljs-keyword">finally</span> {
            extra = {};
        }

        <span class="hljs-keyword">return</span> program;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-168" id="section-168"></a>
</div>
<p>Sync with *.json manifests.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    exports.version = <span class="hljs-string">'2.7.2'</span>;

    exports.tokenize = tokenize;

    exports.parse = parse;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-169" id="section-169"></a>
</div>
<p>Deep copy.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-comment">/* istanbul ignore next */</span>
    exports.Syntax = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> name, types = {};

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.create === <span class="hljs-string">'function'</span>) {
            types = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
        }

        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> Syntax) {
            <span class="hljs-keyword">if</span> (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.freeze === <span class="hljs-string">'function'</span>) {
            <span class="hljs-built_in">Object</span>.freeze(types);
        }

        <span class="hljs-keyword">return</span> types;
    }());

}));
<span class="hljs-comment">/* vim: set sw=4 ts=4 et tw=80 : */</span>

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
