<!DOCTYPE html>
<html>
<head>
  <title>_stream_transform.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../../../doc-style.css" />
  <script src="../../../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../../../";
    var thisFile = "node_modules/serialport/node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>_stream_transform.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<p>Copyright Joyent, Inc. and other Node contributors.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
&quot;Software&quot;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the
following conditions:</p>
<p>The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>a transform stream is a readable/writable stream where you do
something with the data.  Sometimes it's called a &quot;filter&quot;,
but that's not a great name for it, since that implies a thing where
some bits pass through, and others are simply ignored.  (That would
be a valid example of a transform, of course.)</p>
<p>While the output is causally related to the input, it's not a
necessarily symmetric or synchronous transformation.  For example,
a zlib stream might take multiple plain-text writes(), and then
emit a single compressed chunk some time in the future.</p>
<p>Here's how this works:</p>
<p>The Transform stream has all the aspects of the readable and writable
stream classes.  When you write(chunk), that calls _write(chunk,cb)
internally, and returns false if there's a lot of pending writes
buffered up.  When you call read(), that calls _read(n) until
there's enough pending readable data buffered up.</p>
<p>In a transform stream, the written data is placed in a buffer.  When
_read(n) is called, it transforms the queued up data, calling the
buffered _write cb's as it consumes chunks.  If consuming a single
written chunk would result in multiple output chunks, then the first
outputted bit calls the readcb, and subsequent chunks just go into
the read buffer, and will cause it to emit 'readable' if necessary.</p>
<p>This way, back-pressure is actually determined by the reading side,
since _read has to be called to start processing a new chunk.  However,
a pathological inflate type of transform can cause excessive buffering
here.  For example, imagine a stream where every byte of input is
interpreted as an integer from 0-255, and then results in that many
bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
1kb of data being output.  In this case, you could write a very small
amount of input, and end up with a very large amount of output.  In
such a pathological inflating mechanism, there'd be no way to tell
the system to stop doing the transform.  A single 4MB write could
cause the system to run out of memory.</p>
<p>However, even in such a pathological case, only a single written chunk
would be consumed, and then the rest would wait (un-transformed) until
the results of the previous transformed chunk were consumed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-built_in">module</span>.exports = Transform;

<span class="hljs-keyword">var</span> Duplex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./_stream_duplex'</span>);

<span class="hljs-comment">/*&lt;replacement&gt;*/</span>
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'core-util-is'</span>);
util.inherits = <span class="hljs-built_in">require</span>(<span class="hljs-string">'inherits'</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"></pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
