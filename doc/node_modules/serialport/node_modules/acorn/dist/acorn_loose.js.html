<!DOCTYPE html>
<html>
<head>
  <title>acorn_loose.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/acorn/dist/acorn_loose.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>acorn_loose.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>)</span>{<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> exports===<span class="hljs-string">"object"</span>&amp;&amp;<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span>!==<span class="hljs-string">"undefined"</span>){<span class="hljs-built_in">module</span>.exports=f()}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> define===<span class="hljs-string">"function"</span>&amp;&amp;define.amd){define([],f)}<span class="hljs-keyword">else</span>{<span class="hljs-keyword">var</span> g;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>!==<span class="hljs-string">"undefined"</span>){g=<span class="hljs-built_in">window</span>}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> global!==<span class="hljs-string">"undefined"</span>){g=global}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> self!==<span class="hljs-string">"undefined"</span>){g=self}<span class="hljs-keyword">else</span>{g=<span class="hljs-keyword">this</span>}(g.acorn || (g.acorn = {})).loose = f()}})(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">var</span> define,<span class="hljs-built_in">module</span>,exports;<span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">t,n,r</span>)</span>{<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params">o,u</span>)</span>{<span class="hljs-keyword">if</span>(!n[o]){<span class="hljs-keyword">if</span>(!t[o]){<span class="hljs-keyword">var</span> a=<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span>==<span class="hljs-string">"function"</span>&amp;&amp;<span class="hljs-built_in">require</span>;<span class="hljs-keyword">if</span>(!u&amp;&amp;a)<span class="hljs-keyword">return</span> a(o,!<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(i)<span class="hljs-keyword">return</span> i(o,!<span class="hljs-number">0</span>);<span class="hljs-keyword">var</span> f=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cannot find module '"</span>+o+<span class="hljs-string">"'"</span>);<span class="hljs-keyword">throw</span> f.code=<span class="hljs-string">"MODULE_NOT_FOUND"</span>,f}<span class="hljs-keyword">var</span> l=n[o]={<span class="hljs-attr">exports</span>:{}};t[o][<span class="hljs-number">0</span>].call(l.exports,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{<span class="hljs-keyword">var</span> n=t[o][<span class="hljs-number">1</span>][e];<span class="hljs-keyword">return</span> s(n?n:e)},l,l.exports,e,t,n,r)}<span class="hljs-keyword">return</span> n[o].exports}<span class="hljs-keyword">var</span> i=<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span>==<span class="hljs-string">"function"</span>&amp;&amp;<span class="hljs-built_in">require</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> o=<span class="hljs-number">0</span>;o&lt;r.length;o++)s(r[o]);<span class="hljs-keyword">return</span> s})({<span class="hljs-number">1</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_dereq_,module,exports</span>)</span>{
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> _interopRequireWildcard = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{ <span class="hljs-keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class="hljs-string">"default"</span>: obj }; };

exports.parse_dammit = parse_dammit;
exports.__esModule = <span class="hljs-literal">true</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Acorn: Loose parser</p>
<p>This module provides an alternative parser (<code>parse_dammit</code>) that
exposes that same interface as <code>parse</code>, but will try to parse
anything as JavaScript, repairing syntax error the best it can.
There are circumstances in which it will raise an error and give
up, but they are very rare. The resulting AST will be a mostly
valid JavaScript AST (as per the <a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">Mozilla parser API</a>, except
that:</p>
<ul>
<li>
<p>Return outside functions is allowed</p>
</li>
<li>
<p>Label consistency (no conflicts, break only to existing labels)
is not enforced.</p>
</li>
<li>
<p>Bogus Identifier nodes with a name of <code>&quot;âœ–&quot;</code> are inserted whenever
the parser got too confused to return anything meaningful.</p>
</li>
</ul>
<p>The expected use for this is to <em>first</em> try <code>acorn.parse</code>, and only
if that fails switch to <code>parse_dammit</code>. The loose parser might
parse badly indented code incorrectly, so <strong>don't</strong> use it as
your default parser.</p>
<p>Quite a lot of acorn.js is duplicated here. The alternative was to
add a <em>lot</em> of extra cruft to that file, making it less readable
and slower. Copying and editing the code allowed me to make
invasive changes and simplifications without creating a complicated
tangle.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-keyword">var</span> acorn = _interopRequireWildcard(_dereq_(<span class="hljs-string">".."</span>));

<span class="hljs-keyword">var</span> _state = _dereq_(<span class="hljs-string">"./state"</span>);

<span class="hljs-keyword">var</span> LooseParser = _state.LooseParser;

_dereq_(<span class="hljs-string">"./tokenize"</span>);

_dereq_(<span class="hljs-string">"./parseutil"</span>);

_dereq_(<span class="hljs-string">"./statement"</span>);

_dereq_(<span class="hljs-string">"./expression"</span>);

exports.LooseParser = _state.LooseParser;

acorn.defaultOptions.tabSize = <span class="hljs-number">4</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse_dammit</span>(<span class="hljs-params">input, options</span>) </span>{
  <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> LooseParser(input, options);
  p.next();
  <span class="hljs-keyword">return</span> p.parseTopLevel();
}

acorn.parse_dammit = parse_dammit;
acorn.LooseParser = LooseParser;

},{<span class="hljs-string">".."</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"./expression"</span>:<span class="hljs-number">3</span>,<span class="hljs-string">"./parseutil"</span>:<span class="hljs-number">4</span>,<span class="hljs-string">"./state"</span>:<span class="hljs-number">5</span>,<span class="hljs-string">"./statement"</span>:<span class="hljs-number">6</span>,<span class="hljs-string">"./tokenize"</span>:<span class="hljs-number">7</span>}],<span class="hljs-number">2</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_dereq_,module,exports</span>)</span>{
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-built_in">module</span>.exports = <span class="hljs-keyword">typeof</span> acorn != <span class="hljs-string">"undefined"</span> ? acorn : _dereq_(<span class="hljs-string">"./acorn"</span>);

},{}],<span class="hljs-number">3</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_dereq_,module,exports</span>)</span>{
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> LooseParser = _dereq_(<span class="hljs-string">"./state"</span>).LooseParser;

<span class="hljs-keyword">var</span> isDummy = _dereq_(<span class="hljs-string">"./parseutil"</span>).isDummy;

<span class="hljs-keyword">var</span> tt = _dereq_(<span class="hljs-string">".."</span>).tokTypes;

<span class="hljs-keyword">var</span> lp = LooseParser.prototype;

lp.checkLVal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">expr, binding</span>) </span>{
  <span class="hljs-keyword">if</span> (!expr) <span class="hljs-keyword">return</span> expr;
  <span class="hljs-keyword">switch</span> (expr.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Identifier"</span>:
      <span class="hljs-keyword">return</span> expr;

    <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
      <span class="hljs-keyword">return</span> binding ? <span class="hljs-keyword">this</span>.dummyIdent() : expr;

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ParenthesizedExpression"</span>:
      expr.expression = <span class="hljs-keyword">this</span>.checkLVal(expr.expression, binding);
      <span class="hljs-keyword">return</span> expr;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>FIXME recursively check contents</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
    case "AssignmentPattern":
      if (this.options.ecmaVersion &gt;= 6) return expr;

    default:
      return this.dummyIdent();
  }
};

lp.parseExpression = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseMaybeAssign(noIn);
  if (this.tok.type === tt.comma) {
    var node = this.startNodeAt(start);
    node.expressions = [expr];
    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

lp.parseParenExpression = function () {
  this.pushCx();
  this.expect(tt.parenL);
  var val = this.parseExpression();
  this.popCx();
  this.expect(tt.parenR);
  return val;
};

lp.parseMaybeAssign = function (noIn) {
  var start = this.storeCurrentPos();
  var left = this.parseMaybeConditional(noIn);
  if (this.tok.type.isAssign) {
    var node = this.startNodeAt(start);
    node.operator = this.tok.value;
    node.left = this.tok.type === tt.eq ? this.toAssignable(left) : this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  }
  return left;
};

lp.parseMaybeConditional = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseExprOps(noIn);
  if (this.eat(tt.question)) {
    var node = this.startNodeAt(start);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    node.alternate = this.expect(tt.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

lp.parseExprOps = function (noIn) {
  var start = this.storeCurrentPos();
  var indent = this.curIndent,
      line = this.curLineStart;
  return this.parseExprOp(this.parseMaybeUnary(noIn), start, -1, noIn, indent, line);
};

lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
  if (this.curLineStart != line &amp;&amp; this.curIndent &lt; indent &amp;&amp; this.tokenStartsLine()) return left;
  var prec = this.tok.type.binop;
  if (prec != null &amp;&amp; (!noIn || this.tok.type !== tt._in)) {
    if (prec &gt; minPrec) {
      var node = this.startNodeAt(start);
      node.left = left;
      node.operator = this.tok.value;
      this.next();
      if (this.curLineStart != line &amp;&amp; this.curIndent &lt; indent &amp;&amp; this.tokenStartsLine()) {
        node.right = this.dummyIdent();
      } else {
        var rightStart = this.storeCurrentPos();
        node.right = this.parseExprOp(this.parseMaybeUnary(noIn), rightStart, prec, noIn, indent, line);
      }
      this.finishNode(node, /&amp;&amp;|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, start, minPrec, noIn, indent, line);
    }
  }
  return left;
};

lp.parseMaybeUnary = function (noIn) {
  if (this.tok.type.prefix) {
    var node = this.startNode(),
        update = this.tok.type === tt.incDec;
    node.operator = this.tok.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(noIn);
    if (update) node.argument = this.checkLVal(node.argument);
    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (this.tok.type === tt.ellipsis) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(noIn);
    return this.finishNode(node, "SpreadElement");
  }
  var start = this.storeCurrentPos();
  var expr = this.parseExprSubscripts();
  while (this.tok.type.postfix &amp;&amp; !this.canInsertSemicolon()) {
    var node = this.startNodeAt(start);
    node.operator = this.tok.value;
    node.prefix = false;
    node.argument = this.checkLVal(expr);
    this.next();
    expr = this.finishNode(node, "UpdateExpression");
  }
  return expr;
};

lp.parseExprSubscripts = function () {
  var start = this.storeCurrentPos();
  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
};

lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
  for (;;) {
    if (this.curLineStart != line &amp;&amp; this.curIndent &lt;= startIndent &amp;&amp; this.tokenStartsLine()) {
      if (this.tok.type == tt.dot &amp;&amp; this.curIndent == startIndent) --startIndent;else return base;
    }

    if (this.eat(tt.dot)) {
      var node = this.startNodeAt(start);
      node.object = base;
      if (this.curLineStart != line &amp;&amp; this.curIndent &lt;= startIndent &amp;&amp; this.tokenStartsLine()) node.property = this.dummyIdent();else node.property = this.parsePropertyAccessor() || this.dummyIdent();
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.tok.type == tt.bracketL) {
      this.pushCx();
      this.next();
      var node = this.startNodeAt(start);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.popCx();
      this.expect(tt.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls &amp;&amp; this.tok.type == tt.parenL) {
      var node = this.startNodeAt(start);
      node.callee = base;
      node.arguments = this.parseExprList(tt.parenR);
      base = this.finishNode(node, "CallExpression");
    } else if (this.tok.type == tt.backQuote) {
      var node = this.startNodeAt(start);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

lp.parseExprAtom = function () {
  var node = undefined;
  switch (this.tok.type) {
    case tt._this:
    case tt._super:
      var type = this.tok.type === tt._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case tt.name:
      var start = this.storeCurrentPos();
      var id = this.parseIdent();
      return this.eat(tt.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id]) : id;

    case tt.regexp:
      node = this.startNode();
      var val = this.tok.value;
      node.regex = { pattern: val.pattern, flags: val.flags };
      node.value = val.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case tt.num:case tt.string:
      node = this.startNode();
      node.value = this.tok.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case tt._null:case tt._true:case tt._false:
      node = this.startNode();
      node.value = this.tok.type === tt._null ? null : this.tok.type === tt._true;
      node.raw = this.tok.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case tt.parenL:
      var parenStart = this.storeCurrentPos();
      this.next();
      var inner = this.parseExpression();
      this.expect(tt.parenR);
      if (this.eat(tt.arrow)) {
        return this.parseArrowExpression(this.startNodeAt(parenStart), inner.expressions || (isDummy(inner) ? [] : [inner]));
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(parenStart);
        par.expression = inner;
        inner = this.finishNode(par, "ParenthesizedExpression");
      }
      return inner;

    case tt.bracketL:
      node = this.startNode();
      node.elements = this.parseExprList(tt.bracketR, true);
      return this.finishNode(node, "ArrayExpression");

    case tt.braceL:
      return this.parseObj();

    case tt._class:
      return this.parseClass();

    case tt._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case tt._new:
      return this.parseNew();

    case tt._yield:
      node = this.startNode();
      this.next();
      if (this.semicolon() || this.canInsertSemicolon() || this.tok.type != tt.star &amp;&amp; !this.tok.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(tt.star);
        node.argument = this.parseMaybeAssign();
      }
      return this.finishNode(node, "YieldExpression");

    case tt.backQuote:
      return this.parseTemplate();

    default:
      return this.dummyIdent();
  }
};

lp.parseNew = function () {
  var node = this.startNode(),
      startIndent = this.curIndent,
      line = this.curLineStart;
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.eat(tt.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    return this.finishNode(node, "MetaProperty");
  }
  var start = this.storeCurrentPos();
  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
  if (this.tok.type == tt.parenL) {
    node.arguments = this.parseExprList(tt.parenR);
  } else {
    node.arguments = [];
  }
  return this.finishNode(node, "NewExpression");
};

lp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.tok.start, this.tok.end),
    cooked: this.tok.value
  };
  this.next();
  elem.tail = this.tok.type === tt.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

lp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.next();
    node.expressions.push(this.parseExpression());
    if (this.expect(tt.braceR)) {
      curElt = this.parseTemplateElement();
    } else {
      curElt = this.startNode();
      curElt.value = { cooked: "", raw: "" };
      curElt.tail = true;
    }
    node.quasis.push(curElt);
  }
  this.expect(tt.backQuote);
  return this.finishNode(node, "TemplateLiteral");
};

lp.parseObj = function () {
  var node = this.startNode();
  node.properties = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(tt.braceL);
  if (this.curIndent + 1 &lt; indent) {
    indent = this.curIndent;line = this.curLineStart;
  }
  while (!this.closes(tt.braceR, indent, line)) {
    var prop = this.startNode(),
        isGenerator = undefined,
        start = undefined;
    if (this.options.ecmaVersion &gt;= 6) {
      start = this.storeCurrentPos();
      prop.method = false;
      prop.shorthand = false;
      isGenerator = this.eat(tt.star);
    }
    this.parsePropertyName(prop);
    if (isDummy(prop.key)) {
      if (isDummy(this.parseMaybeAssign())) this.next();this.eat(tt.comma);continue;
    }
    if (this.eat(tt.colon)) {
      prop.kind = "init";
      prop.value = this.parseMaybeAssign();
    } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; (this.tok.type === tt.parenL || this.tok.type === tt.braceL)) {
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator);
    } else if (this.options.ecmaVersion &gt;= 5 &amp;&amp; prop.key.type === "Identifier" &amp;&amp; !prop.computed &amp;&amp; (prop.key.name === "get" || prop.key.name === "set") &amp;&amp; (this.tok.type != tt.comma &amp;&amp; this.tok.type != tt.braceR)) {
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
    } else {
      prop.kind = "init";
      if (this.options.ecmaVersion &gt;= 6) {
        if (this.eat(tt.eq)) {
          var assign = this.startNodeAt(start);
          assign.operator = "=";
          assign.left = prop.key;
          assign.right = this.parseMaybeAssign();
          prop.value = this.finishNode(assign, "AssignmentExpression");
        } else {
          prop.value = prop.key;
        }
      } else {
        prop.value = this.dummyIdent();
      }
      prop.shorthand = true;
    }
    node.properties.push(this.finishNode(prop, "Property"));
    this.eat(tt.comma);
  }
  this.popCx();
  if (!this.eat(tt.braceR)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>If there is no closing brace, make the node span to the start
of the next token (this is useful for Tern)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.last.end = <span class="hljs-keyword">this</span>.tok.start;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) <span class="hljs-keyword">this</span>.last.loc.end = <span class="hljs-keyword">this</span>.tok.loc.start;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ObjectExpression"</span>);
};

lp.parsePropertyName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.bracketL)) {
      prop.computed = <span class="hljs-literal">true</span>;
      prop.key = <span class="hljs-keyword">this</span>.parseExpression();
      <span class="hljs-keyword">this</span>.expect(tt.bracketR);
      <span class="hljs-keyword">return</span>;
    } <span class="hljs-keyword">else</span> {
      prop.computed = <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">var</span> key = <span class="hljs-keyword">this</span>.tok.type === tt.num || <span class="hljs-keyword">this</span>.tok.type === tt.string ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-keyword">this</span>.parseIdent();
  prop.key = key || <span class="hljs-keyword">this</span>.dummyIdent();
};

lp.parsePropertyAccessor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.name || <span class="hljs-keyword">this</span>.tok.type.keyword) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseIdent();
};

lp.parseIdent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> name = <span class="hljs-keyword">this</span>.tok.type === tt.name ? <span class="hljs-keyword">this</span>.tok.value : <span class="hljs-keyword">this</span>.tok.type.keyword;
  <span class="hljs-keyword">if</span> (!name) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dummyIdent();
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.startNode();
  <span class="hljs-keyword">this</span>.next();
  node.name = name;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"Identifier"</span>);
};

lp.initFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  node.id = <span class="hljs-literal">null</span>;
  node.params = [];
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    node.generator = <span class="hljs-literal">false</span>;
    node.expression = <span class="hljs-literal">false</span>;
  }
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Convert existing expression atom to assignable pattern
if possible.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
lp.toAssignable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, binding</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> &amp;&amp; node) {
    <span class="hljs-keyword">switch</span> (node.type) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"ObjectExpression"</span>:
        node.type = <span class="hljs-string">"ObjectPattern"</span>;
        <span class="hljs-keyword">var</span> props = node.properties;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; props.length; i++) {
          <span class="hljs-keyword">this</span>.toAssignable(props[i].value, binding);
        }<span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">"ArrayExpression"</span>:
        node.type = <span class="hljs-string">"ArrayPattern"</span>;
        <span class="hljs-keyword">this</span>.toAssignableList(node.elements, binding);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
        node.type = <span class="hljs-string">"RestElement"</span>;
        node.argument = <span class="hljs-keyword">this</span>.toAssignable(node.argument, binding);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">"AssignmentExpression"</span>:
        node.type = <span class="hljs-string">"AssignmentPattern"</span>;
        <span class="hljs-keyword">break</span>;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.checkLVal(node, binding);
};

lp.toAssignableList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">exprList, binding</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; exprList.length; i++) {
    exprList[i] = <span class="hljs-keyword">this</span>.toAssignable(exprList[i], binding);
  }<span class="hljs-keyword">return</span> exprList;
};

lp.parseFunctionParams = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>{
  params = <span class="hljs-keyword">this</span>.parseExprList(tt.parenR);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toAssignableList(params, <span class="hljs-literal">true</span>);
};

lp.parseMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">isGenerator</span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.startNode();
  <span class="hljs-keyword">this</span>.initFunction(node);
  node.params = <span class="hljs-keyword">this</span>.parseFunctionParams();
  node.generator = isGenerator || <span class="hljs-literal">false</span>;
  node.expression = <span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> &amp;&amp; <span class="hljs-keyword">this</span>.tok.type !== tt.braceL;
  node.body = node.expression ? <span class="hljs-keyword">this</span>.parseMaybeAssign() : <span class="hljs-keyword">this</span>.parseBlock();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"FunctionExpression"</span>);
};

lp.parseArrowExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, params</span>) </span>{
  <span class="hljs-keyword">this</span>.initFunction(node);
  node.params = <span class="hljs-keyword">this</span>.toAssignableList(params, <span class="hljs-literal">true</span>);
  node.expression = <span class="hljs-keyword">this</span>.tok.type !== tt.braceL;
  node.body = node.expression ? <span class="hljs-keyword">this</span>.parseMaybeAssign() : <span class="hljs-keyword">this</span>.parseBlock();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ArrowFunctionExpression"</span>);
};

lp.parseExprList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">close, allowEmpty</span>) </span>{
  <span class="hljs-keyword">this</span>.pushCx();
  <span class="hljs-keyword">var</span> indent = <span class="hljs-keyword">this</span>.curIndent,
      line = <span class="hljs-keyword">this</span>.curLineStart,
      elts = [];
  <span class="hljs-keyword">this</span>.next(); <span class="hljs-comment">// Opening bracket</span>
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(close, indent + <span class="hljs-number">1</span>, line)) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.comma)) {
      elts.push(allowEmpty ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.dummyIdent());
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">var</span> elt = <span class="hljs-keyword">this</span>.parseMaybeAssign();
    <span class="hljs-keyword">if</span> (isDummy(elt)) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.closes(close, indent, line)) <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">this</span>.next();
    } <span class="hljs-keyword">else</span> {
      elts.push(elt);
    }
    <span class="hljs-keyword">this</span>.eat(tt.comma);
  }
  <span class="hljs-keyword">this</span>.popCx();
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.eat(close)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>If there is no closing brace, make the node span to the start
of the next token (this is useful for Tern)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.last.end = <span class="hljs-keyword">this</span>.tok.start;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) <span class="hljs-keyword">this</span>.last.loc.end = <span class="hljs-keyword">this</span>.tok.loc.start;
  }
  <span class="hljs-keyword">return</span> elts;
};

},{<span class="hljs-string">".."</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"./parseutil"</span>:<span class="hljs-number">4</span>,<span class="hljs-string">"./state"</span>:<span class="hljs-number">5</span>}],<span class="hljs-number">4</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_dereq_,module,exports</span>)</span>{
<span class="hljs-meta">"use strict"</span>;

exports.isDummy = isDummy;
exports.__esModule = <span class="hljs-literal">true</span>;

<span class="hljs-keyword">var</span> LooseParser = _dereq_(<span class="hljs-string">"./state"</span>).LooseParser;

<span class="hljs-keyword">var</span> _ = _dereq_(<span class="hljs-string">".."</span>);

<span class="hljs-keyword">var</span> Node = _.Node;
<span class="hljs-keyword">var</span> SourceLocation = _.SourceLocation;
<span class="hljs-keyword">var</span> lineBreak = _.lineBreak;
<span class="hljs-keyword">var</span> isNewLine = _.isNewLine;
<span class="hljs-keyword">var</span> tt = _.tokTypes;

<span class="hljs-keyword">var</span> lp = LooseParser.prototype;

lp.startNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node();
  node.start = <span class="hljs-keyword">this</span>.tok.start;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) node.loc = <span class="hljs-keyword">new</span> SourceLocation(<span class="hljs-keyword">this</span>.toks, <span class="hljs-keyword">this</span>.tok.loc.start);
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.directSourceFile) node.sourceFile = <span class="hljs-keyword">this</span>.options.directSourceFile;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ranges) node.range = [<span class="hljs-keyword">this</span>.tok.start, <span class="hljs-number">0</span>];
  <span class="hljs-keyword">return</span> node;
};

lp.storeCurrentPos = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.options.locations ? [<span class="hljs-keyword">this</span>.tok.start, <span class="hljs-keyword">this</span>.tok.loc.start] : <span class="hljs-keyword">this</span>.tok.start;
};

lp.startNodeAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node();
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) {
    node.start = pos[<span class="hljs-number">0</span>];
    node.loc = <span class="hljs-keyword">new</span> SourceLocation(<span class="hljs-keyword">this</span>.toks, pos[<span class="hljs-number">1</span>]);
    pos = pos[<span class="hljs-number">0</span>];
  } <span class="hljs-keyword">else</span> {
    node.start = pos;
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.directSourceFile) node.sourceFile = <span class="hljs-keyword">this</span>.options.directSourceFile;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ranges) node.range = [pos, <span class="hljs-number">0</span>];
  <span class="hljs-keyword">return</span> node;
};

lp.finishNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, type</span>) </span>{
  node.type = type;
  node.end = <span class="hljs-keyword">this</span>.last.end;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) node.loc.end = <span class="hljs-keyword">this</span>.last.loc.end;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ranges) node.range[<span class="hljs-number">1</span>] = <span class="hljs-keyword">this</span>.last.end;
  <span class="hljs-keyword">return</span> node;
};

lp.dummyIdent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> dummy = <span class="hljs-keyword">this</span>.startNode();
  dummy.name = <span class="hljs-string">"âœ–"</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(dummy, <span class="hljs-string">"Identifier"</span>);
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDummy</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">return</span> node.name == <span class="hljs-string">"âœ–"</span>;
}

lp.eat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === type) {
    <span class="hljs-keyword">this</span>.next();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
};

lp.isContextual = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tok.type === tt.name &amp;&amp; <span class="hljs-keyword">this</span>.tok.value === name;
};

lp.eatContextual = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tok.value === name &amp;&amp; <span class="hljs-keyword">this</span>.eat(tt.name);
};

lp.canInsertSemicolon = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tok.type === tt.eof || <span class="hljs-keyword">this</span>.tok.type === tt.braceR || lineBreak.test(<span class="hljs-keyword">this</span>.input.slice(<span class="hljs-keyword">this</span>.last.end, <span class="hljs-keyword">this</span>.tok.start));
};

lp.semicolon = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.eat(tt.semi);
};

lp.expect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(type)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lookAhead(i).type == type) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {
        <span class="hljs-keyword">this</span>.next();
      }<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }
};

lp.pushCx = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.context.push(<span class="hljs-keyword">this</span>.curIndent);
};
lp.popCx = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.curIndent = <span class="hljs-keyword">this</span>.context.pop();
};

lp.lineEnd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
  <span class="hljs-keyword">while</span> (pos &lt; <span class="hljs-keyword">this</span>.input.length &amp;&amp; !isNewLine(<span class="hljs-keyword">this</span>.input.charCodeAt(pos))) ++pos;
  <span class="hljs-keyword">return</span> pos;
};

lp.indentationAfter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;; ++pos) {
    <span class="hljs-keyword">var</span> ch = <span class="hljs-keyword">this</span>.input.charCodeAt(pos);
    <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">32</span>) ++count;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">9</span>) count += <span class="hljs-keyword">this</span>.options.tabSize;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> count;
  }
};

lp.closes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">closeTok, indent, line, blockHeuristic</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === closeTok || <span class="hljs-keyword">this</span>.tok.type === tt.eof) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> line != <span class="hljs-keyword">this</span>.curLineStart &amp;&amp; <span class="hljs-keyword">this</span>.curIndent &lt; indent &amp;&amp; <span class="hljs-keyword">this</span>.tokenStartsLine() &amp;&amp; (!blockHeuristic || <span class="hljs-keyword">this</span>.nextLineStart &gt;= <span class="hljs-keyword">this</span>.input.length || <span class="hljs-keyword">this</span>.indentationAfter(<span class="hljs-keyword">this</span>.nextLineStart) &lt; indent);
};

lp.tokenStartsLine = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">this</span>.tok.start - <span class="hljs-number">1</span>; p &gt;= <span class="hljs-keyword">this</span>.curLineStart; --p) {
    <span class="hljs-keyword">var</span> ch = <span class="hljs-keyword">this</span>.input.charCodeAt(p);
    <span class="hljs-keyword">if</span> (ch !== <span class="hljs-number">9</span> &amp;&amp; ch !== <span class="hljs-number">32</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

},{<span class="hljs-string">".."</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"./state"</span>:<span class="hljs-number">5</span>}],<span class="hljs-number">5</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_dereq_,module,exports</span>)</span>{
<span class="hljs-meta">"use strict"</span>;

exports.LooseParser = LooseParser;
exports.__esModule = <span class="hljs-literal">true</span>;

<span class="hljs-keyword">var</span> _ = _dereq_(<span class="hljs-string">".."</span>);

<span class="hljs-keyword">var</span> tokenizer = _.tokenizer;
<span class="hljs-keyword">var</span> SourceLocation = _.SourceLocation;
<span class="hljs-keyword">var</span> tt = _.tokTypes;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LooseParser</span>(<span class="hljs-params">input, options</span>) </span>{
  <span class="hljs-keyword">this</span>.toks = tokenizer(input, options);
  <span class="hljs-keyword">this</span>.options = <span class="hljs-keyword">this</span>.toks.options;
  <span class="hljs-keyword">this</span>.input = <span class="hljs-keyword">this</span>.toks.input;
  <span class="hljs-keyword">this</span>.tok = <span class="hljs-keyword">this</span>.last = { <span class="hljs-attr">type</span>: tt.eof, <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">end</span>: <span class="hljs-number">0</span> };
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) {
    <span class="hljs-keyword">var</span> here = <span class="hljs-keyword">this</span>.toks.curPosition();
    <span class="hljs-keyword">this</span>.tok.loc = <span class="hljs-keyword">new</span> SourceLocation(<span class="hljs-keyword">this</span>.toks, here, here);
  }
  <span class="hljs-keyword">this</span>.ahead = []; <span class="hljs-comment">// Tokens ahead</span>
  <span class="hljs-keyword">this</span>.context = []; <span class="hljs-comment">// Indentation contexted</span>
  <span class="hljs-keyword">this</span>.curIndent = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.curLineStart = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.nextLineStart = <span class="hljs-keyword">this</span>.lineEnd(<span class="hljs-keyword">this</span>.curLineStart) + <span class="hljs-number">1</span>;
}

},{<span class="hljs-string">".."</span>:<span class="hljs-number">2</span>}],<span class="hljs-number">6</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_dereq_,module,exports</span>)</span>{
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> LooseParser = _dereq_(<span class="hljs-string">"./state"</span>).LooseParser;

<span class="hljs-keyword">var</span> isDummy = _dereq_(<span class="hljs-string">"./parseutil"</span>).isDummy;

<span class="hljs-keyword">var</span> _ = _dereq_(<span class="hljs-string">".."</span>);

<span class="hljs-keyword">var</span> getLineInfo = _.getLineInfo;
<span class="hljs-keyword">var</span> tt = _.tokTypes;

<span class="hljs-keyword">var</span> lp = LooseParser.prototype;

lp.parseTopLevel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.startNodeAt(<span class="hljs-keyword">this</span>.options.locations ? [<span class="hljs-number">0</span>, getLineInfo(<span class="hljs-keyword">this</span>.input, <span class="hljs-number">0</span>)] : <span class="hljs-number">0</span>);
  node.body = [];
  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.tok.type !== tt.eof) node.body.push(<span class="hljs-keyword">this</span>.parseStatement());
  <span class="hljs-keyword">this</span>.last = <span class="hljs-keyword">this</span>.tok;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    node.sourceType = <span class="hljs-keyword">this</span>.options.sourceType;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"Program"</span>);
};

lp.parseStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> starttype = <span class="hljs-keyword">this</span>.tok.type,
      node = <span class="hljs-keyword">this</span>.startNode();

  <span class="hljs-keyword">switch</span> (starttype) {
    <span class="hljs-keyword">case</span> tt._break:<span class="hljs-keyword">case</span> tt._continue:
      <span class="hljs-keyword">this</span>.next();
      <span class="hljs-keyword">var</span> isBreak = starttype === tt._break;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.semicolon() || <span class="hljs-keyword">this</span>.canInsertSemicolon()) {
        node.label = <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {
        node.label = <span class="hljs-keyword">this</span>.tok.type === tt.name ? <span class="hljs-keyword">this</span>.parseIdent() : <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>.semicolon();
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, isBreak ? <span class="hljs-string">"BreakStatement"</span> : <span class="hljs-string">"ContinueStatement"</span>);

    <span class="hljs-keyword">case</span> tt._debugger:
      <span class="hljs-keyword">this</span>.next();
      <span class="hljs-keyword">this</span>.semicolon();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"DebuggerStatement"</span>);

    <span class="hljs-keyword">case</span> tt._do:
      <span class="hljs-keyword">this</span>.next();
      node.body = <span class="hljs-keyword">this</span>.parseStatement();
      node.test = <span class="hljs-keyword">this</span>.eat(tt._while) ? <span class="hljs-keyword">this</span>.parseParenExpression() : <span class="hljs-keyword">this</span>.dummyIdent();
      <span class="hljs-keyword">this</span>.semicolon();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"DoWhileStatement"</span>);

    <span class="hljs-keyword">case</span> tt._for:
      <span class="hljs-keyword">this</span>.next();
      <span class="hljs-keyword">this</span>.pushCx();
      <span class="hljs-keyword">this</span>.expect(tt.parenL);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.semi) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFor(node, <span class="hljs-literal">null</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt._var || <span class="hljs-keyword">this</span>.tok.type === tt._let || <span class="hljs-keyword">this</span>.tok.type === tt._const) {
        <span class="hljs-keyword">var</span> _init = <span class="hljs-keyword">this</span>.parseVar(<span class="hljs-literal">true</span>);
        <span class="hljs-keyword">if</span> (_init.declarations.length === <span class="hljs-number">1</span> &amp;&amp; (<span class="hljs-keyword">this</span>.tok.type === tt._in || <span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"of"</span>))) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseForIn(node, _init);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFor(node, _init);
      }
      <span class="hljs-keyword">var</span> init = <span class="hljs-keyword">this</span>.parseExpression(<span class="hljs-literal">true</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt._in || <span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"of"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseForIn(node, <span class="hljs-keyword">this</span>.toAssignable(init));
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFor(node, init);

    <span class="hljs-keyword">case</span> tt._function:
      <span class="hljs-keyword">this</span>.next();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFunction(node, <span class="hljs-literal">true</span>);

    <span class="hljs-keyword">case</span> tt._if:
      <span class="hljs-keyword">this</span>.next();
      node.test = <span class="hljs-keyword">this</span>.parseParenExpression();
      node.consequent = <span class="hljs-keyword">this</span>.parseStatement();
      node.alternate = <span class="hljs-keyword">this</span>.eat(tt._else) ? <span class="hljs-keyword">this</span>.parseStatement() : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"IfStatement"</span>);

    <span class="hljs-keyword">case</span> tt._return:
      <span class="hljs-keyword">this</span>.next();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.semi) || <span class="hljs-keyword">this</span>.canInsertSemicolon()) node.argument = <span class="hljs-literal">null</span>;<span class="hljs-keyword">else</span> {
        node.argument = <span class="hljs-keyword">this</span>.parseExpression();<span class="hljs-keyword">this</span>.semicolon();
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ReturnStatement"</span>);

    <span class="hljs-keyword">case</span> tt._switch:
      <span class="hljs-keyword">var</span> blockIndent = <span class="hljs-keyword">this</span>.curIndent,
          line = <span class="hljs-keyword">this</span>.curLineStart;
      <span class="hljs-keyword">this</span>.next();
      node.discriminant = <span class="hljs-keyword">this</span>.parseParenExpression();
      node.cases = [];
      <span class="hljs-keyword">this</span>.pushCx();
      <span class="hljs-keyword">this</span>.expect(tt.braceL);

      <span class="hljs-keyword">var</span> cur = <span class="hljs-literal">undefined</span>;
      <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(tt.braceR, blockIndent, line, <span class="hljs-literal">true</span>)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt._case || <span class="hljs-keyword">this</span>.tok.type === tt._default) {
          <span class="hljs-keyword">var</span> isCase = <span class="hljs-keyword">this</span>.tok.type === tt._case;
          <span class="hljs-keyword">if</span> (cur) <span class="hljs-keyword">this</span>.finishNode(cur, <span class="hljs-string">"SwitchCase"</span>);
          node.cases.push(cur = <span class="hljs-keyword">this</span>.startNode());
          cur.consequent = [];
          <span class="hljs-keyword">this</span>.next();
          <span class="hljs-keyword">if</span> (isCase) cur.test = <span class="hljs-keyword">this</span>.parseExpression();<span class="hljs-keyword">else</span> cur.test = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">this</span>.expect(tt.colon);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (!cur) {
            node.cases.push(cur = <span class="hljs-keyword">this</span>.startNode());
            cur.consequent = [];
            cur.test = <span class="hljs-literal">null</span>;
          }
          cur.consequent.push(<span class="hljs-keyword">this</span>.parseStatement());
        }
      }
      <span class="hljs-keyword">if</span> (cur) <span class="hljs-keyword">this</span>.finishNode(cur, <span class="hljs-string">"SwitchCase"</span>);
      <span class="hljs-keyword">this</span>.popCx();
      <span class="hljs-keyword">this</span>.eat(tt.braceR);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"SwitchStatement"</span>);

    <span class="hljs-keyword">case</span> tt._throw:
      <span class="hljs-keyword">this</span>.next();
      node.argument = <span class="hljs-keyword">this</span>.parseExpression();
      <span class="hljs-keyword">this</span>.semicolon();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ThrowStatement"</span>);

    <span class="hljs-keyword">case</span> tt._try:
      <span class="hljs-keyword">this</span>.next();
      node.block = <span class="hljs-keyword">this</span>.parseBlock();
      node.handler = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt._catch) {
        <span class="hljs-keyword">var</span> clause = <span class="hljs-keyword">this</span>.startNode();
        <span class="hljs-keyword">this</span>.next();
        <span class="hljs-keyword">this</span>.expect(tt.parenL);
        clause.param = <span class="hljs-keyword">this</span>.toAssignable(<span class="hljs-keyword">this</span>.parseExprAtom(), <span class="hljs-literal">true</span>);
        <span class="hljs-keyword">this</span>.expect(tt.parenR);
        clause.guard = <span class="hljs-literal">null</span>;
        clause.body = <span class="hljs-keyword">this</span>.parseBlock();
        node.handler = <span class="hljs-keyword">this</span>.finishNode(clause, <span class="hljs-string">"CatchClause"</span>);
      }
      node.finalizer = <span class="hljs-keyword">this</span>.eat(tt._finally) ? <span class="hljs-keyword">this</span>.parseBlock() : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">if</span> (!node.handler &amp;&amp; !node.finalizer) <span class="hljs-keyword">return</span> node.block;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"TryStatement"</span>);

    <span class="hljs-keyword">case</span> tt._var:
    <span class="hljs-keyword">case</span> tt._let:
    <span class="hljs-keyword">case</span> tt._const:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseVar();

    <span class="hljs-keyword">case</span> tt._while:
      <span class="hljs-keyword">this</span>.next();
      node.test = <span class="hljs-keyword">this</span>.parseParenExpression();
      node.body = <span class="hljs-keyword">this</span>.parseStatement();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"WhileStatement"</span>);

    <span class="hljs-keyword">case</span> tt._with:
      <span class="hljs-keyword">this</span>.next();
      node.object = <span class="hljs-keyword">this</span>.parseParenExpression();
      node.body = <span class="hljs-keyword">this</span>.parseStatement();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"WithStatement"</span>);

    <span class="hljs-keyword">case</span> tt.braceL:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseBlock();

    <span class="hljs-keyword">case</span> tt.semi:
      <span class="hljs-keyword">this</span>.next();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"EmptyStatement"</span>);

    <span class="hljs-keyword">case</span> tt._class:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseClass(<span class="hljs-literal">true</span>);

    <span class="hljs-keyword">case</span> tt._import:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseImport();

    <span class="hljs-keyword">case</span> tt._export:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseExport();

    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">var</span> expr = <span class="hljs-keyword">this</span>.parseExpression();
      <span class="hljs-keyword">if</span> (isDummy(expr)) {
        <span class="hljs-keyword">this</span>.next();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.eof) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"EmptyStatement"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseStatement();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (starttype === tt.name &amp;&amp; expr.type === <span class="hljs-string">"Identifier"</span> &amp;&amp; <span class="hljs-keyword">this</span>.eat(tt.colon)) {
        node.body = <span class="hljs-keyword">this</span>.parseStatement();
        node.label = expr;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"LabeledStatement"</span>);
      } <span class="hljs-keyword">else</span> {
        node.expression = expr;
        <span class="hljs-keyword">this</span>.semicolon();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExpressionStatement"</span>);
      }
  }
};

lp.parseBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.startNode();
  <span class="hljs-keyword">this</span>.pushCx();
  <span class="hljs-keyword">this</span>.expect(tt.braceL);
  <span class="hljs-keyword">var</span> blockIndent = <span class="hljs-keyword">this</span>.curIndent,
      line = <span class="hljs-keyword">this</span>.curLineStart;
  node.body = [];
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(tt.braceR, blockIndent, line, <span class="hljs-literal">true</span>)) node.body.push(<span class="hljs-keyword">this</span>.parseStatement());
  <span class="hljs-keyword">this</span>.popCx();
  <span class="hljs-keyword">this</span>.eat(tt.braceR);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"BlockStatement"</span>);
};

lp.parseFor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, init</span>) </span>{
  node.init = init;
  node.test = node.update = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.semi) &amp;&amp; <span class="hljs-keyword">this</span>.tok.type !== tt.semi) node.test = <span class="hljs-keyword">this</span>.parseExpression();
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.semi) &amp;&amp; <span class="hljs-keyword">this</span>.tok.type !== tt.parenR) node.update = <span class="hljs-keyword">this</span>.parseExpression();
  <span class="hljs-keyword">this</span>.popCx();
  <span class="hljs-keyword">this</span>.expect(tt.parenR);
  node.body = <span class="hljs-keyword">this</span>.parseStatement();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ForStatement"</span>);
};

lp.parseForIn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, init</span>) </span>{
  <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>.tok.type === tt._in ? <span class="hljs-string">"ForInStatement"</span> : <span class="hljs-string">"ForOfStatement"</span>;
  <span class="hljs-keyword">this</span>.next();
  node.left = init;
  node.right = <span class="hljs-keyword">this</span>.parseExpression();
  <span class="hljs-keyword">this</span>.popCx();
  <span class="hljs-keyword">this</span>.expect(tt.parenR);
  node.body = <span class="hljs-keyword">this</span>.parseStatement();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, type);
};

lp.parseVar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">noIn</span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.startNode();
  node.kind = <span class="hljs-keyword">this</span>.tok.type.keyword;
  <span class="hljs-keyword">this</span>.next();
  node.declarations = [];
  <span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">var</span> decl = <span class="hljs-keyword">this</span>.startNode();
    decl.id = <span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> ? <span class="hljs-keyword">this</span>.toAssignable(<span class="hljs-keyword">this</span>.parseExprAtom(), <span class="hljs-literal">true</span>) : <span class="hljs-keyword">this</span>.parseIdent();
    decl.init = <span class="hljs-keyword">this</span>.eat(tt.eq) ? <span class="hljs-keyword">this</span>.parseMaybeAssign(noIn) : <span class="hljs-literal">null</span>;
    node.declarations.push(<span class="hljs-keyword">this</span>.finishNode(decl, <span class="hljs-string">"VariableDeclarator"</span>));
  } <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.eat(tt.comma));
  <span class="hljs-keyword">if</span> (!node.declarations.length) {
    <span class="hljs-keyword">var</span> decl = <span class="hljs-keyword">this</span>.startNode();
    decl.id = <span class="hljs-keyword">this</span>.dummyIdent();
    node.declarations.push(<span class="hljs-keyword">this</span>.finishNode(decl, <span class="hljs-string">"VariableDeclarator"</span>));
  }
  <span class="hljs-keyword">if</span> (!noIn) <span class="hljs-keyword">this</span>.semicolon();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"VariableDeclaration"</span>);
};

lp.parseClass = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">isStatement</span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.startNode();
  <span class="hljs-keyword">this</span>.next();
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.name) node.id = <span class="hljs-keyword">this</span>.parseIdent();<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isStatement) node.id = <span class="hljs-keyword">this</span>.dummyIdent();<span class="hljs-keyword">else</span> node.id = <span class="hljs-literal">null</span>;
  node.superClass = <span class="hljs-keyword">this</span>.eat(tt._extends) ? <span class="hljs-keyword">this</span>.parseExpression() : <span class="hljs-literal">null</span>;
  node.body = <span class="hljs-keyword">this</span>.startNode();
  node.body.body = [];
  <span class="hljs-keyword">this</span>.pushCx();
  <span class="hljs-keyword">var</span> indent = <span class="hljs-keyword">this</span>.curIndent + <span class="hljs-number">1</span>,
      line = <span class="hljs-keyword">this</span>.curLineStart;
  <span class="hljs-keyword">this</span>.eat(tt.braceL);
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curIndent + <span class="hljs-number">1</span> &lt; indent) {
    indent = <span class="hljs-keyword">this</span>.curIndent;line = <span class="hljs-keyword">this</span>.curLineStart;
  }
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(tt.braceR, indent, line)) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.semicolon()) <span class="hljs-keyword">continue</span>;
    <span class="hljs-keyword">var</span> method = <span class="hljs-keyword">this</span>.startNode(),
        isGenerator = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
      method[<span class="hljs-string">"static"</span>] = <span class="hljs-literal">false</span>;
      isGenerator = <span class="hljs-keyword">this</span>.eat(tt.star);
    }
    <span class="hljs-keyword">this</span>.parsePropertyName(method);
    <span class="hljs-keyword">if</span> (isDummy(method.key)) {
      <span class="hljs-keyword">if</span> (isDummy(<span class="hljs-keyword">this</span>.parseMaybeAssign())) <span class="hljs-keyword">this</span>.next();<span class="hljs-keyword">this</span>.eat(tt.comma);<span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">if</span> (method.key.type === <span class="hljs-string">"Identifier"</span> &amp;&amp; !method.computed &amp;&amp; method.key.name === <span class="hljs-string">"static"</span> &amp;&amp; (<span class="hljs-keyword">this</span>.tok.type != tt.parenL &amp;&amp; <span class="hljs-keyword">this</span>.tok.type != tt.braceL)) {
      method[<span class="hljs-string">"static"</span>] = <span class="hljs-literal">true</span>;
      isGenerator = <span class="hljs-keyword">this</span>.eat(tt.star);
      <span class="hljs-keyword">this</span>.parsePropertyName(method);
    } <span class="hljs-keyword">else</span> {
      method[<span class="hljs-string">"static"</span>] = <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">5</span> &amp;&amp; method.key.type === <span class="hljs-string">"Identifier"</span> &amp;&amp; !method.computed &amp;&amp; (method.key.name === <span class="hljs-string">"get"</span> || method.key.name === <span class="hljs-string">"set"</span>) &amp;&amp; <span class="hljs-keyword">this</span>.tok.type !== tt.parenL &amp;&amp; <span class="hljs-keyword">this</span>.tok.type !== tt.braceL) {
      method.kind = method.key.name;
      <span class="hljs-keyword">this</span>.parsePropertyName(method);
      method.value = <span class="hljs-keyword">this</span>.parseMethod(<span class="hljs-literal">false</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (!method.computed &amp;&amp; !method[<span class="hljs-string">"static"</span>] &amp;&amp; !isGenerator &amp;&amp; (method.key.type === <span class="hljs-string">"Identifier"</span> &amp;&amp; method.key.name === <span class="hljs-string">"constructor"</span> || method.key.type === <span class="hljs-string">"Literal"</span> &amp;&amp; method.key.value === <span class="hljs-string">"constructor"</span>)) {
        method.kind = <span class="hljs-string">"constructor"</span>;
      } <span class="hljs-keyword">else</span> {
        method.kind = <span class="hljs-string">"method"</span>;
      }
      method.value = <span class="hljs-keyword">this</span>.parseMethod(isGenerator);
    }
    node.body.body.push(<span class="hljs-keyword">this</span>.finishNode(method, <span class="hljs-string">"MethodDefinition"</span>));
  }
  <span class="hljs-keyword">this</span>.popCx();
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.eat(tt.braceR)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>If there is no closing brace, make the node span to the start
of the next token (this is useful for Tern)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.last.end = <span class="hljs-keyword">this</span>.tok.start;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) <span class="hljs-keyword">this</span>.last.loc.end = <span class="hljs-keyword">this</span>.tok.loc.start;
  }
  <span class="hljs-keyword">this</span>.semicolon();
  <span class="hljs-keyword">this</span>.finishNode(node.body, <span class="hljs-string">"ClassBody"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, isStatement ? <span class="hljs-string">"ClassDeclaration"</span> : <span class="hljs-string">"ClassExpression"</span>);
};

lp.parseFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, isStatement</span>) </span>{
  <span class="hljs-keyword">this</span>.initFunction(node);
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    node.generator = <span class="hljs-keyword">this</span>.eat(tt.star);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.name) node.id = <span class="hljs-keyword">this</span>.parseIdent();<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isStatement) node.id = <span class="hljs-keyword">this</span>.dummyIdent();
  node.params = <span class="hljs-keyword">this</span>.parseFunctionParams();
  node.body = <span class="hljs-keyword">this</span>.parseBlock();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, isStatement ? <span class="hljs-string">"FunctionDeclaration"</span> : <span class="hljs-string">"FunctionExpression"</span>);
};

lp.parseExport = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.startNode();
  <span class="hljs-keyword">this</span>.next();
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.star)) {
    node.source = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"from"</span>) ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExportAllDeclaration"</span>);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt._default)) {
    <span class="hljs-keyword">var</span> expr = <span class="hljs-keyword">this</span>.parseMaybeAssign();
    <span class="hljs-keyword">if</span> (expr.id) {
      <span class="hljs-keyword">switch</span> (expr.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"FunctionExpression"</span>:
          expr.type = <span class="hljs-string">"FunctionDeclaration"</span>;<span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"ClassExpression"</span>:
          expr.type = <span class="hljs-string">"ClassDeclaration"</span>;<span class="hljs-keyword">break</span>;
      }
    }
    node.declaration = expr;
    <span class="hljs-keyword">this</span>.semicolon();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExportDefaultDeclaration"</span>);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type.keyword) {
    node.declaration = <span class="hljs-keyword">this</span>.parseStatement();
    node.specifiers = [];
    node.source = <span class="hljs-literal">null</span>;
  } <span class="hljs-keyword">else</span> {
    node.declaration = <span class="hljs-literal">null</span>;
    node.specifiers = <span class="hljs-keyword">this</span>.parseExportSpecifierList();
    node.source = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"from"</span>) ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.semicolon();
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExportNamedDeclaration"</span>);
};

lp.parseImport = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.startNode();
  <span class="hljs-keyword">this</span>.next();
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.string) {
    node.specifiers = [];
    node.source = <span class="hljs-keyword">this</span>.parseExprAtom();
    node.kind = <span class="hljs-string">""</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> elt = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.name &amp;&amp; <span class="hljs-keyword">this</span>.tok.value !== <span class="hljs-string">"from"</span>) {
      elt = <span class="hljs-keyword">this</span>.startNode();
      elt.local = <span class="hljs-keyword">this</span>.parseIdent();
      <span class="hljs-keyword">this</span>.finishNode(elt, <span class="hljs-string">"ImportDefaultSpecifier"</span>);
      <span class="hljs-keyword">this</span>.eat(tt.comma);
    }
    node.specifiers = <span class="hljs-keyword">this</span>.parseImportSpecifierList();
    node.source = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"from"</span>) ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (elt) node.specifiers.unshift(elt);
  }
  <span class="hljs-keyword">this</span>.semicolon();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ImportDeclaration"</span>);
};

lp.parseImportSpecifierList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> elts = [];
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.star) {
    <span class="hljs-keyword">var</span> elt = <span class="hljs-keyword">this</span>.startNode();
    <span class="hljs-keyword">this</span>.next();
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"as"</span>)) elt.local = <span class="hljs-keyword">this</span>.parseIdent();
    elts.push(<span class="hljs-keyword">this</span>.finishNode(elt, <span class="hljs-string">"ImportNamespaceSpecifier"</span>));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> indent = <span class="hljs-keyword">this</span>.curIndent,
        line = <span class="hljs-keyword">this</span>.curLineStart,
        continuedLine = <span class="hljs-keyword">this</span>.nextLineStart;
    <span class="hljs-keyword">this</span>.pushCx();
    <span class="hljs-keyword">this</span>.eat(tt.braceL);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curLineStart &gt; continuedLine) continuedLine = <span class="hljs-keyword">this</span>.curLineStart;
    <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(tt.braceR, indent + (<span class="hljs-keyword">this</span>.curLineStart &lt;= continuedLine ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), line)) {
      <span class="hljs-keyword">var</span> elt = <span class="hljs-keyword">this</span>.startNode();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.star)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"as"</span>)) elt.local = <span class="hljs-keyword">this</span>.parseIdent();
        <span class="hljs-keyword">this</span>.finishNode(elt, <span class="hljs-string">"ImportNamespaceSpecifier"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"from"</span>)) <span class="hljs-keyword">break</span>;
        elt.imported = <span class="hljs-keyword">this</span>.parseIdent();
        elt.local = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"as"</span>) ? <span class="hljs-keyword">this</span>.parseIdent() : elt.imported;
        <span class="hljs-keyword">this</span>.finishNode(elt, <span class="hljs-string">"ImportSpecifier"</span>);
      }
      elts.push(elt);
      <span class="hljs-keyword">this</span>.eat(tt.comma);
    }
    <span class="hljs-keyword">this</span>.eat(tt.braceR);
    <span class="hljs-keyword">this</span>.popCx();
  }
  <span class="hljs-keyword">return</span> elts;
};

lp.parseExportSpecifierList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> elts = [];
  <span class="hljs-keyword">var</span> indent = <span class="hljs-keyword">this</span>.curIndent,
      line = <span class="hljs-keyword">this</span>.curLineStart,
      continuedLine = <span class="hljs-keyword">this</span>.nextLineStart;
  <span class="hljs-keyword">this</span>.pushCx();
  <span class="hljs-keyword">this</span>.eat(tt.braceL);
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curLineStart &gt; continuedLine) continuedLine = <span class="hljs-keyword">this</span>.curLineStart;
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(tt.braceR, indent + (<span class="hljs-keyword">this</span>.curLineStart &lt;= continuedLine ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), line)) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"from"</span>)) <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">var</span> elt = <span class="hljs-keyword">this</span>.startNode();
    elt.local = <span class="hljs-keyword">this</span>.parseIdent();
    elt.exported = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"as"</span>) ? <span class="hljs-keyword">this</span>.parseIdent() : elt.local;
    <span class="hljs-keyword">this</span>.finishNode(elt, <span class="hljs-string">"ExportSpecifier"</span>);
    elts.push(elt);
    <span class="hljs-keyword">this</span>.eat(tt.comma);
  }
  <span class="hljs-keyword">this</span>.eat(tt.braceR);
  <span class="hljs-keyword">this</span>.popCx();
  <span class="hljs-keyword">return</span> elts;
};

},{<span class="hljs-string">".."</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"./parseutil"</span>:<span class="hljs-number">4</span>,<span class="hljs-string">"./state"</span>:<span class="hljs-number">5</span>}],<span class="hljs-number">7</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_dereq_,module,exports</span>)</span>{
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> _ = _dereq_(<span class="hljs-string">".."</span>);

<span class="hljs-keyword">var</span> tt = _.tokTypes;
<span class="hljs-keyword">var</span> Token = _.Token;
<span class="hljs-keyword">var</span> isNewLine = _.isNewLine;
<span class="hljs-keyword">var</span> SourceLocation = _.SourceLocation;
<span class="hljs-keyword">var</span> getLineInfo = _.getLineInfo;
<span class="hljs-keyword">var</span> lineBreakG = _.lineBreakG;

<span class="hljs-keyword">var</span> LooseParser = _dereq_(<span class="hljs-string">"./state"</span>).LooseParser;

<span class="hljs-keyword">var</span> lp = LooseParser.prototype;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSpace</span>(<span class="hljs-params">ch</span>) </span>{
  <span class="hljs-keyword">return</span> ch &lt; <span class="hljs-number">14</span> &amp;&amp; ch &gt; <span class="hljs-number">8</span> || ch === <span class="hljs-number">32</span> || ch === <span class="hljs-number">160</span> || isNewLine(ch);
}

lp.next = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.last = <span class="hljs-keyword">this</span>.tok;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ahead.length) <span class="hljs-keyword">this</span>.tok = <span class="hljs-keyword">this</span>.ahead.shift();<span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span>.tok = <span class="hljs-keyword">this</span>.readToken();

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.start &gt;= <span class="hljs-keyword">this</span>.nextLineStart) {
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.tok.start &gt;= <span class="hljs-keyword">this</span>.nextLineStart) {
      <span class="hljs-keyword">this</span>.curLineStart = <span class="hljs-keyword">this</span>.nextLineStart;
      <span class="hljs-keyword">this</span>.nextLineStart = <span class="hljs-keyword">this</span>.lineEnd(<span class="hljs-keyword">this</span>.curLineStart) + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">this</span>.curIndent = <span class="hljs-keyword">this</span>.indentationAfter(<span class="hljs-keyword">this</span>.curLineStart);
  }
};

lp.readToken = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (;;) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">this</span>.toks.next();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.toks.type === tt.dot &amp;&amp; <span class="hljs-keyword">this</span>.input.substr(<span class="hljs-keyword">this</span>.toks.end, <span class="hljs-number">1</span>) === <span class="hljs-string">"."</span> &amp;&amp; <span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
        <span class="hljs-keyword">this</span>.toks.end++;
        <span class="hljs-keyword">this</span>.toks.type = tt.ellipsis;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Token(<span class="hljs-keyword">this</span>.toks);
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span>)) <span class="hljs-keyword">throw</span> e;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Try to skip some text, based on the error message, and then continue</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> msg = e.message,
          pos = e.raisedAt,
          replace = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/unterminated/i</span>.test(msg)) {
        pos = <span class="hljs-keyword">this</span>.lineEnd(e.pos + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/string/</span>.test(msg)) {
          replace = { <span class="hljs-attr">start</span>: e.pos, <span class="hljs-attr">end</span>: pos, <span class="hljs-attr">type</span>: tt.string, <span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>.input.slice(e.pos + <span class="hljs-number">1</span>, pos) };
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/regular expr/i</span>.test(msg)) {
          <span class="hljs-keyword">var</span> re = <span class="hljs-keyword">this</span>.input.slice(e.pos, pos);
          <span class="hljs-keyword">try</span> {
            re = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(re);
          } <span class="hljs-keyword">catch</span> (e) {}
          replace = { <span class="hljs-attr">start</span>: e.pos, <span class="hljs-attr">end</span>: pos, <span class="hljs-attr">type</span>: tt.regexp, <span class="hljs-attr">value</span>: re };
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/template/</span>.test(msg)) {
          replace = { <span class="hljs-attr">start</span>: e.pos, <span class="hljs-attr">end</span>: pos,
            <span class="hljs-attr">type</span>: tt.template,
            <span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>.input.slice(e.pos, pos) };
        } <span class="hljs-keyword">else</span> {
          replace = <span class="hljs-literal">false</span>;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i</span>.test(msg)) {
        <span class="hljs-keyword">while</span> (pos &lt; <span class="hljs-keyword">this</span>.input.length &amp;&amp; !isSpace(<span class="hljs-keyword">this</span>.input.charCodeAt(pos))) ++pos;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/character escape|expected hexadecimal/i</span>.test(msg)) {
        <span class="hljs-keyword">while</span> (pos &lt; <span class="hljs-keyword">this</span>.input.length) {
          <span class="hljs-keyword">var</span> ch = <span class="hljs-keyword">this</span>.input.charCodeAt(pos++);
          <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">34</span> || ch === <span class="hljs-number">39</span> || isNewLine(ch)) <span class="hljs-keyword">break</span>;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/unexpected character/i</span>.test(msg)) {
        pos++;
        replace = <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/regular expression/i</span>.test(msg)) {
        replace = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> e;
      }
      <span class="hljs-keyword">this</span>.resetTo(pos);
      <span class="hljs-keyword">if</span> (replace === <span class="hljs-literal">true</span>) replace = { <span class="hljs-attr">start</span>: pos, <span class="hljs-attr">end</span>: pos, <span class="hljs-attr">type</span>: tt.name, <span class="hljs-attr">value</span>: <span class="hljs-string">"âœ–"</span> };
      <span class="hljs-keyword">if</span> (replace) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) replace.loc = <span class="hljs-keyword">new</span> SourceLocation(<span class="hljs-keyword">this</span>.toks, getLineInfo(<span class="hljs-keyword">this</span>.input, replace.start), getLineInfo(<span class="hljs-keyword">this</span>.input, replace.end));
        <span class="hljs-keyword">return</span> replace;
      }
    }
  }
};

lp.resetTo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
  <span class="hljs-keyword">this</span>.toks.pos = pos;
  <span class="hljs-keyword">var</span> ch = <span class="hljs-keyword">this</span>.input.charAt(pos - <span class="hljs-number">1</span>);
  <span class="hljs-keyword">this</span>.toks.exprAllowed = !ch || <span class="hljs-regexp">/[\[\{\(,;:?\/*=+\-~!|&amp;%^&lt;&gt;]/</span>.test(ch) || <span class="hljs-regexp">/[enwfd]/</span>.test(ch) &amp;&amp; <span class="hljs-regexp">/\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/</span>.test(<span class="hljs-keyword">this</span>.input.slice(pos - <span class="hljs-number">10</span>, pos));

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) {
    <span class="hljs-keyword">this</span>.toks.curLine = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">this</span>.toks.lineStart = lineBreakG.lastIndex = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> match = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">while</span> ((match = lineBreakG.exec(<span class="hljs-keyword">this</span>.input)) &amp;&amp; match.index &lt; pos) {
      ++<span class="hljs-keyword">this</span>.toks.curLine;
      <span class="hljs-keyword">this</span>.toks.lineStart = match.index + match[<span class="hljs-number">0</span>].length;
    }
  }
};

lp.lookAhead = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-keyword">this</span>.ahead.length) <span class="hljs-keyword">this</span>.ahead.push(<span class="hljs-keyword">this</span>.readToken());
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ahead[n - <span class="hljs-number">1</span>];
};

},{<span class="hljs-string">".."</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"./state"</span>:<span class="hljs-number">5</span>}]},{},[<span class="hljs-number">1</span>])(<span class="hljs-number">1</span>)
});
</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
