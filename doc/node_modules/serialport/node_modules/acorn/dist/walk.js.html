<!DOCTYPE html>
<html>
<head>
  <title>walk.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/acorn/dist/walk.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>walk.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>)</span>{<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> exports===<span class="hljs-string">"object"</span>&amp;&amp;<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span>!==<span class="hljs-string">"undefined"</span>){<span class="hljs-built_in">module</span>.exports=f()}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> define===<span class="hljs-string">"function"</span>&amp;&amp;define.amd){define([],f)}<span class="hljs-keyword">else</span>{<span class="hljs-keyword">var</span> g;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>!==<span class="hljs-string">"undefined"</span>){g=<span class="hljs-built_in">window</span>}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> global!==<span class="hljs-string">"undefined"</span>){g=global}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> self!==<span class="hljs-string">"undefined"</span>){g=self}<span class="hljs-keyword">else</span>{g=<span class="hljs-keyword">this</span>}(g.acorn || (g.acorn = {})).walk = f()}})(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">var</span> define,<span class="hljs-built_in">module</span>,exports;<span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">t,n,r</span>)</span>{<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params">o,u</span>)</span>{<span class="hljs-keyword">if</span>(!n[o]){<span class="hljs-keyword">if</span>(!t[o]){<span class="hljs-keyword">var</span> a=<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span>==<span class="hljs-string">"function"</span>&amp;&amp;<span class="hljs-built_in">require</span>;<span class="hljs-keyword">if</span>(!u&amp;&amp;a)<span class="hljs-keyword">return</span> a(o,!<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(i)<span class="hljs-keyword">return</span> i(o,!<span class="hljs-number">0</span>);<span class="hljs-keyword">var</span> f=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cannot find module '"</span>+o+<span class="hljs-string">"'"</span>);<span class="hljs-keyword">throw</span> f.code=<span class="hljs-string">"MODULE_NOT_FOUND"</span>,f}<span class="hljs-keyword">var</span> l=n[o]={<span class="hljs-attr">exports</span>:{}};t[o][<span class="hljs-number">0</span>].call(l.exports,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{<span class="hljs-keyword">var</span> n=t[o][<span class="hljs-number">1</span>][e];<span class="hljs-keyword">return</span> s(n?n:e)},l,l.exports,e,t,n,r)}<span class="hljs-keyword">return</span> n[o].exports}<span class="hljs-keyword">var</span> i=<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span>==<span class="hljs-string">"function"</span>&amp;&amp;<span class="hljs-built_in">require</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> o=<span class="hljs-number">0</span>;o&lt;r.length;o++)s(r[o]);<span class="hljs-keyword">return</span> s})({<span class="hljs-number">1</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_dereq_,module,exports</span>)</span>{
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> _classCallCheck = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">instance, Constructor</span>) </span>{ <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> Constructor)) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Cannot call a class as a function"</span>); } };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>AST walker module for Mozilla Parser API compatible trees</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>A simple walk is one where you simply specify callbacks to be
called on specific nodes. The last two arguments are optional. A
simple use would be</p>
<pre><code>walk.simple(myTree, {
    Expression: function(node) { ... }
});
</code></pre>
<p>to do something with all expressions. All Parser API node types
can be used to identify node types, as well as Expression,
Statement, and ScopeBody, which denote categories of nodes.</p>
<p>The base argument can be used to pass a custom (recursive)
walker, and state can be used to give this walked an initial
state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
exports.simple = simple;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>An ancestor walk builds up an array of ancestor nodes (including
the current node) and passes them to the callback as the state parameter.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.ancestor = ancestor;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>A recursive walk is one where your functions override the default
walkers. They can modify and replace the state parameter that's
threaded through the walk, and can opt how and whether to walk
their child nodes (by calling their third argument on these
nodes).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.recursive = recursive;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Find a node with a given start, end, and type (all are optional,
null can be used as wildcard). Returns a {node, state} object, or
undefined when it doesn't find a matching node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.findNodeAt = findNodeAt;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Find the innermost node of a given type that contains the given
position. Interface similar to findNodeAt.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.findNodeAround = findNodeAround;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Find the outermost matching node after a given position.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.findNodeAfter = findNodeAfter;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Find the outermost matching node before a given position.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.findNodeBefore = findNodeBefore;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Used to create a custom walker. Will fill in all missing node
type properties with the defaults.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.make = make;
exports.__esModule = <span class="hljs-literal">true</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">simple</span>(<span class="hljs-params">node, visitors, base, state</span>) </span>{
  <span class="hljs-keyword">if</span> (!base) base = exports.base;(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">node, st, override</span>) </span>{
    <span class="hljs-keyword">var</span> type = override || node.type,
        found = visitors[type];
    base[type](node, st, c);
    <span class="hljs-keyword">if</span> (found) found(node, st);
  })(node, state);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ancestor</span>(<span class="hljs-params">node, visitors, base, state</span>) </span>{
  <span class="hljs-keyword">if</span> (!base) base = exports.base;
  <span class="hljs-keyword">if</span> (!state) state = [];(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">node, st, override</span>) </span>{
    <span class="hljs-keyword">var</span> type = override || node.type,
        found = visitors[type];
    <span class="hljs-keyword">if</span> (node != st[st.length - <span class="hljs-number">1</span>]) {
      st = st.slice();
      st.push(node);
    }
    base[type](node, st, c);
    <span class="hljs-keyword">if</span> (found) found(node, st);
  })(node, state);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursive</span>(<span class="hljs-params">node, state, funcs, base</span>) </span>{
  <span class="hljs-keyword">var</span> visitor = funcs ? exports.make(funcs, base) : base;(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">node, st, override</span>) </span>{
    visitor[override || node.type](node, st, c);
  })(node, state);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeTest</span>(<span class="hljs-params">test</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> test == <span class="hljs-string">"string"</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">return</span> type == test;
    };
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!test) {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> test;
  }
}

<span class="hljs-keyword">var</span> Found = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Found</span>(<span class="hljs-params">node, state</span>) </span>{
  _classCallCheck(<span class="hljs-keyword">this</span>, Found);

  <span class="hljs-keyword">this</span>.node = node;<span class="hljs-keyword">this</span>.state = state;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNodeAt</span>(<span class="hljs-params">node, start, end, test, base, state</span>) </span>{
  test = makeTest(test);
  <span class="hljs-keyword">if</span> (!base) base = exports.base;
  <span class="hljs-keyword">try</span> {
    ;(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">node, st, override</span>) </span>{
      <span class="hljs-keyword">var</span> type = override || node.type;
      <span class="hljs-keyword">if</span> ((start == <span class="hljs-literal">null</span> || node.start &lt;= start) &amp;&amp; (end == <span class="hljs-literal">null</span> || node.end &gt;= end)) base[type](node, st, c);
      <span class="hljs-keyword">if</span> (test(type, node) &amp;&amp; (start == <span class="hljs-literal">null</span> || node.start == start) &amp;&amp; (end == <span class="hljs-literal">null</span> || node.end == end)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Found(node, st);
    })(node, state);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> Found) {
      <span class="hljs-keyword">return</span> e;
    }<span class="hljs-keyword">throw</span> e;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNodeAround</span>(<span class="hljs-params">node, pos, test, base, state</span>) </span>{
  test = makeTest(test);
  <span class="hljs-keyword">if</span> (!base) base = exports.base;
  <span class="hljs-keyword">try</span> {
    ;(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">node, st, override</span>) </span>{
      <span class="hljs-keyword">var</span> type = override || node.type;
      <span class="hljs-keyword">if</span> (node.start &gt; pos || node.end &lt; pos) {
        <span class="hljs-keyword">return</span>;
      }base[type](node, st, c);
      <span class="hljs-keyword">if</span> (test(type, node)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Found(node, st);
    })(node, state);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> Found) {
      <span class="hljs-keyword">return</span> e;
    }<span class="hljs-keyword">throw</span> e;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNodeAfter</span>(<span class="hljs-params">node, pos, test, base, state</span>) </span>{
  test = makeTest(test);
  <span class="hljs-keyword">if</span> (!base) base = exports.base;
  <span class="hljs-keyword">try</span> {
    ;(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">node, st, override</span>) </span>{
      <span class="hljs-keyword">if</span> (node.end &lt; pos) {
        <span class="hljs-keyword">return</span>;
      }<span class="hljs-keyword">var</span> type = override || node.type;
      <span class="hljs-keyword">if</span> (node.start &gt;= pos &amp;&amp; test(type, node)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Found(node, st);
      base[type](node, st, c);
    })(node, state);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> Found) {
      <span class="hljs-keyword">return</span> e;
    }<span class="hljs-keyword">throw</span> e;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNodeBefore</span>(<span class="hljs-params">node, pos, test, base, state</span>) </span>{
  test = makeTest(test);
  <span class="hljs-keyword">if</span> (!base) base = exports.base;
  <span class="hljs-keyword">var</span> max = <span class="hljs-literal">undefined</span>;(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">node, st, override</span>) </span>{
    <span class="hljs-keyword">if</span> (node.start &gt; pos) {
      <span class="hljs-keyword">return</span>;
    }<span class="hljs-keyword">var</span> type = override || node.type;
    <span class="hljs-keyword">if</span> (node.end &lt;= pos &amp;&amp; (!max || max.node.end &lt; node.end) &amp;&amp; test(type, node)) max = <span class="hljs-keyword">new</span> Found(node, st);
    base[type](node, st, c);
  })(node, state);
  <span class="hljs-keyword">return</span> max;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make</span>(<span class="hljs-params">funcs, base</span>) </span>{
  <span class="hljs-keyword">if</span> (!base) base = exports.base;
  <span class="hljs-keyword">var</span> visitor = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> type <span class="hljs-keyword">in</span> base) visitor[type] = base[type];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> type <span class="hljs-keyword">in</span> funcs) visitor[type] = funcs[type];
  <span class="hljs-keyword">return</span> visitor;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipThrough</span>(<span class="hljs-params">node, st, c</span>) </span>{
  c(node, st);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ignore</span>(<span class="hljs-params">_node, _st, _c</span>) </span>{}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Node walkers.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-keyword">var</span> base = {};

exports.base = base;
base.Program = base.BlockStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.body.length; ++i) {
    c(node.body[i], st, <span class="hljs-string">"Statement"</span>);
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">return</span> c(node.expression, st, <span class="hljs-string">"Expression"</span>);
};
base.IfStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.test, st, <span class="hljs-string">"Expression"</span>);
  c(node.consequent, st, <span class="hljs-string">"Statement"</span>);
  <span class="hljs-keyword">if</span> (node.alternate) c(node.alternate, st, <span class="hljs-string">"Statement"</span>);
};
base.LabeledStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">return</span> c(node.body, st, <span class="hljs-string">"Statement"</span>);
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.object, st, <span class="hljs-string">"Expression"</span>);
  c(node.body, st, <span class="hljs-string">"Statement"</span>);
};
base.SwitchStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.discriminant, st, <span class="hljs-string">"Expression"</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.cases.length; ++i) {
    <span class="hljs-keyword">var</span> cs = node.cases[i];
    <span class="hljs-keyword">if</span> (cs.test) c(cs.test, st, <span class="hljs-string">"Expression"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; cs.consequent.length; ++j) {
      c(cs.consequent[j], st, <span class="hljs-string">"Statement"</span>);
    }
  }
};
base.ReturnStatement = base.YieldExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">if</span> (node.argument) c(node.argument, st, <span class="hljs-string">"Expression"</span>);
};
base.ThrowStatement = base.SpreadElement = base.RestElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">return</span> c(node.argument, st, <span class="hljs-string">"Expression"</span>);
};
base.TryStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.block, st, <span class="hljs-string">"Statement"</span>);
  <span class="hljs-keyword">if</span> (node.handler) c(node.handler.body, st, <span class="hljs-string">"ScopeBody"</span>);
  <span class="hljs-keyword">if</span> (node.finalizer) c(node.finalizer, st, <span class="hljs-string">"Statement"</span>);
};
base.WhileStatement = base.DoWhileStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.test, st, <span class="hljs-string">"Expression"</span>);
  c(node.body, st, <span class="hljs-string">"Statement"</span>);
};
base.ForStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">if</span> (node.init) c(node.init, st, <span class="hljs-string">"ForInit"</span>);
  <span class="hljs-keyword">if</span> (node.test) c(node.test, st, <span class="hljs-string">"Expression"</span>);
  <span class="hljs-keyword">if</span> (node.update) c(node.update, st, <span class="hljs-string">"Expression"</span>);
  c(node.body, st, <span class="hljs-string">"Statement"</span>);
};
base.ForInStatement = base.ForOfStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.left, st, <span class="hljs-string">"ForInit"</span>);
  c(node.right, st, <span class="hljs-string">"Expression"</span>);
  c(node.body, st, <span class="hljs-string">"Statement"</span>);
};
base.ForInit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">if</span> (node.type == <span class="hljs-string">"VariableDeclaration"</span>) c(node, st);<span class="hljs-keyword">else</span> c(node, st, <span class="hljs-string">"Expression"</span>);
};
base.DebuggerStatement = ignore;

base.FunctionDeclaration = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">return</span> c(node, st, <span class="hljs-string">"Function"</span>);
};
base.VariableDeclaration = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.declarations.length; ++i) {
    <span class="hljs-keyword">var</span> decl = node.declarations[i];
    <span class="hljs-keyword">if</span> (decl.init) c(decl.init, st, <span class="hljs-string">"Expression"</span>);
  }
};

base.Function = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">return</span> c(node.body, st, <span class="hljs-string">"ScopeBody"</span>);
};
base.ScopeBody = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">return</span> c(node, st, <span class="hljs-string">"Statement"</span>);
};

base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = base.ArrayPattern = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.elements.length; ++i) {
    <span class="hljs-keyword">var</span> elt = node.elements[i];
    <span class="hljs-keyword">if</span> (elt) c(elt, st, <span class="hljs-string">"Expression"</span>);
  }
};
base.ObjectExpression = base.ObjectPattern = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.properties.length; ++i) {
    c(node.properties[i], st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = base.TemplateLiteral = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.expressions.length; ++i) {
    c(node.expressions[i], st, <span class="hljs-string">"Expression"</span>);
  }
};
base.UnaryExpression = base.UpdateExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.argument, st, <span class="hljs-string">"Expression"</span>);
};
base.BinaryExpression = base.AssignmentExpression = base.AssignmentPattern = base.LogicalExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.left, st, <span class="hljs-string">"Expression"</span>);
  c(node.right, st, <span class="hljs-string">"Expression"</span>);
};
base.ConditionalExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.test, st, <span class="hljs-string">"Expression"</span>);
  c(node.consequent, st, <span class="hljs-string">"Expression"</span>);
  c(node.alternate, st, <span class="hljs-string">"Expression"</span>);
};
base.NewExpression = base.CallExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.callee, st, <span class="hljs-string">"Expression"</span>);
  <span class="hljs-keyword">if</span> (node.arguments) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.arguments.length; ++i) {
    c(node.arguments[i], st, <span class="hljs-string">"Expression"</span>);
  }
};
base.MemberExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.object, st, <span class="hljs-string">"Expression"</span>);
  <span class="hljs-keyword">if</span> (node.computed) c(node.property, st, <span class="hljs-string">"Expression"</span>);
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">return</span> c(node.declaration, st);
};
base.ImportDeclaration = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.specifiers.length; i++) {
    c(node.specifiers[i], st);
  }
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

base.TaggedTemplateExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  c(node.tag, st, <span class="hljs-string">"Expression"</span>);
  c(node.quasi, st);
};
base.ClassDeclaration = base.ClassExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">if</span> (node.superClass) c(node.superClass, st, <span class="hljs-string">"Expression"</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.body.body.length; i++) {
    c(node.body.body[i], st);
  }
};
base.MethodDefinition = base.Property = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">if</span> (node.computed) c(node.key, st, <span class="hljs-string">"Expression"</span>);
  c(node.value, st, <span class="hljs-string">"Expression"</span>);
};
base.ComprehensionExpression = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, st, c</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.blocks.length; i++) {
    c(node.blocks[i].right, st, <span class="hljs-string">"Expression"</span>);
  }c(node.body, st, <span class="hljs-string">"Expression"</span>);
};

},{}]},{},[<span class="hljs-number">1</span>])(<span class="hljs-number">1</span>)
});
</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
