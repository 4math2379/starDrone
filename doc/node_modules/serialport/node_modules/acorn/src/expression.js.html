<!DOCTYPE html>
<html>
<head>
  <title>expression.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/acorn/src/expression.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h3">
        <a href="#expression-parsing">Expression parsing</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>expression.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<p>A recursive descent parser operates by defining functions for all
syntactic elements, and recursively calling those, each function
advancing the input stream and returning an AST node. Precedence
of constructs (for example, the fact that <code>!x[1]</code> means <code>!(x[1])</code>
instead of <code>(!x)[1]</code> is handled by the fact that the parser
function that parses unary prefix operators is called first, and
in turn calls the function that parses <code>[]</code> subscripts — that
way, it'll receive the node for <code>x[1]</code> already parsed, and wraps
<em>that</em> in the unary operator node.</p>
<p>Acorn uses an <a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">operator precedence parser</a> to handle binary
operator precedence, because it is much more compact than using
the technique outlined above, which uses different, nesting
functions to specify precedence, for all of the ten binary
precedence levels that JavaScript defines.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-keyword">import</span> {types <span class="hljs-keyword">as</span> tt} <span class="hljs-keyword">from</span> <span class="hljs-string">"./tokentype"</span>
<span class="hljs-keyword">import</span> {Parser} <span class="hljs-keyword">from</span> <span class="hljs-string">"./state"</span>
<span class="hljs-keyword">import</span> {reservedWords} <span class="hljs-keyword">from</span> <span class="hljs-string">"./identifier"</span>
<span class="hljs-keyword">import</span> {has} <span class="hljs-keyword">from</span> <span class="hljs-string">"./util"</span>

<span class="hljs-keyword">const</span> pp = Parser.prototype

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Check if property name clashes with already added.
Object/class getters and setters are not allowed to clash —
either with each other or with an init property — and in
strict mode, init properties are also not allowed to be repeated.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.checkPropClash = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop, propHash</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">let</span> key = prop.key, name
  <span class="hljs-keyword">switch</span> (key.type) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">"Identifier"</span>: name = key.name; <span class="hljs-keyword">break</span>
  <span class="hljs-keyword">case</span> <span class="hljs-string">"Literal"</span>: name = <span class="hljs-built_in">String</span>(key.value); <span class="hljs-keyword">break</span>
  <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span>
  }
  <span class="hljs-keyword">let</span> kind = prop.kind || <span class="hljs-string">"init"</span>, other
  <span class="hljs-keyword">if</span> (has(propHash, name)) {
    other = propHash[name]
    <span class="hljs-keyword">let</span> isGetSet = kind !== <span class="hljs-string">"init"</span>
    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.strict || isGetSet) &amp;&amp; other[kind] || !(isGetSet ^ other.init))
      <span class="hljs-keyword">this</span>.raise(key.start, <span class="hljs-string">"Redefinition of property"</span>)
  } <span class="hljs-keyword">else</span> {
    other = propHash[name] = {
      <span class="hljs-attr">init</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">get</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">set</span>: <span class="hljs-literal">false</span>
    }
  }
  other[kind] = <span class="hljs-literal">true</span>
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="expression-parsing">
  <h3>
    <a href="#expression-parsing" name="expression-parsing" class="pilcrow"></a>
Expression parsing
  </h3>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>These nest, from the most general expression type at the top to
'atomic', nondivisible expression types at the bottom. Most of
the functions will simply let the function(s) below them parse,
and, <em>if</em> the syntactic construct they handle is present, wrap
the AST node that the inner parser gave them in another node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Parse a full expression. The optional arguments are used to
forbid the <code>in</code> operator (in for loops initalization expressions)
and provide reference for storing '=' operator inside shorthand
property assignment in contexts where both object expression
and object pattern might appear (so it's possible to raise
delayed syntax error at correct position).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseExpression = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">noIn, refShorthandDefaultPos</span>) </span>{
  <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc
  <span class="hljs-keyword">let</span> expr = <span class="hljs-keyword">this</span>.parseMaybeAssign(noIn, refShorthandDefaultPos)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.comma) {
    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc)
    node.expressions = [expr]
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.eat(tt.comma)) node.expressions.push(<span class="hljs-keyword">this</span>.parseMaybeAssign(noIn, refShorthandDefaultPos))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"SequenceExpression"</span>)
  }
  <span class="hljs-keyword">return</span> expr
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Parse an assignment expression. This includes applications of
operators like <code>+=</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseMaybeAssign = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">noIn, refShorthandDefaultPos, afterLeftParse</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type == tt._yield &amp;&amp; <span class="hljs-keyword">this</span>.inGenerator) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseYield()

  <span class="hljs-keyword">let</span> failOnShorthandAssign
  <span class="hljs-keyword">if</span> (!refShorthandDefaultPos) {
    refShorthandDefaultPos = {<span class="hljs-attr">start</span>: <span class="hljs-number">0</span>}
    failOnShorthandAssign = <span class="hljs-literal">true</span>
  } <span class="hljs-keyword">else</span> {
    failOnShorthandAssign = <span class="hljs-literal">false</span>
  }
  <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type == tt.parenL || <span class="hljs-keyword">this</span>.type == tt.name)
    <span class="hljs-keyword">this</span>.potentialArrowAt = <span class="hljs-keyword">this</span>.start
  <span class="hljs-keyword">let</span> left = <span class="hljs-keyword">this</span>.parseMaybeConditional(noIn, refShorthandDefaultPos)
  <span class="hljs-keyword">if</span> (afterLeftParse) left = afterLeftParse.call(<span class="hljs-keyword">this</span>, left, startPos, startLoc)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type.isAssign) {
    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc)
    node.operator = <span class="hljs-keyword">this</span>.value
    node.left = <span class="hljs-keyword">this</span>.type === tt.eq ? <span class="hljs-keyword">this</span>.toAssignable(left) : left
    refShorthandDefaultPos.start = <span class="hljs-number">0</span> <span class="hljs-comment">// reset because shorthand default was used correctly</span>
    <span class="hljs-keyword">this</span>.checkLVal(left)
    <span class="hljs-keyword">this</span>.next()
    node.right = <span class="hljs-keyword">this</span>.parseMaybeAssign(noIn)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"AssignmentExpression"</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failOnShorthandAssign &amp;&amp; refShorthandDefaultPos.start) {
    <span class="hljs-keyword">this</span>.unexpected(refShorthandDefaultPos.start)
  }
  <span class="hljs-keyword">return</span> left
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Parse a ternary conditional (<code>?:</code>) operator.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseMaybeConditional = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">noIn, refShorthandDefaultPos</span>) </span>{
  <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc
  <span class="hljs-keyword">let</span> expr = <span class="hljs-keyword">this</span>.parseExprOps(noIn, refShorthandDefaultPos)
  <span class="hljs-keyword">if</span> (refShorthandDefaultPos &amp;&amp; refShorthandDefaultPos.start) <span class="hljs-keyword">return</span> expr
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.question)) {
    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc)
    node.test = expr
    node.consequent = <span class="hljs-keyword">this</span>.parseMaybeAssign()
    <span class="hljs-keyword">this</span>.expect(tt.colon)
    node.alternate = <span class="hljs-keyword">this</span>.parseMaybeAssign(noIn)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ConditionalExpression"</span>)
  }
  <span class="hljs-keyword">return</span> expr
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Start the precedence parser.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseExprOps = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">noIn, refShorthandDefaultPos</span>) </span>{
  <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc
  <span class="hljs-keyword">let</span> expr = <span class="hljs-keyword">this</span>.parseMaybeUnary(refShorthandDefaultPos)
  <span class="hljs-keyword">if</span> (refShorthandDefaultPos &amp;&amp; refShorthandDefaultPos.start) <span class="hljs-keyword">return</span> expr
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseExprOp(expr, startPos, startLoc, <span class="hljs-number">-1</span>, noIn)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Parse binary operators with the operator precedence parsing
algorithm. <code>left</code> is the left-hand side of the operator.
<code>minPrec</code> provides context that allows the function to stop and
defer further parser to one of its callers when it encounters an
operator that has a lower precedence than the set it is parsing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseExprOp = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">left, leftStartPos, leftStartLoc, minPrec, noIn</span>) </span>{
  <span class="hljs-keyword">let</span> prec = <span class="hljs-keyword">this</span>.type.binop
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(leftStartPos)){
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations &amp;&amp; noIn === <span class="hljs-literal">undefined</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>shift arguments to left by one</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      noIn = minPrec
      minPrec = leftStartLoc
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>flatten leftStartPos</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      leftStartLoc = leftStartPos[<span class="hljs-number">1</span>]
      leftStartPos = leftStartPos[<span class="hljs-number">0</span>]
    }
  }
  <span class="hljs-keyword">if</span> (prec != <span class="hljs-literal">null</span> &amp;&amp; (!noIn || <span class="hljs-keyword">this</span>.type !== tt._in)) {
    <span class="hljs-keyword">if</span> (prec &gt; minPrec) {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(leftStartPos, leftStartLoc)
      node.left = left
      node.operator = <span class="hljs-keyword">this</span>.value
      <span class="hljs-keyword">let</span> op = <span class="hljs-keyword">this</span>.type
      <span class="hljs-keyword">this</span>.next()
      <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc
      node.right = <span class="hljs-keyword">this</span>.parseExprOp(<span class="hljs-keyword">this</span>.parseMaybeUnary(), startPos, startLoc, prec, noIn)
      <span class="hljs-keyword">this</span>.finishNode(node, (op === tt.logicalOR || op === tt.logicalAND) ? <span class="hljs-string">"LogicalExpression"</span> : <span class="hljs-string">"BinaryExpression"</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  <span class="hljs-keyword">return</span> left
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Parse unary operators, both prefix and postfix.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseMaybeUnary = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">refShorthandDefaultPos</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type.prefix) {
    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode(), update = <span class="hljs-keyword">this</span>.type === tt.incDec
    node.operator = <span class="hljs-keyword">this</span>.value
    node.prefix = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">this</span>.next()
    node.argument = <span class="hljs-keyword">this</span>.parseMaybeUnary()
    <span class="hljs-keyword">if</span> (refShorthandDefaultPos &amp;&amp; refShorthandDefaultPos.start) <span class="hljs-keyword">this</span>.unexpected(refShorthandDefaultPos.start)
    <span class="hljs-keyword">if</span> (update) <span class="hljs-keyword">this</span>.checkLVal(node.argument)
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.strict &amp;&amp; node.operator === <span class="hljs-string">"delete"</span> &amp;&amp;
             node.argument.type === <span class="hljs-string">"Identifier"</span>)
      <span class="hljs-keyword">this</span>.raise(node.start, <span class="hljs-string">"Deleting local variable in strict mode"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, update ? <span class="hljs-string">"UpdateExpression"</span> : <span class="hljs-string">"UnaryExpression"</span>)
  }
  <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc
  <span class="hljs-keyword">let</span> expr = <span class="hljs-keyword">this</span>.parseExprSubscripts(refShorthandDefaultPos)
  <span class="hljs-keyword">if</span> (refShorthandDefaultPos &amp;&amp; refShorthandDefaultPos.start) <span class="hljs-keyword">return</span> expr
  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.type.postfix &amp;&amp; !<span class="hljs-keyword">this</span>.canInsertSemicolon()) {
    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc)
    node.operator = <span class="hljs-keyword">this</span>.value
    node.prefix = <span class="hljs-literal">false</span>
    node.argument = expr
    <span class="hljs-keyword">this</span>.checkLVal(expr)
    <span class="hljs-keyword">this</span>.next()
    expr = <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"UpdateExpression"</span>)
  }
  <span class="hljs-keyword">return</span> expr
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>Parse call, dot, and <code>[]</code>-subscript expressions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseExprSubscripts = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">refShorthandDefaultPos</span>) </span>{
  <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc
  <span class="hljs-keyword">let</span> expr = <span class="hljs-keyword">this</span>.parseExprAtom(refShorthandDefaultPos)
  <span class="hljs-keyword">if</span> (refShorthandDefaultPos &amp;&amp; refShorthandDefaultPos.start) <span class="hljs-keyword">return</span> expr
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseSubscripts(expr, startPos, startLoc)
}

pp.parseSubscripts = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">base, startPos, startLoc, noCalls</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(startPos)){
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations &amp;&amp; noCalls === <span class="hljs-literal">undefined</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>shift arguments to left by one</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      noCalls = startLoc
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>flatten startPos</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      startLoc = startPos[<span class="hljs-number">1</span>]
      startPos = startPos[<span class="hljs-number">0</span>]
    }
  }
  <span class="hljs-keyword">for</span> (;;) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.dot)) {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc)
      node.object = base
      node.property = <span class="hljs-keyword">this</span>.parseIdent(<span class="hljs-literal">true</span>)
      node.computed = <span class="hljs-literal">false</span>
      base = <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"MemberExpression"</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.bracketL)) {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc)
      node.object = base
      node.property = <span class="hljs-keyword">this</span>.parseExpression()
      node.computed = <span class="hljs-literal">true</span>
      <span class="hljs-keyword">this</span>.expect(tt.bracketR)
      base = <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"MemberExpression"</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!noCalls &amp;&amp; <span class="hljs-keyword">this</span>.eat(tt.parenL)) {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc)
      node.callee = base
      node.arguments = <span class="hljs-keyword">this</span>.parseExprList(tt.parenR, <span class="hljs-literal">false</span>)
      base = <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"CallExpression"</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.backQuote) {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc)
      node.tag = base
      node.quasi = <span class="hljs-keyword">this</span>.parseTemplate()
      base = <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"TaggedTemplateExpression"</span>)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> base
    }
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Parse an atomic expression — either a single token that is an
expression, an expression started by a keyword like <code>function</code> or
<code>new</code>, or an expression wrapped in punctuation like <code>()</code>, <code>[]</code>,
or <code>{}</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseExprAtom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">refShorthandDefaultPos</span>) </span>{
  <span class="hljs-keyword">let</span> node, canBeArrow = <span class="hljs-keyword">this</span>.potentialArrowAt == <span class="hljs-keyword">this</span>.start
  <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.type) {
  <span class="hljs-keyword">case</span> tt._this:
  <span class="hljs-keyword">case</span> tt._super:
    <span class="hljs-keyword">let</span> type = <span class="hljs-keyword">this</span>.type === tt._this ? <span class="hljs-string">"ThisExpression"</span> : <span class="hljs-string">"Super"</span>
    node = <span class="hljs-keyword">this</span>.startNode()
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, type)

  <span class="hljs-keyword">case</span> tt._yield:
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.inGenerator) <span class="hljs-keyword">this</span>.unexpected()

  <span class="hljs-keyword">case</span> tt.name:
    <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc
    <span class="hljs-keyword">let</span> id = <span class="hljs-keyword">this</span>.parseIdent(<span class="hljs-keyword">this</span>.type !== tt.name)
    <span class="hljs-keyword">if</span> (canBeArrow &amp;&amp; !<span class="hljs-keyword">this</span>.canInsertSemicolon() &amp;&amp; <span class="hljs-keyword">this</span>.eat(tt.arrow))
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseArrowExpression(<span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc), [id])
    <span class="hljs-keyword">return</span> id

  <span class="hljs-keyword">case</span> tt.regexp:
    <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>.value
    node = <span class="hljs-keyword">this</span>.parseLiteral(value.value)
    node.regex = {<span class="hljs-attr">pattern</span>: value.pattern, <span class="hljs-attr">flags</span>: value.flags}
    <span class="hljs-keyword">return</span> node

  <span class="hljs-keyword">case</span> tt.num: <span class="hljs-keyword">case</span> tt.string:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseLiteral(<span class="hljs-keyword">this</span>.value)

  <span class="hljs-keyword">case</span> tt._null: <span class="hljs-keyword">case</span> tt._true: <span class="hljs-keyword">case</span> tt._false:
    node = <span class="hljs-keyword">this</span>.startNode()
    node.value = <span class="hljs-keyword">this</span>.type === tt._null ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.type === tt._true
    node.raw = <span class="hljs-keyword">this</span>.type.keyword
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"Literal"</span>)

  <span class="hljs-keyword">case</span> tt.parenL:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseParenAndDistinguishExpression(canBeArrow)

  <span class="hljs-keyword">case</span> tt.bracketL:
    node = <span class="hljs-keyword">this</span>.startNode()
    <span class="hljs-keyword">this</span>.next()
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>check whether this is array comprehension or regular array</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">7</span> &amp;&amp; <span class="hljs-keyword">this</span>.type === tt._for) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseComprehension(node, <span class="hljs-literal">false</span>)
    }
    node.elements = <span class="hljs-keyword">this</span>.parseExprList(tt.bracketR, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, refShorthandDefaultPos)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ArrayExpression"</span>)

  <span class="hljs-keyword">case</span> tt.braceL:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseObj(<span class="hljs-literal">false</span>, refShorthandDefaultPos)

  <span class="hljs-keyword">case</span> tt._function:
    node = <span class="hljs-keyword">this</span>.startNode()
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFunction(node, <span class="hljs-literal">false</span>)

  <span class="hljs-keyword">case</span> tt._class:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseClass(<span class="hljs-keyword">this</span>.startNode(), <span class="hljs-literal">false</span>)

  <span class="hljs-keyword">case</span> tt._new:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseNew()

  <span class="hljs-keyword">case</span> tt.backQuote:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseTemplate()

  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">this</span>.unexpected()
  }
}

pp.parseLiteral = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  node.value = value
  node.raw = <span class="hljs-keyword">this</span>.input.slice(<span class="hljs-keyword">this</span>.start, <span class="hljs-keyword">this</span>.end)
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"Literal"</span>)
}

pp.parseParenExpression = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.expect(tt.parenL)
  <span class="hljs-keyword">let</span> val = <span class="hljs-keyword">this</span>.parseExpression()
  <span class="hljs-keyword">this</span>.expect(tt.parenR)
  <span class="hljs-keyword">return</span> val
}

pp.parseParenAndDistinguishExpression = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">canBeArrow</span>) </span>{
  <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc, val
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    <span class="hljs-keyword">this</span>.next()

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">7</span> &amp;&amp; <span class="hljs-keyword">this</span>.type === tt._for) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseComprehension(<span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc), <span class="hljs-literal">true</span>)
    }

    <span class="hljs-keyword">let</span> innerStartPos = <span class="hljs-keyword">this</span>.start, innerStartLoc = <span class="hljs-keyword">this</span>.startLoc
    <span class="hljs-keyword">let</span> exprList = [], first = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">let</span> refShorthandDefaultPos = {<span class="hljs-attr">start</span>: <span class="hljs-number">0</span>}, spreadStart, innerParenStart
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.type !== tt.parenR) {
      first ? first = <span class="hljs-literal">false</span> : <span class="hljs-keyword">this</span>.expect(tt.comma)
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.ellipsis) {
        spreadStart = <span class="hljs-keyword">this</span>.start
        exprList.push(<span class="hljs-keyword">this</span>.parseParenItem(<span class="hljs-keyword">this</span>.parseRest()))
        <span class="hljs-keyword">break</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.parenL &amp;&amp; !innerParenStart) {
          innerParenStart = <span class="hljs-keyword">this</span>.start
        }
        exprList.push(<span class="hljs-keyword">this</span>.parseMaybeAssign(<span class="hljs-literal">false</span>, refShorthandDefaultPos, <span class="hljs-keyword">this</span>.parseParenItem))
      }
    }
    <span class="hljs-keyword">let</span> innerEndPos = <span class="hljs-keyword">this</span>.start, innerEndLoc = <span class="hljs-keyword">this</span>.startLoc
    <span class="hljs-keyword">this</span>.expect(tt.parenR)

    <span class="hljs-keyword">if</span> (canBeArrow &amp;&amp; !<span class="hljs-keyword">this</span>.canInsertSemicolon() &amp;&amp; <span class="hljs-keyword">this</span>.eat(tt.arrow)) {
      <span class="hljs-keyword">if</span> (innerParenStart) <span class="hljs-keyword">this</span>.unexpected(innerParenStart)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseParenArrowList(startPos, startLoc, exprList)
    }

    <span class="hljs-keyword">if</span> (!exprList.length) <span class="hljs-keyword">this</span>.unexpected(<span class="hljs-keyword">this</span>.lastTokStart)
    <span class="hljs-keyword">if</span> (spreadStart) <span class="hljs-keyword">this</span>.unexpected(spreadStart)
    <span class="hljs-keyword">if</span> (refShorthandDefaultPos.start) <span class="hljs-keyword">this</span>.unexpected(refShorthandDefaultPos.start)

    <span class="hljs-keyword">if</span> (exprList.length &gt; <span class="hljs-number">1</span>) {
      val = <span class="hljs-keyword">this</span>.startNodeAt(innerStartPos, innerStartLoc)
      val.expressions = exprList
      <span class="hljs-keyword">this</span>.finishNodeAt(val, <span class="hljs-string">"SequenceExpression"</span>, innerEndPos, innerEndLoc)
    } <span class="hljs-keyword">else</span> {
      val = exprList[<span class="hljs-number">0</span>]
    }
  } <span class="hljs-keyword">else</span> {
    val = <span class="hljs-keyword">this</span>.parseParenExpression()
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.preserveParens) {
    <span class="hljs-keyword">let</span> par = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc)
    par.expression = val
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(par, <span class="hljs-string">"ParenthesizedExpression"</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> val
  }
}

pp.parseParenItem = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
  <span class="hljs-keyword">return</span> item
}

pp.parseParenArrowList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">startPos, startLoc, exprList</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseArrowExpression(<span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc), exprList)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>New's precedence is slightly tricky. It must allow its argument
to be a <code>[]</code> or dot subscript expression, but not a call — at
least, not without wrapping it in parentheses. Thus, it uses the</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-keyword">const</span> empty = []

pp.parseNew = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  <span class="hljs-keyword">let</span> meta = <span class="hljs-keyword">this</span>.parseIdent(<span class="hljs-literal">true</span>)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> &amp;&amp; <span class="hljs-keyword">this</span>.eat(tt.dot)) {
    node.meta = meta
    node.property = <span class="hljs-keyword">this</span>.parseIdent(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">if</span> (node.property.name !== <span class="hljs-string">"target"</span>)
      <span class="hljs-keyword">this</span>.raise(node.property.start, <span class="hljs-string">"The only valid meta property for new is new.target"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"MetaProperty"</span>)
  }
  <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc
  node.callee = <span class="hljs-keyword">this</span>.parseSubscripts(<span class="hljs-keyword">this</span>.parseExprAtom(), startPos, startLoc, <span class="hljs-literal">true</span>)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.parenL)) node.arguments = <span class="hljs-keyword">this</span>.parseExprList(tt.parenR, <span class="hljs-literal">false</span>)
  <span class="hljs-keyword">else</span> node.arguments = empty
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"NewExpression"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>Parse template expression.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseTemplateElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> elem = <span class="hljs-keyword">this</span>.startNode()
  elem.value = {
    <span class="hljs-attr">raw</span>: <span class="hljs-keyword">this</span>.input.slice(<span class="hljs-keyword">this</span>.start, <span class="hljs-keyword">this</span>.end),
    <span class="hljs-attr">cooked</span>: <span class="hljs-keyword">this</span>.value
  }
  <span class="hljs-keyword">this</span>.next()
  elem.tail = <span class="hljs-keyword">this</span>.type === tt.backQuote
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(elem, <span class="hljs-string">"TemplateElement"</span>)
}

pp.parseTemplate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  <span class="hljs-keyword">this</span>.next()
  node.expressions = []
  <span class="hljs-keyword">let</span> curElt = <span class="hljs-keyword">this</span>.parseTemplateElement()
  node.quasis = [curElt]
  <span class="hljs-keyword">while</span> (!curElt.tail) {
    <span class="hljs-keyword">this</span>.expect(tt.dollarBraceL)
    node.expressions.push(<span class="hljs-keyword">this</span>.parseExpression())
    <span class="hljs-keyword">this</span>.expect(tt.braceR)
    node.quasis.push(curElt = <span class="hljs-keyword">this</span>.parseTemplateElement())
  }
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"TemplateLiteral"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Parse an object literal or binding pattern.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseObj = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">isPattern, refShorthandDefaultPos</span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode(), first = <span class="hljs-literal">true</span>, propHash = {}
  node.properties = []
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.eat(tt.braceR)) {
    <span class="hljs-keyword">if</span> (!first) {
      <span class="hljs-keyword">this</span>.expect(tt.comma)
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.afterTrailingComma(tt.braceR)) <span class="hljs-keyword">break</span>
    } <span class="hljs-keyword">else</span> first = <span class="hljs-literal">false</span>

    <span class="hljs-keyword">let</span> prop = <span class="hljs-keyword">this</span>.startNode(), isGenerator, startPos, startLoc
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
      prop.method = <span class="hljs-literal">false</span>
      prop.shorthand = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">if</span> (isPattern || refShorthandDefaultPos) {
        startPos = <span class="hljs-keyword">this</span>.start
        startLoc = <span class="hljs-keyword">this</span>.startLoc
      }
      <span class="hljs-keyword">if</span> (!isPattern)
        isGenerator = <span class="hljs-keyword">this</span>.eat(tt.star)
    }
    <span class="hljs-keyword">this</span>.parsePropertyName(prop)
    <span class="hljs-keyword">this</span>.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos)
    <span class="hljs-keyword">this</span>.checkPropClash(prop, propHash)
    node.properties.push(<span class="hljs-keyword">this</span>.finishNode(prop, <span class="hljs-string">"Property"</span>))
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, isPattern ? <span class="hljs-string">"ObjectPattern"</span> : <span class="hljs-string">"ObjectExpression"</span>)
}

pp.parsePropertyValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.colon)) {
      prop.value = isPattern ? <span class="hljs-keyword">this</span>.parseMaybeDefault(<span class="hljs-keyword">this</span>.start, <span class="hljs-keyword">this</span>.startLoc) : <span class="hljs-keyword">this</span>.parseMaybeAssign(<span class="hljs-literal">false</span>, refShorthandDefaultPos)
      prop.kind = <span class="hljs-string">"init"</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> &amp;&amp; <span class="hljs-keyword">this</span>.type === tt.parenL) {
      <span class="hljs-keyword">if</span> (isPattern) <span class="hljs-keyword">this</span>.unexpected()
      prop.kind = <span class="hljs-string">"init"</span>
      prop.method = <span class="hljs-literal">true</span>
      prop.value = <span class="hljs-keyword">this</span>.parseMethod(isGenerator)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">5</span> &amp;&amp; !prop.computed &amp;&amp; prop.key.type === <span class="hljs-string">"Identifier"</span> &amp;&amp;
               (prop.key.name === <span class="hljs-string">"get"</span> || prop.key.name === <span class="hljs-string">"set"</span>) &amp;&amp;
               (<span class="hljs-keyword">this</span>.type != tt.comma &amp;&amp; <span class="hljs-keyword">this</span>.type != tt.braceR)) {
      <span class="hljs-keyword">if</span> (isGenerator || isPattern) <span class="hljs-keyword">this</span>.unexpected()
      prop.kind = prop.key.name
      <span class="hljs-keyword">this</span>.parsePropertyName(prop)
      prop.value = <span class="hljs-keyword">this</span>.parseMethod(<span class="hljs-literal">false</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> &amp;&amp; !prop.computed &amp;&amp; prop.key.type === <span class="hljs-string">"Identifier"</span>) {
      prop.kind = <span class="hljs-string">"init"</span>
      <span class="hljs-keyword">if</span> (isPattern) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isKeyword(prop.key.name) ||
            (<span class="hljs-keyword">this</span>.strict &amp;&amp; (reservedWords.strictBind(prop.key.name) || reservedWords.strict(prop.key.name))) ||
            (!<span class="hljs-keyword">this</span>.options.allowReserved &amp;&amp; <span class="hljs-keyword">this</span>.isReservedWord(prop.key.name)))
          <span class="hljs-keyword">this</span>.raise(prop.key.start, <span class="hljs-string">"Binding "</span> + prop.key.name)
        prop.value = <span class="hljs-keyword">this</span>.parseMaybeDefault(startPos, startLoc, prop.key)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.eq &amp;&amp; refShorthandDefaultPos) {
        <span class="hljs-keyword">if</span> (!refShorthandDefaultPos.start)
          refShorthandDefaultPos.start = <span class="hljs-keyword">this</span>.start
        prop.value = <span class="hljs-keyword">this</span>.parseMaybeDefault(startPos, startLoc, prop.key)
      } <span class="hljs-keyword">else</span> {
        prop.value = prop.key
      }
      prop.shorthand = <span class="hljs-literal">true</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span>.unexpected()
}

pp.parsePropertyName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.bracketL)) {
      prop.computed = <span class="hljs-literal">true</span>
      prop.key = <span class="hljs-keyword">this</span>.parseMaybeAssign()
      <span class="hljs-keyword">this</span>.expect(tt.bracketR)
      <span class="hljs-keyword">return</span> prop.key
    } <span class="hljs-keyword">else</span> {
      prop.computed = <span class="hljs-literal">false</span>
    }
  }
  <span class="hljs-keyword">return</span> prop.key = (<span class="hljs-keyword">this</span>.type === tt.num || <span class="hljs-keyword">this</span>.type === tt.string) ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-keyword">this</span>.parseIdent(<span class="hljs-literal">true</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>Initialize empty function node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.initFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  node.id = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    node.generator = <span class="hljs-literal">false</span>
    node.expression = <span class="hljs-literal">false</span>
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>Parse object or class method.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">isGenerator</span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  <span class="hljs-keyword">this</span>.initFunction(node)
  <span class="hljs-keyword">this</span>.expect(tt.parenL)
  node.params = <span class="hljs-keyword">this</span>.parseBindingList(tt.parenR, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)
  <span class="hljs-keyword">let</span> allowExpressionBody
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    node.generator = isGenerator
    allowExpressionBody = <span class="hljs-literal">true</span>
  } <span class="hljs-keyword">else</span> {
    allowExpressionBody = <span class="hljs-literal">false</span>
  }
  <span class="hljs-keyword">this</span>.parseFunctionBody(node, allowExpressionBody)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"FunctionExpression"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>Parse arrow function expression with given parameters.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseArrowExpression = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, params</span>) </span>{
  <span class="hljs-keyword">this</span>.initFunction(node)
  node.params = <span class="hljs-keyword">this</span>.toAssignableList(params, <span class="hljs-literal">true</span>)
  <span class="hljs-keyword">this</span>.parseFunctionBody(node, <span class="hljs-literal">true</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ArrowFunctionExpression"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>Parse function body and check parameters.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseFunctionBody = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, allowExpression</span>) </span>{
  <span class="hljs-keyword">let</span> isExpression = allowExpression &amp;&amp; <span class="hljs-keyword">this</span>.type !== tt.braceL

  <span class="hljs-keyword">if</span> (isExpression) {
    node.body = <span class="hljs-keyword">this</span>.parseMaybeAssign()
    node.expression = <span class="hljs-literal">true</span>
  } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>Start a new scope with regard to labels and the <code>inFunction</code>
flag (restore them to their old value afterwards).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">let</span> oldInFunc = <span class="hljs-keyword">this</span>.inFunction, oldInGen = <span class="hljs-keyword">this</span>.inGenerator, oldLabels = <span class="hljs-keyword">this</span>.labels
    <span class="hljs-keyword">this</span>.inFunction = <span class="hljs-literal">true</span>; <span class="hljs-keyword">this</span>.inGenerator = node.generator; <span class="hljs-keyword">this</span>.labels = []
    node.body = <span class="hljs-keyword">this</span>.parseBlock(<span class="hljs-literal">true</span>)
    node.expression = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">this</span>.inFunction = oldInFunc; <span class="hljs-keyword">this</span>.inGenerator = oldInGen; <span class="hljs-keyword">this</span>.labels = oldLabels
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>If this is a strict mode function, verify that argument names
are not repeated, and it does not try to bind the words <code>eval</code>
or <code>arguments</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.strict || !isExpression &amp;&amp; node.body.body.length &amp;&amp; <span class="hljs-keyword">this</span>.isUseStrict(node.body.body[<span class="hljs-number">0</span>])) {
    <span class="hljs-keyword">let</span> nameHash = {}, oldStrict = <span class="hljs-keyword">this</span>.strict
    <span class="hljs-keyword">this</span>.strict = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">if</span> (node.id)
      <span class="hljs-keyword">this</span>.checkLVal(node.id, <span class="hljs-literal">true</span>)
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; node.params.length; i++)
      <span class="hljs-keyword">this</span>.checkLVal(node.params[i], <span class="hljs-literal">true</span>, nameHash)
    <span class="hljs-keyword">this</span>.strict = oldStrict
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>Parses a comma-separated list of expressions, and returns them as
an array. <code>close</code> is the token type that ends the list, and
<code>allowEmpty</code> can be turned on to allow subsequent commas with
nothing in between them to be parsed as <code>null</code> (which is needed
for array literals).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseExprList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">close, allowTrailingComma, allowEmpty, refShorthandDefaultPos</span>) </span>{
  <span class="hljs-keyword">let</span> elts = [], first = <span class="hljs-literal">true</span>
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.eat(close)) {
    <span class="hljs-keyword">if</span> (!first) {
      <span class="hljs-keyword">this</span>.expect(tt.comma)
      <span class="hljs-keyword">if</span> (allowTrailingComma &amp;&amp; <span class="hljs-keyword">this</span>.afterTrailingComma(close)) <span class="hljs-keyword">break</span>
    } <span class="hljs-keyword">else</span> first = <span class="hljs-literal">false</span>

    <span class="hljs-keyword">if</span> (allowEmpty &amp;&amp; <span class="hljs-keyword">this</span>.type === tt.comma) {
      elts.push(<span class="hljs-literal">null</span>)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.ellipsis)
        elts.push(<span class="hljs-keyword">this</span>.parseSpread(refShorthandDefaultPos))
      <span class="hljs-keyword">else</span>
        elts.push(<span class="hljs-keyword">this</span>.parseMaybeAssign(<span class="hljs-literal">false</span>, refShorthandDefaultPos))
    }
  }
  <span class="hljs-keyword">return</span> elts
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>Parse the next token as an identifier. If <code>liberal</code> is true (used
when parsing properties), it will also convert keywords into
identifiers.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseIdent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">liberal</span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  <span class="hljs-keyword">if</span> (liberal &amp;&amp; <span class="hljs-keyword">this</span>.options.allowReserved == <span class="hljs-string">"never"</span>) liberal = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.name) {
    <span class="hljs-keyword">if</span> (!liberal &amp;&amp;
        ((!<span class="hljs-keyword">this</span>.options.allowReserved &amp;&amp; <span class="hljs-keyword">this</span>.isReservedWord(<span class="hljs-keyword">this</span>.value)) ||
         (<span class="hljs-keyword">this</span>.strict &amp;&amp; reservedWords.strict(<span class="hljs-keyword">this</span>.value)) &amp;&amp;
         (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> ||
          <span class="hljs-keyword">this</span>.input.slice(<span class="hljs-keyword">this</span>.start, <span class="hljs-keyword">this</span>.end).indexOf(<span class="hljs-string">"\\"</span>) == <span class="hljs-number">-1</span>)))
      <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.start, <span class="hljs-string">"The keyword '"</span> + <span class="hljs-keyword">this</span>.value + <span class="hljs-string">"' is reserved"</span>)
    node.name = <span class="hljs-keyword">this</span>.value
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (liberal &amp;&amp; <span class="hljs-keyword">this</span>.type.keyword) {
    node.name = <span class="hljs-keyword">this</span>.type.keyword
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.unexpected()
  }
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"Identifier"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>Parses yield expression inside generator.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseYield = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type == tt.semi || <span class="hljs-keyword">this</span>.canInsertSemicolon() || (<span class="hljs-keyword">this</span>.type != tt.star &amp;&amp; !<span class="hljs-keyword">this</span>.type.startsExpr)) {
    node.delegate = <span class="hljs-literal">false</span>
    node.argument = <span class="hljs-literal">null</span>
  } <span class="hljs-keyword">else</span> {
    node.delegate = <span class="hljs-keyword">this</span>.eat(tt.star)
    node.argument = <span class="hljs-keyword">this</span>.parseMaybeAssign()
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"YieldExpression"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>Parses array and generator comprehensions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseComprehension = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, isGenerator</span>) </span>{
  node.blocks = []
  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.type === tt._for) {
    <span class="hljs-keyword">let</span> block = <span class="hljs-keyword">this</span>.startNode()
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">this</span>.expect(tt.parenL)
    block.left = <span class="hljs-keyword">this</span>.parseBindingAtom()
    <span class="hljs-keyword">this</span>.checkLVal(block.left, <span class="hljs-literal">true</span>)
    <span class="hljs-keyword">this</span>.expectContextual(<span class="hljs-string">"of"</span>)
    block.right = <span class="hljs-keyword">this</span>.parseExpression()
    <span class="hljs-keyword">this</span>.expect(tt.parenR)
    node.blocks.push(<span class="hljs-keyword">this</span>.finishNode(block, <span class="hljs-string">"ComprehensionBlock"</span>))
  }
  node.filter = <span class="hljs-keyword">this</span>.eat(tt._if) ? <span class="hljs-keyword">this</span>.parseParenExpression() : <span class="hljs-literal">null</span>
  node.body = <span class="hljs-keyword">this</span>.parseExpression()
  <span class="hljs-keyword">this</span>.expect(isGenerator ? tt.parenR : tt.bracketR)
  node.generator = isGenerator
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ComprehensionExpression"</span>)
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
