<!DOCTYPE html>
<html>
<head>
  <title>statement.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/acorn/src/statement.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h3">
        <a href="#statement-parsing">Statement parsing</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>statement.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">import</span> {types <span class="hljs-keyword">as</span> tt} <span class="hljs-keyword">from</span> <span class="hljs-string">"./tokentype"</span>
<span class="hljs-keyword">import</span> {Parser} <span class="hljs-keyword">from</span> <span class="hljs-string">"./state"</span>
<span class="hljs-keyword">import</span> {lineBreak} <span class="hljs-keyword">from</span> <span class="hljs-string">"./whitespace"</span>

<span class="hljs-keyword">const</span> pp = Parser.prototype

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="statement-parsing">
  <h3>
    <a href="#statement-parsing" name="statement-parsing" class="pilcrow"></a>
Statement parsing
  </h3>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Parse a program. Initializes the parser, reads any number of
statements, and wraps them in a Program node.  Optionally takes a
<code>program</code> argument.  If present, the statements will be appended
to its body instead of creating a new node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseTopLevel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">let</span> first = <span class="hljs-literal">true</span>
  <span class="hljs-keyword">if</span> (!node.body) node.body = []
  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.type !== tt.eof) {
    <span class="hljs-keyword">let</span> stmt = <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>)
    node.body.push(stmt)
    <span class="hljs-keyword">if</span> (first &amp;&amp; <span class="hljs-keyword">this</span>.isUseStrict(stmt)) <span class="hljs-keyword">this</span>.setStrict(<span class="hljs-literal">true</span>)
    first = <span class="hljs-literal">false</span>
  }
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    node.sourceType = <span class="hljs-keyword">this</span>.options.sourceType
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"Program"</span>)
}

<span class="hljs-keyword">const</span> loopLabel = {<span class="hljs-attr">kind</span>: <span class="hljs-string">"loop"</span>}, switchLabel = {<span class="hljs-attr">kind</span>: <span class="hljs-string">"switch"</span>}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>Parse a single statement.</p>
<p>If expecting a statement and finding a slash operator, parse a
regular expression literal. This is to handle cases like
<code>if (foo) /blah/.exec(foo)</code>, where looking at the previous token
does not help.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">declaration, topLevel</span>) </span>{
  <span class="hljs-keyword">let</span> starttype = <span class="hljs-keyword">this</span>.type, node = <span class="hljs-keyword">this</span>.startNode()

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Most types of statements are recognized by the keyword they
start with. Many are trivial to parse, some require a bit of
complexity.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  <span class="hljs-keyword">switch</span> (starttype) {
  <span class="hljs-keyword">case</span> tt._break: <span class="hljs-keyword">case</span> tt._continue: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseBreakContinueStatement(node, starttype.keyword)
  <span class="hljs-keyword">case</span> tt._debugger: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseDebuggerStatement(node)
  <span class="hljs-keyword">case</span> tt._do: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseDoStatement(node)
  <span class="hljs-keyword">case</span> tt._for: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseForStatement(node)
  <span class="hljs-keyword">case</span> tt._function:
    <span class="hljs-keyword">if</span> (!declaration &amp;&amp; <span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) <span class="hljs-keyword">this</span>.unexpected()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFunctionStatement(node)
  <span class="hljs-keyword">case</span> tt._class:
    <span class="hljs-keyword">if</span> (!declaration) <span class="hljs-keyword">this</span>.unexpected()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseClass(node, <span class="hljs-literal">true</span>)
  <span class="hljs-keyword">case</span> tt._if: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseIfStatement(node)
  <span class="hljs-keyword">case</span> tt._return: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseReturnStatement(node)
  <span class="hljs-keyword">case</span> tt._switch: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseSwitchStatement(node)
  <span class="hljs-keyword">case</span> tt._throw: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseThrowStatement(node)
  <span class="hljs-keyword">case</span> tt._try: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseTryStatement(node)
  <span class="hljs-keyword">case</span> tt._let: <span class="hljs-keyword">case</span> tt._const: <span class="hljs-keyword">if</span> (!declaration) <span class="hljs-keyword">this</span>.unexpected() <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> falls through to _var</span>
  <span class="hljs-keyword">case</span> tt._var: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseVarStatement(node, starttype)
  <span class="hljs-keyword">case</span> tt._while: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseWhileStatement(node)
  <span class="hljs-keyword">case</span> tt._with: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseWithStatement(node)
  <span class="hljs-keyword">case</span> tt.braceL: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseBlock()
  <span class="hljs-keyword">case</span> tt.semi: <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseEmptyStatement(node)
  <span class="hljs-keyword">case</span> tt._export:
  <span class="hljs-keyword">case</span> tt._import:
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.options.allowImportExportEverywhere) {
      <span class="hljs-keyword">if</span> (!topLevel)
        <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.start, <span class="hljs-string">"'import' and 'export' may only appear at the top level"</span>)
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.inModule)
        <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.start, <span class="hljs-string">"'import' and 'export' may appear only with 'sourceType: module'"</span>)
    }
    <span class="hljs-keyword">return</span> starttype === tt._import ? <span class="hljs-keyword">this</span>.parseImport(node) : <span class="hljs-keyword">this</span>.parseExport(node)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>If the statement does not start with a statement keyword or a
brace, it's an ExpressionStatement or LabeledStatement. We
simply start parsing an expression, and afterwards, if the
next token is a colon and the expression was a simple
Identifier node, we switch to interpreting it as a label.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">let</span> maybeName = <span class="hljs-keyword">this</span>.value, expr = <span class="hljs-keyword">this</span>.parseExpression()
    <span class="hljs-keyword">if</span> (starttype === tt.name &amp;&amp; expr.type === <span class="hljs-string">"Identifier"</span> &amp;&amp; <span class="hljs-keyword">this</span>.eat(tt.colon))
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseLabeledStatement(node, maybeName, expr)
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseExpressionStatement(node, expr)
  }
}

pp.parseBreakContinueStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, keyword</span>) </span>{
  <span class="hljs-keyword">let</span> isBreak = keyword == <span class="hljs-string">"break"</span>
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.semi) || <span class="hljs-keyword">this</span>.insertSemicolon()) node.label = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type !== tt.name) <span class="hljs-keyword">this</span>.unexpected()
  <span class="hljs-keyword">else</span> {
    node.label = <span class="hljs-keyword">this</span>.parseIdent()
    <span class="hljs-keyword">this</span>.semicolon()
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Verify that there is an actual destination to break or
continue to.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.labels.length; ++i) {
    <span class="hljs-keyword">let</span> lab = <span class="hljs-keyword">this</span>.labels[i]
    <span class="hljs-keyword">if</span> (node.label == <span class="hljs-literal">null</span> || lab.name === node.label.name) {
      <span class="hljs-keyword">if</span> (lab.kind != <span class="hljs-literal">null</span> &amp;&amp; (isBreak || lab.kind === <span class="hljs-string">"loop"</span>)) <span class="hljs-keyword">break</span>
      <span class="hljs-keyword">if</span> (node.label &amp;&amp; isBreak) <span class="hljs-keyword">break</span>
    }
  }
  <span class="hljs-keyword">if</span> (i === <span class="hljs-keyword">this</span>.labels.length) <span class="hljs-keyword">this</span>.raise(node.start, <span class="hljs-string">"Unsyntactic "</span> + keyword)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, isBreak ? <span class="hljs-string">"BreakStatement"</span> : <span class="hljs-string">"ContinueStatement"</span>)
}

pp.parseDebuggerStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">this</span>.semicolon()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"DebuggerStatement"</span>)
}

pp.parseDoStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">this</span>.labels.push(loopLabel)
  node.body = <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">this</span>.labels.pop()
  <span class="hljs-keyword">this</span>.expect(tt._while)
  node.test = <span class="hljs-keyword">this</span>.parseParenExpression()
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>)
    <span class="hljs-keyword">this</span>.eat(tt.semi)
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">this</span>.semicolon()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"DoWhileStatement"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Disambiguating between a <code>for</code> and a <code>for</code>/<code>in</code> or <code>for</code>/<code>of</code>
loop is non-trivial. Basically, we have to parse the init <code>var</code>
statement or expression, disallowing the <code>in</code> operator (see
the second parameter to <code>parseExpression</code>), and then check
whether the next token is <code>in</code> or <code>of</code>. When there is no init
part (semicolon immediately after the opening parenthesis), it
is a regular <code>for</code> loop.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseForStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">this</span>.labels.push(loopLabel)
  <span class="hljs-keyword">this</span>.expect(tt.parenL)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.semi) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFor(node, <span class="hljs-literal">null</span>)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt._var || <span class="hljs-keyword">this</span>.type === tt._let || <span class="hljs-keyword">this</span>.type === tt._const) {
    <span class="hljs-keyword">let</span> init = <span class="hljs-keyword">this</span>.startNode(), varKind = <span class="hljs-keyword">this</span>.type
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">this</span>.parseVar(init, <span class="hljs-literal">true</span>, varKind)
    <span class="hljs-keyword">this</span>.finishNode(init, <span class="hljs-string">"VariableDeclaration"</span>)
    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.type === tt._in || (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> &amp;&amp; <span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"of"</span>))) &amp;&amp; init.declarations.length === <span class="hljs-number">1</span> &amp;&amp;
        !(varKind !== tt._var &amp;&amp; init.declarations[<span class="hljs-number">0</span>].init))
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseForIn(node, init)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFor(node, init)
  }
  <span class="hljs-keyword">let</span> refShorthandDefaultPos = {<span class="hljs-attr">start</span>: <span class="hljs-number">0</span>}
  <span class="hljs-keyword">let</span> init = <span class="hljs-keyword">this</span>.parseExpression(<span class="hljs-literal">true</span>, refShorthandDefaultPos)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt._in || (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> &amp;&amp; <span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"of"</span>))) {
    <span class="hljs-keyword">this</span>.toAssignable(init)
    <span class="hljs-keyword">this</span>.checkLVal(init)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseForIn(node, init)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refShorthandDefaultPos.start) {
    <span class="hljs-keyword">this</span>.unexpected(refShorthandDefaultPos.start)
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFor(node, init)
}

pp.parseFunctionStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFunction(node, <span class="hljs-literal">true</span>)
}

pp.parseIfStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  node.test = <span class="hljs-keyword">this</span>.parseParenExpression()
  node.consequent = <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">false</span>)
  node.alternate = <span class="hljs-keyword">this</span>.eat(tt._else) ? <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">false</span>) : <span class="hljs-literal">null</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"IfStatement"</span>)
}

pp.parseReturnStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.inFunction &amp;&amp; !<span class="hljs-keyword">this</span>.options.allowReturnOutsideFunction)
    <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.start, <span class="hljs-string">"'return' outside of function"</span>)
  <span class="hljs-keyword">this</span>.next()

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>In <code>return</code> (and <code>break</code>/<code>continue</code>), the keywords with
optional arguments, we eagerly look for a semicolon or the
possibility to insert one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.semi) || <span class="hljs-keyword">this</span>.insertSemicolon()) node.argument = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">else</span> { node.argument = <span class="hljs-keyword">this</span>.parseExpression(); <span class="hljs-keyword">this</span>.semicolon() }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ReturnStatement"</span>)
}

pp.parseSwitchStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  node.discriminant = <span class="hljs-keyword">this</span>.parseParenExpression()
  node.cases = []
  <span class="hljs-keyword">this</span>.expect(tt.braceL)
  <span class="hljs-keyword">this</span>.labels.push(switchLabel)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Statements under must be grouped (by label) in SwitchCase
nodes. <code>cur</code> is used to keep the node that we are currently
adding statements to.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> cur, sawDefault; <span class="hljs-keyword">this</span>.type != tt.braceR;) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt._case || <span class="hljs-keyword">this</span>.type === tt._default) {
      <span class="hljs-keyword">let</span> isCase = <span class="hljs-keyword">this</span>.type === tt._case
      <span class="hljs-keyword">if</span> (cur) <span class="hljs-keyword">this</span>.finishNode(cur, <span class="hljs-string">"SwitchCase"</span>)
      node.cases.push(cur = <span class="hljs-keyword">this</span>.startNode())
      cur.consequent = []
      <span class="hljs-keyword">this</span>.next()
      <span class="hljs-keyword">if</span> (isCase) {
        cur.test = <span class="hljs-keyword">this</span>.parseExpression()
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (sawDefault) <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.lastTokStart, <span class="hljs-string">"Multiple default clauses"</span>)
        sawDefault = <span class="hljs-literal">true</span>
        cur.test = <span class="hljs-literal">null</span>
      }
      <span class="hljs-keyword">this</span>.expect(tt.colon)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">this</span>.unexpected()
      cur.consequent.push(<span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">true</span>))
    }
  }
  <span class="hljs-keyword">if</span> (cur) <span class="hljs-keyword">this</span>.finishNode(cur, <span class="hljs-string">"SwitchCase"</span>)
  <span class="hljs-keyword">this</span>.next() <span class="hljs-comment">// Closing brace</span>
  <span class="hljs-keyword">this</span>.labels.pop()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"SwitchStatement"</span>)
}

pp.parseThrowStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">if</span> (lineBreak.test(<span class="hljs-keyword">this</span>.input.slice(<span class="hljs-keyword">this</span>.lastTokEnd, <span class="hljs-keyword">this</span>.start)))
    <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.lastTokEnd, <span class="hljs-string">"Illegal newline after throw"</span>)
  node.argument = <span class="hljs-keyword">this</span>.parseExpression()
  <span class="hljs-keyword">this</span>.semicolon()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ThrowStatement"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Reused empty array added for node fields that are always empty.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-keyword">const</span> empty = []

pp.parseTryStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  node.block = <span class="hljs-keyword">this</span>.parseBlock()
  node.handler = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt._catch) {
    <span class="hljs-keyword">let</span> clause = <span class="hljs-keyword">this</span>.startNode()
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">this</span>.expect(tt.parenL)
    clause.param = <span class="hljs-keyword">this</span>.parseBindingAtom()
    <span class="hljs-keyword">this</span>.checkLVal(clause.param, <span class="hljs-literal">true</span>)
    <span class="hljs-keyword">this</span>.expect(tt.parenR)
    clause.guard = <span class="hljs-literal">null</span>
    clause.body = <span class="hljs-keyword">this</span>.parseBlock()
    node.handler = <span class="hljs-keyword">this</span>.finishNode(clause, <span class="hljs-string">"CatchClause"</span>)
  }
  node.guardedHandlers = empty
  node.finalizer = <span class="hljs-keyword">this</span>.eat(tt._finally) ? <span class="hljs-keyword">this</span>.parseBlock() : <span class="hljs-literal">null</span>
  <span class="hljs-keyword">if</span> (!node.handler &amp;&amp; !node.finalizer)
    <span class="hljs-keyword">this</span>.raise(node.start, <span class="hljs-string">"Missing catch or finally clause"</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"TryStatement"</span>)
}

pp.parseVarStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, kind</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">this</span>.parseVar(node, <span class="hljs-literal">false</span>, kind)
  <span class="hljs-keyword">this</span>.semicolon()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"VariableDeclaration"</span>)
}

pp.parseWhileStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  node.test = <span class="hljs-keyword">this</span>.parseParenExpression()
  <span class="hljs-keyword">this</span>.labels.push(loopLabel)
  node.body = <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">this</span>.labels.pop()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"WhileStatement"</span>)
}

pp.parseWithStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.strict) <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.start, <span class="hljs-string">"'with' in strict mode"</span>)
  <span class="hljs-keyword">this</span>.next()
  node.object = <span class="hljs-keyword">this</span>.parseParenExpression()
  node.body = <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"WithStatement"</span>)
}

pp.parseEmptyStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"EmptyStatement"</span>)
}

pp.parseLabeledStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, maybeName, expr</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.labels.length; ++i)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.labels[i].name === maybeName) <span class="hljs-keyword">this</span>.raise(expr.start, <span class="hljs-string">"Label '"</span> + maybeName + <span class="hljs-string">"' is already declared"</span>)
  <span class="hljs-keyword">let</span> kind = <span class="hljs-keyword">this</span>.type.isLoop ? <span class="hljs-string">"loop"</span> : <span class="hljs-keyword">this</span>.type === tt._switch ? <span class="hljs-string">"switch"</span> : <span class="hljs-literal">null</span>
  <span class="hljs-keyword">this</span>.labels.push({<span class="hljs-attr">name</span>: maybeName, <span class="hljs-attr">kind</span>: kind})
  node.body = <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">true</span>)
  <span class="hljs-keyword">this</span>.labels.pop()
  node.label = expr
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"LabeledStatement"</span>)
}

pp.parseExpressionStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, expr</span>) </span>{
  node.expression = expr
  <span class="hljs-keyword">this</span>.semicolon()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExpressionStatement"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Parse a semicolon-enclosed block of statements, handling <code>&quot;use strict&quot;</code> declarations when <code>allowStrict</code> is true (used for
function bodies).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseBlock = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">allowStrict</span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode(), first = <span class="hljs-literal">true</span>, oldStrict
  node.body = []
  <span class="hljs-keyword">this</span>.expect(tt.braceL)
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.eat(tt.braceR)) {
    <span class="hljs-keyword">let</span> stmt = <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">true</span>)
    node.body.push(stmt)
    <span class="hljs-keyword">if</span> (first &amp;&amp; allowStrict &amp;&amp; <span class="hljs-keyword">this</span>.isUseStrict(stmt)) {
      oldStrict = <span class="hljs-keyword">this</span>.strict
      <span class="hljs-keyword">this</span>.setStrict(<span class="hljs-keyword">this</span>.strict = <span class="hljs-literal">true</span>)
    }
    first = <span class="hljs-literal">false</span>
  }
  <span class="hljs-keyword">if</span> (oldStrict === <span class="hljs-literal">false</span>) <span class="hljs-keyword">this</span>.setStrict(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"BlockStatement"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>Parse a regular <code>for</code> loop. The disambiguation code in
<code>parseStatement</code> will already have parsed the init statement or
expression.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseFor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, init</span>) </span>{
  node.init = init
  <span class="hljs-keyword">this</span>.expect(tt.semi)
  node.test = <span class="hljs-keyword">this</span>.type === tt.semi ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.parseExpression()
  <span class="hljs-keyword">this</span>.expect(tt.semi)
  node.update = <span class="hljs-keyword">this</span>.type === tt.parenR ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>.parseExpression()
  <span class="hljs-keyword">this</span>.expect(tt.parenR)
  node.body = <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">this</span>.labels.pop()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ForStatement"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Parse a <code>for</code>/<code>in</code> and <code>for</code>/<code>of</code> loop, which are almost
same from parser's perspective.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseForIn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, init</span>) </span>{
  <span class="hljs-keyword">let</span> type = <span class="hljs-keyword">this</span>.type === tt._in ? <span class="hljs-string">"ForInStatement"</span> : <span class="hljs-string">"ForOfStatement"</span>
  <span class="hljs-keyword">this</span>.next()
  node.left = init
  node.right = <span class="hljs-keyword">this</span>.parseExpression()
  <span class="hljs-keyword">this</span>.expect(tt.parenR)
  node.body = <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">this</span>.labels.pop()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, type)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>Parse a list of variable declarations.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseVar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, isFor, kind</span>) </span>{
  node.declarations = []
  node.kind = kind.keyword
  <span class="hljs-keyword">for</span> (;;) {
    <span class="hljs-keyword">let</span> decl = <span class="hljs-keyword">this</span>.startNode()
    <span class="hljs-keyword">this</span>.parseVarId(decl)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.eq)) {
      decl.init = <span class="hljs-keyword">this</span>.parseMaybeAssign(isFor)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kind === tt._const &amp;&amp; !(<span class="hljs-keyword">this</span>.type === tt._in || (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> &amp;&amp; <span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"of"</span>)))) {
      <span class="hljs-keyword">this</span>.unexpected()
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (decl.id.type != <span class="hljs-string">"Identifier"</span> &amp;&amp; !(isFor &amp;&amp; (<span class="hljs-keyword">this</span>.type === tt._in || <span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"of"</span>)))) {
      <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.lastTokEnd, <span class="hljs-string">"Complex binding patterns require an initialization value"</span>)
    } <span class="hljs-keyword">else</span> {
      decl.init = <span class="hljs-literal">null</span>
    }
    node.declarations.push(<span class="hljs-keyword">this</span>.finishNode(decl, <span class="hljs-string">"VariableDeclarator"</span>))
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.eat(tt.comma)) <span class="hljs-keyword">break</span>
  }
  <span class="hljs-keyword">return</span> node
}

pp.parseVarId = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">decl</span>) </span>{
  decl.id = <span class="hljs-keyword">this</span>.parseBindingAtom()
  <span class="hljs-keyword">this</span>.checkLVal(decl.id, <span class="hljs-literal">true</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Parse a function declaration or literal (depending on the
<code>isStatement</code> parameter).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, isStatement, allowExpressionBody</span>) </span>{
  <span class="hljs-keyword">this</span>.initFunction(node)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>)
    node.generator = <span class="hljs-keyword">this</span>.eat(tt.star)
  <span class="hljs-keyword">if</span> (isStatement || <span class="hljs-keyword">this</span>.type === tt.name)
    node.id = <span class="hljs-keyword">this</span>.parseIdent()
  <span class="hljs-keyword">this</span>.parseFunctionParams(node)
  <span class="hljs-keyword">this</span>.parseFunctionBody(node, allowExpressionBody)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, isStatement ? <span class="hljs-string">"FunctionDeclaration"</span> : <span class="hljs-string">"FunctionExpression"</span>)
}

pp.parseFunctionParams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.expect(tt.parenL)
  node.params = <span class="hljs-keyword">this</span>.parseBindingList(tt.parenR, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>Parse a class declaration or literal (depending on the
<code>isStatement</code> parameter).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseClass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, isStatement</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">this</span>.parseClassId(node, isStatement)
  <span class="hljs-keyword">this</span>.parseClassSuper(node)
  <span class="hljs-keyword">let</span> classBody = <span class="hljs-keyword">this</span>.startNode()
  <span class="hljs-keyword">let</span> hadConstructor = <span class="hljs-literal">false</span>
  classBody.body = []
  <span class="hljs-keyword">this</span>.expect(tt.braceL)
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.eat(tt.braceR)) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.semi)) <span class="hljs-keyword">continue</span>
    <span class="hljs-keyword">let</span> method = <span class="hljs-keyword">this</span>.startNode()
    <span class="hljs-keyword">let</span> isGenerator = <span class="hljs-keyword">this</span>.eat(tt.star)
    <span class="hljs-keyword">let</span> isMaybeStatic = <span class="hljs-keyword">this</span>.type === tt.name &amp;&amp; <span class="hljs-keyword">this</span>.value === <span class="hljs-string">"static"</span>
    <span class="hljs-keyword">this</span>.parsePropertyName(method)
    method.static = isMaybeStatic &amp;&amp; <span class="hljs-keyword">this</span>.type !== tt.parenL
    <span class="hljs-keyword">if</span> (method.static) {
      <span class="hljs-keyword">if</span> (isGenerator) <span class="hljs-keyword">this</span>.unexpected()
      isGenerator = <span class="hljs-keyword">this</span>.eat(tt.star)
      <span class="hljs-keyword">this</span>.parsePropertyName(method)
    }
    method.kind = <span class="hljs-string">"method"</span>
    <span class="hljs-keyword">if</span> (!method.computed) {
      <span class="hljs-keyword">let</span> {key} = method
      <span class="hljs-keyword">let</span> isGetSet = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">if</span> (!isGenerator &amp;&amp; key.type === <span class="hljs-string">"Identifier"</span> &amp;&amp; <span class="hljs-keyword">this</span>.type !== tt.parenL &amp;&amp; (key.name === <span class="hljs-string">"get"</span> || key.name === <span class="hljs-string">"set"</span>)) {
        isGetSet = <span class="hljs-literal">true</span>
        method.kind = key.name
        key = <span class="hljs-keyword">this</span>.parsePropertyName(method)
      }
      <span class="hljs-keyword">if</span> (!method.static &amp;&amp; (key.type === <span class="hljs-string">"Identifier"</span> &amp;&amp; key.name === <span class="hljs-string">"constructor"</span> ||
          key.type === <span class="hljs-string">"Literal"</span> &amp;&amp; key.value === <span class="hljs-string">"constructor"</span>)) {
        <span class="hljs-keyword">if</span> (hadConstructor) <span class="hljs-keyword">this</span>.raise(key.start, <span class="hljs-string">"Duplicate constructor in the same class"</span>)
        <span class="hljs-keyword">if</span> (isGetSet) <span class="hljs-keyword">this</span>.raise(key.start, <span class="hljs-string">"Constructor can't have get/set modifier"</span>)
        <span class="hljs-keyword">if</span> (isGenerator) <span class="hljs-keyword">this</span>.raise(key.start, <span class="hljs-string">"Constructor can't be a generator"</span>)
        method.kind = <span class="hljs-string">"constructor"</span>
        hadConstructor = <span class="hljs-literal">true</span>
      }
    }
    <span class="hljs-keyword">this</span>.parseClassMethod(classBody, method, isGenerator)
  }
  node.body = <span class="hljs-keyword">this</span>.finishNode(classBody, <span class="hljs-string">"ClassBody"</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, isStatement ? <span class="hljs-string">"ClassDeclaration"</span> : <span class="hljs-string">"ClassExpression"</span>)
}

pp.parseClassMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">classBody, method, isGenerator</span>) </span>{
  method.value = <span class="hljs-keyword">this</span>.parseMethod(isGenerator)
  classBody.body.push(<span class="hljs-keyword">this</span>.finishNode(method, <span class="hljs-string">"MethodDefinition"</span>))
}

pp.parseClassId = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, isStatement</span>) </span>{
  node.id = <span class="hljs-keyword">this</span>.type === tt.name ? <span class="hljs-keyword">this</span>.parseIdent() : isStatement ? <span class="hljs-keyword">this</span>.unexpected() : <span class="hljs-literal">null</span>
}

pp.parseClassSuper = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  node.superClass = <span class="hljs-keyword">this</span>.eat(tt._extends) ? <span class="hljs-keyword">this</span>.parseExprSubscripts() : <span class="hljs-literal">null</span>
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>Parses module export declaration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseExport = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>export * from '...'</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.star)) {
    <span class="hljs-keyword">this</span>.expectContextual(<span class="hljs-string">"from"</span>)
    node.source = <span class="hljs-keyword">this</span>.type === tt.string ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-keyword">this</span>.unexpected()
    <span class="hljs-keyword">this</span>.semicolon()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExportAllDeclaration"</span>)
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt._default)) { <span class="hljs-comment">// export default ...</span>
    <span class="hljs-keyword">let</span> expr = <span class="hljs-keyword">this</span>.parseMaybeAssign()
    <span class="hljs-keyword">let</span> needsSemi = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">if</span> (expr.type == <span class="hljs-string">"FunctionExpression"</span> ||
        expr.type == <span class="hljs-string">"ClassExpression"</span>) {
      needsSemi = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">if</span> (expr.id) {
        expr.type = expr.type == <span class="hljs-string">"FunctionExpression"</span>
          ? <span class="hljs-string">"FunctionDeclaration"</span>
          : <span class="hljs-string">"ClassDeclaration"</span>
      }
    }
    node.declaration = expr
    <span class="hljs-keyword">if</span> (needsSemi) <span class="hljs-keyword">this</span>.semicolon()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExportDefaultDeclaration"</span>)
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>export var|const|let|function|class ...</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.shouldParseExportStatement()) {
    node.declaration = <span class="hljs-keyword">this</span>.parseStatement(<span class="hljs-literal">true</span>)
    node.specifiers = []
    node.source = <span class="hljs-literal">null</span>
  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// export { x, y as z } [from '...']</span>
    node.declaration = <span class="hljs-literal">null</span>
    node.specifiers = <span class="hljs-keyword">this</span>.parseExportSpecifiers()
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"from"</span>)) {
      node.source = <span class="hljs-keyword">this</span>.type === tt.string ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-keyword">this</span>.unexpected()
    } <span class="hljs-keyword">else</span> {
      node.source = <span class="hljs-literal">null</span>
    }
    <span class="hljs-keyword">this</span>.semicolon()
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExportNamedDeclaration"</span>)
}

pp.shouldParseExportStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type.keyword
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>Parses a comma-separated list of module exports.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseExportSpecifiers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> nodes = [], first = <span class="hljs-literal">true</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>export { x, y as z } [from '...']</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">this</span>.expect(tt.braceL)
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.eat(tt.braceR)) {
    <span class="hljs-keyword">if</span> (!first) {
      <span class="hljs-keyword">this</span>.expect(tt.comma)
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.afterTrailingComma(tt.braceR)) <span class="hljs-keyword">break</span>
    } <span class="hljs-keyword">else</span> first = <span class="hljs-literal">false</span>

    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
    node.local = <span class="hljs-keyword">this</span>.parseIdent(<span class="hljs-keyword">this</span>.type === tt._default)
    node.exported = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"as"</span>) ? <span class="hljs-keyword">this</span>.parseIdent(<span class="hljs-literal">true</span>) : node.local
    nodes.push(<span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExportSpecifier"</span>))
  }
  <span class="hljs-keyword">return</span> nodes
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>Parses import declaration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseImport = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.next()
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>import '...'</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.string) {
    node.specifiers = empty
    node.source = <span class="hljs-keyword">this</span>.parseExprAtom()
    node.kind = <span class="hljs-string">""</span>
  } <span class="hljs-keyword">else</span> {
    node.specifiers = <span class="hljs-keyword">this</span>.parseImportSpecifiers()
    <span class="hljs-keyword">this</span>.expectContextual(<span class="hljs-string">"from"</span>)
    node.source = <span class="hljs-keyword">this</span>.type === tt.string ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-keyword">this</span>.unexpected()
  }
  <span class="hljs-keyword">this</span>.semicolon()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ImportDeclaration"</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>Parses a comma-separated list of module imports.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
pp.parseImportSpecifiers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> nodes = [], first = <span class="hljs-literal">true</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.name) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>import defaultObj, { x, y as z } from '...'</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
    node.local = <span class="hljs-keyword">this</span>.parseIdent()
    <span class="hljs-keyword">this</span>.checkLVal(node.local, <span class="hljs-literal">true</span>)
    nodes.push(<span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ImportDefaultSpecifier"</span>))
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.eat(tt.comma)) <span class="hljs-keyword">return</span> nodes
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.star) {
    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">this</span>.expectContextual(<span class="hljs-string">"as"</span>)
    node.local = <span class="hljs-keyword">this</span>.parseIdent()
    <span class="hljs-keyword">this</span>.checkLVal(node.local, <span class="hljs-literal">true</span>)
    nodes.push(<span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ImportNamespaceSpecifier"</span>))
    <span class="hljs-keyword">return</span> nodes
  }
  <span class="hljs-keyword">this</span>.expect(tt.braceL)
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.eat(tt.braceR)) {
    <span class="hljs-keyword">if</span> (!first) {
      <span class="hljs-keyword">this</span>.expect(tt.comma)
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.afterTrailingComma(tt.braceR)) <span class="hljs-keyword">break</span>
    } <span class="hljs-keyword">else</span> first = <span class="hljs-literal">false</span>

    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
    node.imported = <span class="hljs-keyword">this</span>.parseIdent(<span class="hljs-literal">true</span>)
    node.local = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"as"</span>) ? <span class="hljs-keyword">this</span>.parseIdent() : node.imported
    <span class="hljs-keyword">this</span>.checkLVal(node.local, <span class="hljs-literal">true</span>)
    nodes.push(<span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ImportSpecifier"</span>))
  }
  <span class="hljs-keyword">return</span> nodes
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
