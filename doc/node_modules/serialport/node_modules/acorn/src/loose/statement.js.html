<!DOCTYPE html>
<html>
<head>
  <title>statement.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../../doc-style.css" />
  <script src="../../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../../";
    var thisFile = "node_modules/serialport/node_modules/acorn/src/loose/statement.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>statement.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">import</span> {LooseParser} <span class="hljs-keyword">from</span> <span class="hljs-string">"./state"</span>
<span class="hljs-keyword">import</span> {isDummy} <span class="hljs-keyword">from</span> <span class="hljs-string">"./parseutil"</span>
<span class="hljs-keyword">import</span> {getLineInfo, tokTypes <span class="hljs-keyword">as</span> tt} <span class="hljs-keyword">from</span> <span class="hljs-string">".."</span>

<span class="hljs-keyword">const</span> lp = LooseParser.prototype

lp.parseTopLevel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(<span class="hljs-keyword">this</span>.options.locations ? [<span class="hljs-number">0</span>, getLineInfo(<span class="hljs-keyword">this</span>.input, <span class="hljs-number">0</span>)] : <span class="hljs-number">0</span>)
  node.body = []
  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.tok.type !== tt.eof) node.body.push(<span class="hljs-keyword">this</span>.parseStatement())
  <span class="hljs-keyword">this</span>.last = <span class="hljs-keyword">this</span>.tok
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    node.sourceType = <span class="hljs-keyword">this</span>.options.sourceType
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"Program"</span>)
}

lp.parseStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> starttype = <span class="hljs-keyword">this</span>.tok.type, node = <span class="hljs-keyword">this</span>.startNode()

  <span class="hljs-keyword">switch</span> (starttype) {
  <span class="hljs-keyword">case</span> tt._break: <span class="hljs-keyword">case</span> tt._continue:
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">let</span> isBreak = starttype === tt._break
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.semicolon() || <span class="hljs-keyword">this</span>.canInsertSemicolon()) {
      node.label = <span class="hljs-literal">null</span>
    } <span class="hljs-keyword">else</span> {
      node.label = <span class="hljs-keyword">this</span>.tok.type === tt.name ? <span class="hljs-keyword">this</span>.parseIdent() : <span class="hljs-literal">null</span>
      <span class="hljs-keyword">this</span>.semicolon()
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, isBreak ? <span class="hljs-string">"BreakStatement"</span> : <span class="hljs-string">"ContinueStatement"</span>)

  <span class="hljs-keyword">case</span> tt._debugger:
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">this</span>.semicolon()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"DebuggerStatement"</span>)

  <span class="hljs-keyword">case</span> tt._do:
    <span class="hljs-keyword">this</span>.next()
    node.body = <span class="hljs-keyword">this</span>.parseStatement()
    node.test = <span class="hljs-keyword">this</span>.eat(tt._while) ? <span class="hljs-keyword">this</span>.parseParenExpression() : <span class="hljs-keyword">this</span>.dummyIdent()
    <span class="hljs-keyword">this</span>.semicolon()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"DoWhileStatement"</span>)

  <span class="hljs-keyword">case</span> tt._for:
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">this</span>.pushCx()
    <span class="hljs-keyword">this</span>.expect(tt.parenL)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.semi) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFor(node, <span class="hljs-literal">null</span>)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt._var || <span class="hljs-keyword">this</span>.tok.type === tt._let || <span class="hljs-keyword">this</span>.tok.type === tt._const) {
      <span class="hljs-keyword">let</span> init = <span class="hljs-keyword">this</span>.parseVar(<span class="hljs-literal">true</span>)
      <span class="hljs-keyword">if</span> (init.declarations.length === <span class="hljs-number">1</span> &amp;&amp; (<span class="hljs-keyword">this</span>.tok.type === tt._in || <span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"of"</span>))) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseForIn(node, init)
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFor(node, init)
    }
    <span class="hljs-keyword">let</span> init = <span class="hljs-keyword">this</span>.parseExpression(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt._in || <span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"of"</span>))
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseForIn(node, <span class="hljs-keyword">this</span>.toAssignable(init))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFor(node, init)

  <span class="hljs-keyword">case</span> tt._function:
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseFunction(node, <span class="hljs-literal">true</span>)

  <span class="hljs-keyword">case</span> tt._if:
    <span class="hljs-keyword">this</span>.next()
    node.test = <span class="hljs-keyword">this</span>.parseParenExpression()
    node.consequent = <span class="hljs-keyword">this</span>.parseStatement()
    node.alternate = <span class="hljs-keyword">this</span>.eat(tt._else) ? <span class="hljs-keyword">this</span>.parseStatement() : <span class="hljs-literal">null</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"IfStatement"</span>)

  <span class="hljs-keyword">case</span> tt._return:
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.semi) || <span class="hljs-keyword">this</span>.canInsertSemicolon()) node.argument = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">else</span> { node.argument = <span class="hljs-keyword">this</span>.parseExpression(); <span class="hljs-keyword">this</span>.semicolon() }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ReturnStatement"</span>)

  <span class="hljs-keyword">case</span> tt._switch:
    <span class="hljs-keyword">let</span> blockIndent = <span class="hljs-keyword">this</span>.curIndent, line = <span class="hljs-keyword">this</span>.curLineStart
    <span class="hljs-keyword">this</span>.next()
    node.discriminant = <span class="hljs-keyword">this</span>.parseParenExpression()
    node.cases = []
    <span class="hljs-keyword">this</span>.pushCx()
    <span class="hljs-keyword">this</span>.expect(tt.braceL)

    <span class="hljs-keyword">let</span> cur
    <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(tt.braceR, blockIndent, line, <span class="hljs-literal">true</span>)) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt._case || <span class="hljs-keyword">this</span>.tok.type === tt._default) {
        <span class="hljs-keyword">let</span> isCase = <span class="hljs-keyword">this</span>.tok.type === tt._case
        <span class="hljs-keyword">if</span> (cur) <span class="hljs-keyword">this</span>.finishNode(cur, <span class="hljs-string">"SwitchCase"</span>)
        node.cases.push(cur = <span class="hljs-keyword">this</span>.startNode())
        cur.consequent = []
        <span class="hljs-keyword">this</span>.next()
        <span class="hljs-keyword">if</span> (isCase) cur.test = <span class="hljs-keyword">this</span>.parseExpression()
        <span class="hljs-keyword">else</span> cur.test = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">this</span>.expect(tt.colon)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (!cur) {
          node.cases.push(cur = <span class="hljs-keyword">this</span>.startNode())
          cur.consequent = []
          cur.test = <span class="hljs-literal">null</span>
        }
        cur.consequent.push(<span class="hljs-keyword">this</span>.parseStatement())
      }
    }
    <span class="hljs-keyword">if</span> (cur) <span class="hljs-keyword">this</span>.finishNode(cur, <span class="hljs-string">"SwitchCase"</span>)
    <span class="hljs-keyword">this</span>.popCx()
    <span class="hljs-keyword">this</span>.eat(tt.braceR)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"SwitchStatement"</span>)

  <span class="hljs-keyword">case</span> tt._throw:
    <span class="hljs-keyword">this</span>.next()
    node.argument = <span class="hljs-keyword">this</span>.parseExpression()
    <span class="hljs-keyword">this</span>.semicolon()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ThrowStatement"</span>)

  <span class="hljs-keyword">case</span> tt._try:
    <span class="hljs-keyword">this</span>.next()
    node.block = <span class="hljs-keyword">this</span>.parseBlock()
    node.handler = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt._catch) {
      <span class="hljs-keyword">let</span> clause = <span class="hljs-keyword">this</span>.startNode()
      <span class="hljs-keyword">this</span>.next()
      <span class="hljs-keyword">this</span>.expect(tt.parenL)
      clause.param = <span class="hljs-keyword">this</span>.toAssignable(<span class="hljs-keyword">this</span>.parseExprAtom(), <span class="hljs-literal">true</span>)
      <span class="hljs-keyword">this</span>.expect(tt.parenR)
      clause.guard = <span class="hljs-literal">null</span>
      clause.body = <span class="hljs-keyword">this</span>.parseBlock()
      node.handler = <span class="hljs-keyword">this</span>.finishNode(clause, <span class="hljs-string">"CatchClause"</span>)
    }
    node.finalizer = <span class="hljs-keyword">this</span>.eat(tt._finally) ? <span class="hljs-keyword">this</span>.parseBlock() : <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (!node.handler &amp;&amp; !node.finalizer) <span class="hljs-keyword">return</span> node.block
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"TryStatement"</span>)

  <span class="hljs-keyword">case</span> tt._var:
  <span class="hljs-keyword">case</span> tt._let:
  <span class="hljs-keyword">case</span> tt._const:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseVar()

  <span class="hljs-keyword">case</span> tt._while:
    <span class="hljs-keyword">this</span>.next()
    node.test = <span class="hljs-keyword">this</span>.parseParenExpression()
    node.body = <span class="hljs-keyword">this</span>.parseStatement()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"WhileStatement"</span>)

  <span class="hljs-keyword">case</span> tt._with:
    <span class="hljs-keyword">this</span>.next()
    node.object = <span class="hljs-keyword">this</span>.parseParenExpression()
    node.body = <span class="hljs-keyword">this</span>.parseStatement()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"WithStatement"</span>)

  <span class="hljs-keyword">case</span> tt.braceL:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseBlock()

  <span class="hljs-keyword">case</span> tt.semi:
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"EmptyStatement"</span>)

  <span class="hljs-keyword">case</span> tt._class:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseClass(<span class="hljs-literal">true</span>)

  <span class="hljs-keyword">case</span> tt._import:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseImport()

  <span class="hljs-keyword">case</span> tt._export:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseExport()

  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">let</span> expr = <span class="hljs-keyword">this</span>.parseExpression()
    <span class="hljs-keyword">if</span> (isDummy(expr)) {
      <span class="hljs-keyword">this</span>.next()
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.eof) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"EmptyStatement"</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseStatement()
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (starttype === tt.name &amp;&amp; expr.type === <span class="hljs-string">"Identifier"</span> &amp;&amp; <span class="hljs-keyword">this</span>.eat(tt.colon)) {
      node.body = <span class="hljs-keyword">this</span>.parseStatement()
      node.label = expr
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"LabeledStatement"</span>)
    } <span class="hljs-keyword">else</span> {
      node.expression = expr
      <span class="hljs-keyword">this</span>.semicolon()
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExpressionStatement"</span>)
    }
  }
}

lp.parseBlock = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  <span class="hljs-keyword">this</span>.pushCx()
  <span class="hljs-keyword">this</span>.expect(tt.braceL)
  <span class="hljs-keyword">let</span> blockIndent = <span class="hljs-keyword">this</span>.curIndent, line = <span class="hljs-keyword">this</span>.curLineStart
  node.body = []
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(tt.braceR, blockIndent, line, <span class="hljs-literal">true</span>))
    node.body.push(<span class="hljs-keyword">this</span>.parseStatement())
  <span class="hljs-keyword">this</span>.popCx()
  <span class="hljs-keyword">this</span>.eat(tt.braceR)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"BlockStatement"</span>)
}

lp.parseFor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, init</span>) </span>{
  node.init = init
  node.test = node.update = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.semi) &amp;&amp; <span class="hljs-keyword">this</span>.tok.type !== tt.semi) node.test = <span class="hljs-keyword">this</span>.parseExpression()
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.semi) &amp;&amp; <span class="hljs-keyword">this</span>.tok.type !== tt.parenR) node.update = <span class="hljs-keyword">this</span>.parseExpression()
  <span class="hljs-keyword">this</span>.popCx()
  <span class="hljs-keyword">this</span>.expect(tt.parenR)
  node.body = <span class="hljs-keyword">this</span>.parseStatement()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ForStatement"</span>)
}

lp.parseForIn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, init</span>) </span>{
  <span class="hljs-keyword">let</span> type = <span class="hljs-keyword">this</span>.tok.type === tt._in ? <span class="hljs-string">"ForInStatement"</span> : <span class="hljs-string">"ForOfStatement"</span>
  <span class="hljs-keyword">this</span>.next()
  node.left = init
  node.right = <span class="hljs-keyword">this</span>.parseExpression()
  <span class="hljs-keyword">this</span>.popCx()
  <span class="hljs-keyword">this</span>.expect(tt.parenR)
  node.body = <span class="hljs-keyword">this</span>.parseStatement()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, type)
}

lp.parseVar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">noIn</span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  node.kind = <span class="hljs-keyword">this</span>.tok.type.keyword
  <span class="hljs-keyword">this</span>.next()
  node.declarations = []
  <span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">let</span> decl = <span class="hljs-keyword">this</span>.startNode()
    decl.id = <span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span> ? <span class="hljs-keyword">this</span>.toAssignable(<span class="hljs-keyword">this</span>.parseExprAtom(), <span class="hljs-literal">true</span>) : <span class="hljs-keyword">this</span>.parseIdent()
    decl.init = <span class="hljs-keyword">this</span>.eat(tt.eq) ? <span class="hljs-keyword">this</span>.parseMaybeAssign(noIn) : <span class="hljs-literal">null</span>
    node.declarations.push(<span class="hljs-keyword">this</span>.finishNode(decl, <span class="hljs-string">"VariableDeclarator"</span>))
  } <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.eat(tt.comma))
  <span class="hljs-keyword">if</span> (!node.declarations.length) {
    <span class="hljs-keyword">let</span> decl = <span class="hljs-keyword">this</span>.startNode()
    decl.id = <span class="hljs-keyword">this</span>.dummyIdent()
    node.declarations.push(<span class="hljs-keyword">this</span>.finishNode(decl, <span class="hljs-string">"VariableDeclarator"</span>))
  }
  <span class="hljs-keyword">if</span> (!noIn) <span class="hljs-keyword">this</span>.semicolon()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"VariableDeclaration"</span>)
}

lp.parseClass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">isStatement</span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.name) node.id = <span class="hljs-keyword">this</span>.parseIdent()
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isStatement) node.id = <span class="hljs-keyword">this</span>.dummyIdent()
  <span class="hljs-keyword">else</span> node.id = <span class="hljs-literal">null</span>
  node.superClass = <span class="hljs-keyword">this</span>.eat(tt._extends) ? <span class="hljs-keyword">this</span>.parseExpression() : <span class="hljs-literal">null</span>
  node.body = <span class="hljs-keyword">this</span>.startNode()
  node.body.body = []
  <span class="hljs-keyword">this</span>.pushCx()
  <span class="hljs-keyword">let</span> indent = <span class="hljs-keyword">this</span>.curIndent + <span class="hljs-number">1</span>, line = <span class="hljs-keyword">this</span>.curLineStart
  <span class="hljs-keyword">this</span>.eat(tt.braceL)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curIndent + <span class="hljs-number">1</span> &lt; indent) { indent = <span class="hljs-keyword">this</span>.curIndent; line = <span class="hljs-keyword">this</span>.curLineStart }
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(tt.braceR, indent, line)) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.semicolon()) <span class="hljs-keyword">continue</span>
    <span class="hljs-keyword">let</span> method = <span class="hljs-keyword">this</span>.startNode(), isGenerator
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
      method.static = <span class="hljs-literal">false</span>
      isGenerator = <span class="hljs-keyword">this</span>.eat(tt.star)
    }
    <span class="hljs-keyword">this</span>.parsePropertyName(method)
    <span class="hljs-keyword">if</span> (isDummy(method.key)) { <span class="hljs-keyword">if</span> (isDummy(<span class="hljs-keyword">this</span>.parseMaybeAssign())) <span class="hljs-keyword">this</span>.next(); <span class="hljs-keyword">this</span>.eat(tt.comma); <span class="hljs-keyword">continue</span> }
    <span class="hljs-keyword">if</span> (method.key.type === <span class="hljs-string">"Identifier"</span> &amp;&amp; !method.computed &amp;&amp; method.key.name === <span class="hljs-string">"static"</span> &amp;&amp;
        (<span class="hljs-keyword">this</span>.tok.type != tt.parenL &amp;&amp; <span class="hljs-keyword">this</span>.tok.type != tt.braceL)) {
      method.static = <span class="hljs-literal">true</span>
      isGenerator = <span class="hljs-keyword">this</span>.eat(tt.star)
      <span class="hljs-keyword">this</span>.parsePropertyName(method)
    } <span class="hljs-keyword">else</span> {
      method.static = <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">5</span> &amp;&amp; method.key.type === <span class="hljs-string">"Identifier"</span> &amp;&amp;
        !method.computed &amp;&amp; (method.key.name === <span class="hljs-string">"get"</span> || method.key.name === <span class="hljs-string">"set"</span>) &amp;&amp;
        <span class="hljs-keyword">this</span>.tok.type !== tt.parenL &amp;&amp; <span class="hljs-keyword">this</span>.tok.type !== tt.braceL) {
      method.kind = method.key.name
      <span class="hljs-keyword">this</span>.parsePropertyName(method)
      method.value = <span class="hljs-keyword">this</span>.parseMethod(<span class="hljs-literal">false</span>)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (!method.computed &amp;&amp; !method.static &amp;&amp; !isGenerator &amp;&amp; (
        method.key.type === <span class="hljs-string">"Identifier"</span> &amp;&amp; method.key.name === <span class="hljs-string">"constructor"</span> ||
          method.key.type === <span class="hljs-string">"Literal"</span> &amp;&amp; method.key.value === <span class="hljs-string">"constructor"</span>)) {
        method.kind = <span class="hljs-string">"constructor"</span>
      } <span class="hljs-keyword">else</span> {
        method.kind =  <span class="hljs-string">"method"</span>
      }
      method.value = <span class="hljs-keyword">this</span>.parseMethod(isGenerator)
    }
    node.body.body.push(<span class="hljs-keyword">this</span>.finishNode(method, <span class="hljs-string">"MethodDefinition"</span>))
  }
  <span class="hljs-keyword">this</span>.popCx()
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.eat(tt.braceR)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>If there is no closing brace, make the node span to the start
of the next token (this is useful for Tern)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.last.end = <span class="hljs-keyword">this</span>.tok.start
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) <span class="hljs-keyword">this</span>.last.loc.end = <span class="hljs-keyword">this</span>.tok.loc.start
  }
  <span class="hljs-keyword">this</span>.semicolon()
  <span class="hljs-keyword">this</span>.finishNode(node.body, <span class="hljs-string">"ClassBody"</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, isStatement ? <span class="hljs-string">"ClassDeclaration"</span> : <span class="hljs-string">"ClassExpression"</span>)
}

lp.parseFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, isStatement</span>) </span>{
  <span class="hljs-keyword">this</span>.initFunction(node)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.ecmaVersion &gt;= <span class="hljs-number">6</span>) {
    node.generator = <span class="hljs-keyword">this</span>.eat(tt.star)
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.name) node.id = <span class="hljs-keyword">this</span>.parseIdent()
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isStatement) node.id = <span class="hljs-keyword">this</span>.dummyIdent()
  node.params = <span class="hljs-keyword">this</span>.parseFunctionParams()
  node.body = <span class="hljs-keyword">this</span>.parseBlock()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, isStatement ? <span class="hljs-string">"FunctionDeclaration"</span> : <span class="hljs-string">"FunctionExpression"</span>)
}

lp.parseExport = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.star)) {
    node.source = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"from"</span>) ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-literal">null</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExportAllDeclaration"</span>)
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt._default)) {
    <span class="hljs-keyword">let</span> expr = <span class="hljs-keyword">this</span>.parseMaybeAssign()
    <span class="hljs-keyword">if</span> (expr.id) {
      <span class="hljs-keyword">switch</span> (expr.type) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"FunctionExpression"</span>: expr.type = <span class="hljs-string">"FunctionDeclaration"</span>; <span class="hljs-keyword">break</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">"ClassExpression"</span>: expr.type = <span class="hljs-string">"ClassDeclaration"</span>; <span class="hljs-keyword">break</span>
      }
    }
    node.declaration = expr
    <span class="hljs-keyword">this</span>.semicolon()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExportDefaultDeclaration"</span>)
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type.keyword) {
    node.declaration = <span class="hljs-keyword">this</span>.parseStatement()
    node.specifiers = []
    node.source = <span class="hljs-literal">null</span>
  } <span class="hljs-keyword">else</span> {
    node.declaration = <span class="hljs-literal">null</span>
    node.specifiers = <span class="hljs-keyword">this</span>.parseExportSpecifierList()
    node.source = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"from"</span>) ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-literal">null</span>
    <span class="hljs-keyword">this</span>.semicolon()
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ExportNamedDeclaration"</span>)
}

lp.parseImport = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode()
  <span class="hljs-keyword">this</span>.next()
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.string) {
    node.specifiers = []
    node.source = <span class="hljs-keyword">this</span>.parseExprAtom()
    node.kind = <span class="hljs-string">''</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">let</span> elt
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.name &amp;&amp; <span class="hljs-keyword">this</span>.tok.value !== <span class="hljs-string">"from"</span>) {
      elt = <span class="hljs-keyword">this</span>.startNode()
      elt.local = <span class="hljs-keyword">this</span>.parseIdent()
      <span class="hljs-keyword">this</span>.finishNode(elt, <span class="hljs-string">"ImportDefaultSpecifier"</span>)
      <span class="hljs-keyword">this</span>.eat(tt.comma)
    }
    node.specifiers = <span class="hljs-keyword">this</span>.parseImportSpecifierList()
    node.source = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"from"</span>) ? <span class="hljs-keyword">this</span>.parseExprAtom() : <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (elt) node.specifiers.unshift(elt)
  }
  <span class="hljs-keyword">this</span>.semicolon()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">"ImportDeclaration"</span>)
}

lp.parseImportSpecifierList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> elts = []
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tok.type === tt.star) {
    <span class="hljs-keyword">let</span> elt = <span class="hljs-keyword">this</span>.startNode()
    <span class="hljs-keyword">this</span>.next()
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"as"</span>)) elt.local = <span class="hljs-keyword">this</span>.parseIdent()
    elts.push(<span class="hljs-keyword">this</span>.finishNode(elt, <span class="hljs-string">"ImportNamespaceSpecifier"</span>))
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">let</span> indent = <span class="hljs-keyword">this</span>.curIndent, line = <span class="hljs-keyword">this</span>.curLineStart, continuedLine = <span class="hljs-keyword">this</span>.nextLineStart
    <span class="hljs-keyword">this</span>.pushCx()
    <span class="hljs-keyword">this</span>.eat(tt.braceL)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curLineStart &gt; continuedLine) continuedLine = <span class="hljs-keyword">this</span>.curLineStart
    <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(tt.braceR, indent + (<span class="hljs-keyword">this</span>.curLineStart &lt;= continuedLine ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), line)) {
      <span class="hljs-keyword">let</span> elt = <span class="hljs-keyword">this</span>.startNode()
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.star)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"as"</span>)) elt.local = <span class="hljs-keyword">this</span>.parseIdent()
        <span class="hljs-keyword">this</span>.finishNode(elt, <span class="hljs-string">"ImportNamespaceSpecifier"</span>)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"from"</span>)) <span class="hljs-keyword">break</span>
        elt.imported = <span class="hljs-keyword">this</span>.parseIdent()
        elt.local = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"as"</span>) ? <span class="hljs-keyword">this</span>.parseIdent() : elt.imported
        <span class="hljs-keyword">this</span>.finishNode(elt, <span class="hljs-string">"ImportSpecifier"</span>)
      }
      elts.push(elt)
      <span class="hljs-keyword">this</span>.eat(tt.comma)
    }
    <span class="hljs-keyword">this</span>.eat(tt.braceR)
    <span class="hljs-keyword">this</span>.popCx()
  }
  <span class="hljs-keyword">return</span> elts
}

lp.parseExportSpecifierList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> elts = []
  <span class="hljs-keyword">let</span> indent = <span class="hljs-keyword">this</span>.curIndent, line = <span class="hljs-keyword">this</span>.curLineStart, continuedLine = <span class="hljs-keyword">this</span>.nextLineStart
  <span class="hljs-keyword">this</span>.pushCx()
  <span class="hljs-keyword">this</span>.eat(tt.braceL)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curLineStart &gt; continuedLine) continuedLine = <span class="hljs-keyword">this</span>.curLineStart
  <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.closes(tt.braceR, indent + (<span class="hljs-keyword">this</span>.curLineStart &lt;= continuedLine ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), line)) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isContextual(<span class="hljs-string">"from"</span>)) <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">let</span> elt = <span class="hljs-keyword">this</span>.startNode()
    elt.local = <span class="hljs-keyword">this</span>.parseIdent()
    elt.exported = <span class="hljs-keyword">this</span>.eatContextual(<span class="hljs-string">"as"</span>) ? <span class="hljs-keyword">this</span>.parseIdent() : elt.local
    <span class="hljs-keyword">this</span>.finishNode(elt, <span class="hljs-string">"ExportSpecifier"</span>)
    elts.push(elt)
    <span class="hljs-keyword">this</span>.eat(tt.comma)
  }
  <span class="hljs-keyword">this</span>.eat(tt.braceR)
  <span class="hljs-keyword">this</span>.popCx()
  <span class="hljs-keyword">return</span> elts
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
