<!DOCTYPE html>
<html>
<head>
  <title>patcher.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/recast/lib/patcher.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>patcher.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">"assert"</span>);
<span class="hljs-keyword">var</span> linesModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./lines"</span>);
<span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>);
<span class="hljs-keyword">var</span> getFieldValue = types.getFieldValue;
<span class="hljs-keyword">var</span> Printable = types.namedTypes.Printable;
<span class="hljs-keyword">var</span> Expression = types.namedTypes.Expression;
<span class="hljs-keyword">var</span> SourceLocation = types.namedTypes.SourceLocation;
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./util"</span>);
<span class="hljs-keyword">var</span> comparePos = util.comparePos;
<span class="hljs-keyword">var</span> FastPath = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./fast-path"</span>);
<span class="hljs-keyword">var</span> isObject = types.builtInTypes.object;
<span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
<span class="hljs-keyword">var</span> isString = types.builtInTypes.string;
<span class="hljs-keyword">var</span> riskyAdjoiningCharExp = <span class="hljs-regexp">/[0-9a-z_$]/i</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Patcher</span>(<span class="hljs-params">lines</span>) </span>{
    assert.ok(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Patcher);
    assert.ok(lines <span class="hljs-keyword">instanceof</span> linesModule.Lines);

    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>,
        replacements = [];

    self.replace = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">loc, lines</span>) </span>{
        <span class="hljs-keyword">if</span> (isString.check(lines))
            lines = linesModule.fromString(lines);

        replacements.push({
            <span class="hljs-attr">lines</span>: lines,
            <span class="hljs-attr">start</span>: loc.start,
            <span class="hljs-attr">end</span>: loc.end
        });
    };

    self.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">loc</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>If no location is provided, return the complete Lines object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        loc = loc || {
            <span class="hljs-attr">start</span>: { <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">column</span>: <span class="hljs-number">0</span> },
            <span class="hljs-attr">end</span>: { <span class="hljs-attr">line</span>: lines.length,
                   <span class="hljs-attr">column</span>: lines.getLineLength(lines.length) }
        };

        <span class="hljs-keyword">var</span> sliceFrom = loc.start,
            toConcat = [];

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushSlice</span>(<span class="hljs-params">from, to</span>) </span>{
            assert.ok(comparePos(<span class="hljs-keyword">from</span>, to) &lt;= <span class="hljs-number">0</span>);
            toConcat.push(lines.slice(<span class="hljs-keyword">from</span>, to));
        }

        replacements.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
            <span class="hljs-keyword">return</span> comparePos(a.start, b.start);
        }).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rep</span>) </span>{
            <span class="hljs-keyword">if</span> (comparePos(sliceFrom, rep.start) &gt; <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Ignore nested replacement ranges.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            } <span class="hljs-keyword">else</span> {
                pushSlice(sliceFrom, rep.start);
                toConcat.push(rep.lines);
                sliceFrom = rep.end;
            }
        });

        pushSlice(sliceFrom, loc.end);

        <span class="hljs-keyword">return</span> linesModule.concat(toConcat);
    };
}
exports.Patcher = Patcher;

<span class="hljs-keyword">var</span> Pp = Patcher.prototype;

Pp.tryToReprintComments = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newNode, oldNode, print</span>) </span>{
    <span class="hljs-keyword">var</span> patcher = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">if</span> (!newNode.comments &amp;&amp;
        !oldNode.comments) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>We were (vacuously) able to reprint all the comments!</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">var</span> newPath = FastPath.from(newNode);
    <span class="hljs-keyword">var</span> oldPath = FastPath.from(oldNode);

    newPath.stack.push(<span class="hljs-string">"comments"</span>, getSurroundingComments(newNode));
    oldPath.stack.push(<span class="hljs-string">"comments"</span>, getSurroundingComments(oldNode));

    <span class="hljs-keyword">var</span> reprints = [];
    <span class="hljs-keyword">var</span> ableToReprintComments =
        findArrayReprints(newPath, oldPath, reprints);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>No need to pop anything from newPath.stack or oldPath.stack, since
newPath and oldPath are fresh local variables.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">if</span> (ableToReprintComments &amp;&amp; reprints.length &gt; <span class="hljs-number">0</span>) {
        reprints.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reprint</span>) </span>{
            <span class="hljs-keyword">var</span> oldComment = reprint.oldPath.getValue();
            assert.ok(oldComment.leading || oldComment.trailing);
            patcher.replace(
                oldComment.loc,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Comments can't have .comments, so it doesn't matter
whether we print with comments or without.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                print(reprint.newPath).indentTail(oldComment.loc.indent)
            );
        });
    }

    <span class="hljs-keyword">return</span> ableToReprintComments;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Get all comments that are either leading or trailing, ignoring any
comments that occur inside node.loc. Returns an empty array for nodes
with no leading or trailing comments.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSurroundingComments</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">var</span> result = [];
    <span class="hljs-keyword">if</span> (node.comments &amp;&amp;
        node.comments.length &gt; <span class="hljs-number">0</span>) {
        node.comments.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">comment</span>) </span>{
            <span class="hljs-keyword">if</span> (comment.leading || comment.trailing) {
                result.push(comment);
            }
        });
    }
    <span class="hljs-keyword">return</span> result;
}

Pp.deleteComments = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (!node.comments) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> patcher = <span class="hljs-keyword">this</span>;

    node.comments.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">comment</span>) </span>{
        <span class="hljs-keyword">if</span> (comment.leading) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Delete leading comments along with any trailing whitespace
they might have.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            patcher.replace({
                <span class="hljs-attr">start</span>: comment.loc.start,
                <span class="hljs-attr">end</span>: node.loc.lines.skipSpaces(
                    comment.loc.end, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)
            }, <span class="hljs-string">""</span>);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (comment.trailing) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Delete trailing comments along with any leading whitespace
they might have.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            patcher.replace({
                <span class="hljs-attr">start</span>: node.loc.lines.skipSpaces(
                    comment.loc.start, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>),
                <span class="hljs-attr">end</span>: comment.loc.end
            }, <span class="hljs-string">""</span>);
        }
    });
};

exports.getReprinter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
    assert.ok(path <span class="hljs-keyword">instanceof</span> FastPath);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Make sure that this path refers specifically to a Node, rather than
some non-Node subproperty of a Node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> node = path.getValue();
    <span class="hljs-keyword">if</span> (!Printable.check(node))
        <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">var</span> orig = node.original;
    <span class="hljs-keyword">var</span> origLoc = orig &amp;&amp; orig.loc;
    <span class="hljs-keyword">var</span> lines = origLoc &amp;&amp; origLoc.lines;
    <span class="hljs-keyword">var</span> reprints = [];

    <span class="hljs-keyword">if</span> (!lines || !findReprints(path, reprints))
        <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">print</span>) </span>{
        <span class="hljs-keyword">var</span> patcher = <span class="hljs-keyword">new</span> Patcher(lines);

        reprints.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reprint</span>) </span>{
            <span class="hljs-keyword">var</span> newNode = reprint.newPath.getValue();
            <span class="hljs-keyword">var</span> oldNode = reprint.oldPath.getValue();

            SourceLocation.assert(oldNode.loc, <span class="hljs-literal">true</span>);

            <span class="hljs-keyword">var</span> needToPrintNewPathWithComments =
                !patcher.tryToReprintComments(newNode, oldNode, print)

            <span class="hljs-keyword">if</span> (needToPrintNewPathWithComments) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Since we were not able to preserve all leading/trailing
comments, we delete oldNode's comments, print newPath
with comments, and then patch the resulting lines where
oldNode used to be.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                patcher.deleteComments(oldNode);
            }

            <span class="hljs-keyword">var</span> newLines = print(
                reprint.newPath,
                needToPrintNewPathWithComments
            ).indentTail(oldNode.loc.indent);

            <span class="hljs-keyword">var</span> nls = needsLeadingSpace(lines, oldNode.loc, newLines);
            <span class="hljs-keyword">var</span> nts = needsTrailingSpace(lines, oldNode.loc, newLines);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>If we try to replace the argument of a ReturnStatement like
return&quot;asdf&quot; with e.g. a literal null expression, we run
the risk of ending up with returnnull, so we need to add an
extra leading space in situations where that might
happen. Likewise for &quot;asdf&quot;in obj. See #170.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (nls || nts) {
                <span class="hljs-keyword">var</span> newParts = [];
                nls &amp;&amp; newParts.push(<span class="hljs-string">" "</span>);
                newParts.push(newLines);
                nts &amp;&amp; newParts.push(<span class="hljs-string">" "</span>);
                newLines = linesModule.concat(newParts);
            }

            patcher.replace(oldNode.loc, newLines);
        });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>Recall that origLoc is the .loc of an ancestor node that is
guaranteed to contain all the reprinted nodes and comments.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> patcher.get(origLoc).indentTail(-orig.loc.indent);
    };
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>If the last character before oldLoc and the first character of newLines
are both identifier characters, they must be separated by a space,
otherwise they will most likely get fused together into a single token.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">needsLeadingSpace</span>(<span class="hljs-params">oldLines, oldLoc, newLines</span>) </span>{
    <span class="hljs-keyword">var</span> posBeforeOldLoc = util.copyPos(oldLoc.start);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>The character just before the location occupied by oldNode.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> charBeforeOldLoc =
        oldLines.prevPos(posBeforeOldLoc) &amp;&amp;
        oldLines.charAt(posBeforeOldLoc);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>First character of the reprinted node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> newFirstChar = newLines.charAt(newLines.firstPos());

    <span class="hljs-keyword">return</span> charBeforeOldLoc &amp;&amp;
        riskyAdjoiningCharExp.test(charBeforeOldLoc) &amp;&amp;
        newFirstChar &amp;&amp;
        riskyAdjoiningCharExp.test(newFirstChar);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>If the last character of newLines and the first character after oldLoc
are both identifier characters, they must be separated by a space,
otherwise they will most likely get fused together into a single token.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">needsTrailingSpace</span>(<span class="hljs-params">oldLines, oldLoc, newLines</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>The character just after the location occupied by oldNode.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> charAfterOldLoc = oldLines.charAt(oldLoc.end);

    <span class="hljs-keyword">var</span> newLastPos = newLines.lastPos();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>Last character of the reprinted node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> newLastChar = newLines.prevPos(newLastPos) &amp;&amp;
        newLines.charAt(newLastPos);

    <span class="hljs-keyword">return</span> newLastChar &amp;&amp;
        riskyAdjoiningCharExp.test(newLastChar) &amp;&amp;
        charAfterOldLoc &amp;&amp;
        riskyAdjoiningCharExp.test(charAfterOldLoc);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findReprints</span>(<span class="hljs-params">newPath, reprints</span>) </span>{
    <span class="hljs-keyword">var</span> newNode = newPath.getValue();
    Printable.assert(newNode);

    <span class="hljs-keyword">var</span> oldNode = newNode.original;
    Printable.assert(oldNode);

    assert.deepEqual(reprints, []);

    <span class="hljs-keyword">if</span> (newNode.type !== oldNode.type) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> oldPath = <span class="hljs-keyword">new</span> FastPath(oldNode);
    <span class="hljs-keyword">var</span> canReprint = findChildReprints(newPath, oldPath, reprints);

    <span class="hljs-keyword">if</span> (!canReprint) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Make absolutely sure the calling code does not attempt to reprint
any nodes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        reprints.length = <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">return</span> canReprint;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findAnyReprints</span>(<span class="hljs-params">newPath, oldPath, reprints</span>) </span>{
    <span class="hljs-keyword">var</span> newNode = newPath.getValue();
    <span class="hljs-keyword">var</span> oldNode = oldPath.getValue();

    <span class="hljs-keyword">if</span> (newNode === oldNode)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">if</span> (isArray.check(newNode))
        <span class="hljs-keyword">return</span> findArrayReprints(newPath, oldPath, reprints);

    <span class="hljs-keyword">if</span> (isObject.check(newNode))
        <span class="hljs-keyword">return</span> findObjectReprints(newPath, oldPath, reprints);

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findArrayReprints</span>(<span class="hljs-params">newPath, oldPath, reprints</span>) </span>{
    <span class="hljs-keyword">var</span> newNode = newPath.getValue();
    <span class="hljs-keyword">var</span> oldNode = oldPath.getValue();
    isArray.assert(newNode);
    <span class="hljs-keyword">var</span> len = newNode.length;

    <span class="hljs-keyword">if</span> (!(isArray.check(oldNode) &amp;&amp;
          oldNode.length === len))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) {
        newPath.stack.push(i, newNode[i]);
        oldPath.stack.push(i, oldNode[i]);
        <span class="hljs-keyword">var</span> canReprint = findAnyReprints(newPath, oldPath, reprints);
        newPath.stack.length -= <span class="hljs-number">2</span>;
        oldPath.stack.length -= <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (!canReprint) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findObjectReprints</span>(<span class="hljs-params">newPath, oldPath, reprints</span>) </span>{
    <span class="hljs-keyword">var</span> newNode = newPath.getValue();
    isObject.assert(newNode);

    <span class="hljs-keyword">if</span> (newNode.original === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>If newNode.original node was set to null, reprint the node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> oldNode = oldPath.getValue();
    <span class="hljs-keyword">if</span> (!isObject.check(oldNode))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (Printable.check(newNode)) {
        <span class="hljs-keyword">if</span> (!Printable.check(oldNode)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>Here we need to decide whether the reprinted code for newNode
is appropriate for patching into the location of oldNode.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (newNode.type === oldNode.type) {
            <span class="hljs-keyword">var</span> childReprints = [];

            <span class="hljs-keyword">if</span> (findChildReprints(newPath, oldPath, childReprints)) {
                reprints.push.apply(reprints, childReprints);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldNode.loc) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>If we have no .loc information for oldNode, then we
won't be able to reprint it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                reprints.push({
                    <span class="hljs-attr">oldPath</span>: oldPath.copy(),
                    <span class="hljs-attr">newPath</span>: newPath.copy()
                });
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (Expression.check(newNode) &amp;&amp;
            Expression.check(oldNode) &amp;&amp;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>If we have no .loc information for oldNode, then we won't
be able to reprint it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            oldNode.loc) {

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>If both nodes are subtypes of Expression, then we should be
able to fill the location occupied by the old node with
code printed for the new node with no ill consequences.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            reprints.push({
                <span class="hljs-attr">oldPath</span>: oldPath.copy(),
                <span class="hljs-attr">newPath</span>: newPath.copy()
            });

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>The nodes have different types, and at least one of the types
is not a subtype of the Expression type, so we cannot safely
assume the nodes are syntactically interchangeable.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> findChildReprints(newPath, oldPath, reprints);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>This object is reused in hasOpeningParen and hasClosingParen to avoid
having to allocate a temporary object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> reusablePos = { <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">column</span>: <span class="hljs-number">0</span> };
<span class="hljs-keyword">var</span> nonSpaceExp = <span class="hljs-regexp">/\S/</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasOpeningParen</span>(<span class="hljs-params">oldPath</span>) </span>{
    <span class="hljs-keyword">var</span> oldNode = oldPath.getValue();
    <span class="hljs-keyword">var</span> loc = oldNode.loc;
    <span class="hljs-keyword">var</span> lines = loc &amp;&amp; loc.lines;

    <span class="hljs-keyword">if</span> (lines) {
        <span class="hljs-keyword">var</span> pos = reusablePos;
        pos.line = loc.start.line;
        pos.column = loc.start.column;

        <span class="hljs-keyword">while</span> (lines.prevPos(pos)) {
            <span class="hljs-keyword">var</span> ch = lines.charAt(pos);

            <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">"("</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>If we found an opening parenthesis but it occurred before
the start of the original subtree for this reprinting, then
we must not return true for hasOpeningParen(oldPath).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">return</span> comparePos(oldPath.getRootValue().loc.start, pos) &lt;= <span class="hljs-number">0</span>;
            }

            <span class="hljs-keyword">if</span> (nonSpaceExp.test(ch)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasClosingParen</span>(<span class="hljs-params">oldPath</span>) </span>{
    <span class="hljs-keyword">var</span> oldNode = oldPath.getValue();
    <span class="hljs-keyword">var</span> loc = oldNode.loc;
    <span class="hljs-keyword">var</span> lines = loc &amp;&amp; loc.lines;

    <span class="hljs-keyword">if</span> (lines) {
        <span class="hljs-keyword">var</span> pos = reusablePos;
        pos.line = loc.end.line;
        pos.column = loc.end.column;

        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">var</span> ch = lines.charAt(pos);

            <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">")"</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>If we found a closing parenthesis but it occurred after the
end of the original subtree for this reprinting, then we
must not return true for hasClosingParen(oldPath).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">return</span> comparePos(pos, oldPath.getRootValue().loc.end) &lt;= <span class="hljs-number">0</span>;
            }

            <span class="hljs-keyword">if</span> (nonSpaceExp.test(ch)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

        } <span class="hljs-keyword">while</span> (lines.nextPos(pos));
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasParens</span>(<span class="hljs-params">oldPath</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>This logic can technically be fooled if the node has parentheses
but there are comments intervening between the parentheses and the
node. In such cases the node will be harmlessly wrapped in an
additional layer of parentheses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> hasOpeningParen(oldPath) &amp;&amp; hasClosingParen(oldPath);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findChildReprints</span>(<span class="hljs-params">newPath, oldPath, reprints</span>) </span>{
    <span class="hljs-keyword">var</span> newNode = newPath.getValue();
    <span class="hljs-keyword">var</span> oldNode = oldPath.getValue();

    isObject.assert(newNode);
    isObject.assert(oldNode);

    <span class="hljs-keyword">if</span> (newNode.original === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>If newNode.original node was set to null, reprint the node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>If this type of node cannot come lexically first in its enclosing
statement (e.g. a function expression or object literal), and it
seems to be doing so, then the only way we can ignore this problem
and save ourselves from falling back to the pretty printer is if an
opening parenthesis happens to precede the node.  For example,
(function(){ ... }()); does not need to be reprinted, even though
the FunctionExpression comes lexically first in the enclosing
ExpressionStatement and fails the hasParens test, because the
parent CallExpression passes the hasParens test. If we relied on
the path.needsParens() &amp;&amp; !hasParens(oldNode) check below, the
absence of a closing parenthesis after the FunctionExpression would
trigger pretty-printing unnecessarily.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!newPath.canBeFirstInStatement() &amp;&amp;
        newPath.firstInStatement() &amp;&amp;
        !hasOpeningParen(oldPath))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>If this node needs parentheses and will not be wrapped with
parentheses when reprinted, then return false to skip reprinting
and let it be printed generically.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (newPath.needsParens(<span class="hljs-literal">true</span>) &amp;&amp; !hasParens(oldPath)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> util.getUnionOfKeys(newNode, oldNode)) {
        <span class="hljs-keyword">if</span> (k === <span class="hljs-string">"loc"</span>)
            <span class="hljs-keyword">continue</span>;

        newPath.stack.push(k, types.getFieldValue(newNode, k));
        oldPath.stack.push(k, types.getFieldValue(oldNode, k));
        <span class="hljs-keyword">var</span> canReprint = findAnyReprints(newPath, oldPath, reprints);
        newPath.stack.length -= <span class="hljs-number">2</span>;
        oldPath.stack.length -= <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (!canReprint) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
