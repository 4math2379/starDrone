<!DOCTYPE html>
<html>
<head>
  <title>parser.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/recast/lib/parser.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>parser.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">"assert"</span>);
<span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>);
<span class="hljs-keyword">var</span> n = types.namedTypes;
<span class="hljs-keyword">var</span> b = types.builders;
<span class="hljs-keyword">var</span> isObject = types.builtInTypes.object;
<span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
<span class="hljs-keyword">var</span> isFunction = types.builtInTypes.function;
<span class="hljs-keyword">var</span> Patcher = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./patcher"</span>).Patcher;
<span class="hljs-keyword">var</span> normalizeOptions = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./options"</span>).normalize;
<span class="hljs-keyword">var</span> fromString = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./lines"</span>).fromString;
<span class="hljs-keyword">var</span> attachComments = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./comments"</span>).attach;
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./util"</span>);

exports.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">source, options</span>) </span>{
    options = normalizeOptions(options);

    <span class="hljs-keyword">var</span> lines = fromString(source, options);

    <span class="hljs-keyword">var</span> sourceWithoutTabs = lines.toString({
        <span class="hljs-attr">tabWidth</span>: options.tabWidth,
        <span class="hljs-attr">reuseWhitespace</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">useTabs</span>: <span class="hljs-literal">false</span>
    });

    <span class="hljs-keyword">var</span> comments = [];
    <span class="hljs-keyword">var</span> program = options.parser.parse(sourceWithoutTabs, {
        <span class="hljs-attr">loc</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">locations</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">range</span>: options.range,
        <span class="hljs-attr">comment</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">onComment</span>: comments,
        <span class="hljs-attr">tolerant</span>: options.tolerant,
        <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-number">6</span>,
        <span class="hljs-attr">sourceType</span>: <span class="hljs-string">'module'</span>
    });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>If the source was empty, some parsers give loc.{start,end}.line
values of 0, instead of the minimum of 1.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    util.fixFaultyLocations(program, lines);

    program.loc = program.loc || {
        <span class="hljs-attr">start</span>: lines.firstPos(),
        <span class="hljs-attr">end</span>: lines.lastPos()
    };

    program.loc.lines = lines;
    program.loc.indent = <span class="hljs-number">0</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Expand the Program node's .loc to include all comments, since
typically its .loc.start and .loc.end will coincide with those of
the first and last statements, respectively, excluding any comments
that fall outside that region.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> trueProgramLoc = util.getTrueLoc(program, lines);
    program.loc.start = trueProgramLoc.start;
    program.loc.end = trueProgramLoc.end;

    <span class="hljs-keyword">if</span> (program.comments) {
        comments = program.comments;
        <span class="hljs-keyword">delete</span> program.comments;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>In order to ensure we reprint leading and trailing program
comments, wrap the original Program node with a File node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> file = program;
    <span class="hljs-keyword">if</span> (file.type === <span class="hljs-string">"Program"</span>) {
        <span class="hljs-keyword">var</span> file = b.file(program);
        file.loc = {
            <span class="hljs-attr">lines</span>: lines,
            <span class="hljs-attr">indent</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">start</span>: lines.firstPos(),
            <span class="hljs-attr">end</span>: lines.lastPos()
        };
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.type === <span class="hljs-string">"File"</span>) {
      program = file.program;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Passing file.program here instead of just file means that initial
comments will be attached to program.body[0] instead of program.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    attachComments(
        comments,
        program.body.length ? file.program : file,
        lines
    );

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Return a copy of the original AST so that any changes made may be
compared to the original.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeCopier(lines).copy(file);
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TreeCopier</span>(<span class="hljs-params">lines</span>) </span>{
    assert.ok(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> TreeCopier);
    <span class="hljs-keyword">this</span>.lines = lines;
    <span class="hljs-keyword">this</span>.indent = <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">var</span> TCp = TreeCopier.prototype;

TCp.copy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (isArray.check(node)) {
        <span class="hljs-keyword">return</span> node.map(<span class="hljs-keyword">this</span>.copy, <span class="hljs-keyword">this</span>);
    }

    <span class="hljs-keyword">if</span> (!isObject.check(node)) {
        <span class="hljs-keyword">return</span> node;
    }

    util.fixFaultyLocations(node, <span class="hljs-keyword">this</span>.lines);

    <span class="hljs-keyword">var</span> copy = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(node), {
        <span class="hljs-attr">original</span>: { <span class="hljs-comment">// Provide a link from the copy to the original.</span>
            value: node,
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
        }
    });

    <span class="hljs-keyword">var</span> loc = node.loc;
    <span class="hljs-keyword">var</span> oldIndent = <span class="hljs-keyword">this</span>.indent;
    <span class="hljs-keyword">var</span> newIndent = oldIndent;

    <span class="hljs-keyword">if</span> (loc) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>When node is a comment, we set node.loc.indent to
node.loc.start.column so that, when/if we print the comment by
itself, we can strip that much whitespace from the left margin
of the comment. This only really matters for multiline Block
comments, but it doesn't hurt for Line comments.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">"Block"</span> || node.type === <span class="hljs-string">"Line"</span> ||
            node.type === <span class="hljs-string">"CommentBlock"</span> || node.type === <span class="hljs-string">"CommentLine"</span> ||
            <span class="hljs-keyword">this</span>.lines.isPrecededOnlyByWhitespace(loc.start)) {
            newIndent = <span class="hljs-keyword">this</span>.indent = loc.start.column;
        }

        loc.lines = <span class="hljs-keyword">this</span>.lines;
        loc.indent = newIndent;
    }

    <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(node);
    <span class="hljs-keyword">var</span> keyCount = keys.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keyCount; ++i) {
        <span class="hljs-keyword">var</span> key = keys[i];
        <span class="hljs-keyword">if</span> (key === <span class="hljs-string">"loc"</span>) {
            copy[key] = node[key];
        } <span class="hljs-keyword">else</span> {
            copy[key] = <span class="hljs-keyword">this</span>.copy(node[key]);
        }
    }

    <span class="hljs-keyword">this</span>.indent = oldIndent;

    <span class="hljs-keyword">return</span> copy;
};

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
