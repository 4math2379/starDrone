<!DOCTYPE html>
<html>
<head>
  <title>comments.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/recast/lib/comments.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>comments.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">"assert"</span>);
<span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>);
<span class="hljs-keyword">var</span> n = types.namedTypes;
<span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
<span class="hljs-keyword">var</span> isObject = types.builtInTypes.object;
<span class="hljs-keyword">var</span> linesModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./lines"</span>);
<span class="hljs-keyword">var</span> fromString = linesModule.fromString;
<span class="hljs-keyword">var</span> Lines = linesModule.Lines;
<span class="hljs-keyword">var</span> concat = linesModule.concat;
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./util"</span>);
<span class="hljs-keyword">var</span> comparePos = util.comparePos;
<span class="hljs-keyword">var</span> childNodesCacheKey = <span class="hljs-built_in">require</span>(<span class="hljs-string">"private"</span>).makeUniqueKey();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>TODO Move a non-caching implementation of this function into ast-types,
and implement a caching wrapper function here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSortedChildNodes</span>(<span class="hljs-params">node, lines, resultArray</span>) </span>{
    <span class="hljs-keyword">if</span> (!node) {
        <span class="hljs-keyword">return</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>The .loc checks below are sensitive to some of the problems that
are fixed by this utility function. Specifically, if it decides to
set node.loc to null, indicating that the node's .loc information
is unreliable, then we don't want to add node to the resultArray.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    util.fixFaultyLocations(node, lines);

    <span class="hljs-keyword">if</span> (resultArray) {
        <span class="hljs-keyword">if</span> (n.Node.check(node) &amp;&amp;
            n.SourceLocation.check(node.loc)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>This reverse insertion sort almost always takes constant
time because we almost always (maybe always?) append the
nodes in order anyway.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = resultArray.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
                <span class="hljs-keyword">if</span> (comparePos(resultArray[i].loc.end,
                               node.loc.start) &lt;= <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">break</span>;
                }
            }
            resultArray.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, node);
            <span class="hljs-keyword">return</span>;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node[childNodesCacheKey]) {
        <span class="hljs-keyword">return</span> node[childNodesCacheKey];
    }

    <span class="hljs-keyword">var</span> names;
    <span class="hljs-keyword">if</span> (isArray.check(node)) {
        names = <span class="hljs-built_in">Object</span>.keys(node);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject.check(node)) {
        names = types.getFieldNames(node);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (!resultArray) {
        <span class="hljs-built_in">Object</span>.defineProperty(node, childNodesCacheKey, {
            <span class="hljs-attr">value</span>: resultArray = [],
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>
        });
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, nameCount = names.length; i &lt; nameCount; ++i) {
        getSortedChildNodes(node[names[i]], lines, resultArray);
    }

    <span class="hljs-keyword">return</span> resultArray;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>As efficiently as possible, decorate the comment object with
.precedingNode, .enclosingNode, and/or .followingNode properties, at
least one of which is guaranteed to be defined.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decorateComment</span>(<span class="hljs-params">node, comment, lines</span>) </span>{
    <span class="hljs-keyword">var</span> childNodes = getSortedChildNodes(node, lines);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Time to dust off the old binary search robes and wizard hat.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> left = <span class="hljs-number">0</span>, right = childNodes.length;
    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">var</span> middle = (left + right) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> child = childNodes[middle];

        <span class="hljs-keyword">if</span> (comparePos(child.loc.start, comment.loc.start) &lt;= <span class="hljs-number">0</span> &amp;&amp;
            comparePos(comment.loc.end, child.loc.end) &lt;= <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>The comment is completely contained by this child node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            decorateComment(comment.enclosingNode = child, comment, lines);
            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Abandon the binary search at this level.</span>
        }

        <span class="hljs-keyword">if</span> (comparePos(child.loc.end, comment.loc.start) &lt;= <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>This child node falls completely before the comment.
Because we will never consider this node or any nodes
before it again, this node must be the closest preceding
node we have encountered so far.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> precedingNode = child;
            left = middle + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (comparePos(comment.loc.end, child.loc.start) &lt;= <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>This child node falls completely after the comment.
Because we will never consider this node or any nodes after
it again, this node must be the closest following node we
have encountered so far.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> followingNode = child;
            right = middle;
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Comment location overlaps with node location"</span>);
    }

    <span class="hljs-keyword">if</span> (precedingNode) {
        comment.precedingNode = precedingNode;
    }

    <span class="hljs-keyword">if</span> (followingNode) {
        comment.followingNode = followingNode;
    }
}

exports.attach = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">comments, ast, lines</span>) </span>{
    <span class="hljs-keyword">if</span> (!isArray.check(comments)) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> tiesToBreak = [];

    comments.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">comment</span>) </span>{
        comment.loc.lines = lines;
        decorateComment(ast, comment, lines);

        <span class="hljs-keyword">var</span> pn = comment.precedingNode;
        <span class="hljs-keyword">var</span> en = comment.enclosingNode;
        <span class="hljs-keyword">var</span> fn = comment.followingNode;

        <span class="hljs-keyword">if</span> (pn &amp;&amp; fn) {
            <span class="hljs-keyword">var</span> tieCount = tiesToBreak.length;
            <span class="hljs-keyword">if</span> (tieCount &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">var</span> lastTie = tiesToBreak[tieCount - <span class="hljs-number">1</span>];

                assert.strictEqual(
                    lastTie.precedingNode === comment.precedingNode,
                    lastTie.followingNode === comment.followingNode
                );

                <span class="hljs-keyword">if</span> (lastTie.followingNode !== comment.followingNode) {
                    breakTies(tiesToBreak, lines);
                }
            }

            tiesToBreak.push(comment);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pn) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>No contest: we have a trailing comment.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            breakTies(tiesToBreak, lines);
            addTrailingComment(pn, comment);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fn) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>No contest: we have a leading comment.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            breakTies(tiesToBreak, lines);
            addLeadingComment(fn, comment);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (en) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>The enclosing node has no child nodes at all, so what we
have here is a dangling comment, e.g. [/* crickets */].</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            breakTies(tiesToBreak, lines);
            addDanglingComment(en, comment);

        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"AST contains no nodes at all?"</span>);
        }
    });

    breakTies(tiesToBreak, lines);

    comments.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">comment</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>These node references were useful for breaking ties, but we
don't need them anymore, and they create cycles in the AST that
may lead to infinite recursion if we don't delete them here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">delete</span> comment.precedingNode;
        <span class="hljs-keyword">delete</span> comment.enclosingNode;
        <span class="hljs-keyword">delete</span> comment.followingNode;
    });
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">breakTies</span>(<span class="hljs-params">tiesToBreak, lines</span>) </span>{
    <span class="hljs-keyword">var</span> tieCount = tiesToBreak.length;
    <span class="hljs-keyword">if</span> (tieCount === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> pn = tiesToBreak[<span class="hljs-number">0</span>].precedingNode;
    <span class="hljs-keyword">var</span> fn = tiesToBreak[<span class="hljs-number">0</span>].followingNode;
    <span class="hljs-keyword">var</span> gapEndPos = fn.loc.start;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Iterate backwards through tiesToBreak, examining the gaps
between the tied comments. In order to qualify as leading, a
comment must be separated from fn by an unbroken series of
whitespace-only gaps (or other comments).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> indexOfFirstLeadingComment = tieCount;
         indexOfFirstLeadingComment &gt; <span class="hljs-number">0</span>;
         --indexOfFirstLeadingComment) {
        <span class="hljs-keyword">var</span> comment = tiesToBreak[indexOfFirstLeadingComment - <span class="hljs-number">1</span>];
        assert.strictEqual(comment.precedingNode, pn);
        assert.strictEqual(comment.followingNode, fn);

        <span class="hljs-keyword">var</span> gap = lines.sliceString(comment.loc.end, gapEndPos);
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\S/</span>.test(gap)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>The gap string contained something other than whitespace.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">break</span>;
        }

        gapEndPos = comment.loc.start;
    }

    <span class="hljs-keyword">while</span> (indexOfFirstLeadingComment &lt;= tieCount &amp;&amp;
           (comment = tiesToBreak[indexOfFirstLeadingComment]) &amp;&amp;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>If the comment is a //-style comment and indented more
deeply than the node itself, reconsider it as trailing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">           (comment.type === <span class="hljs-string">"Line"</span> || comment.type === <span class="hljs-string">"CommentLine"</span>) &amp;&amp;
           comment.loc.start.column &gt; fn.loc.start.column) {
        ++indexOfFirstLeadingComment;
    }

    tiesToBreak.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">comment, i</span>) </span>{
        <span class="hljs-keyword">if</span> (i &lt; indexOfFirstLeadingComment) {
            addTrailingComment(pn, comment);
        } <span class="hljs-keyword">else</span> {
            addLeadingComment(fn, comment);
        }
    });

    tiesToBreak.length = <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCommentHelper</span>(<span class="hljs-params">node, comment</span>) </span>{
    <span class="hljs-keyword">var</span> comments = node.comments || (node.comments = []);
    comments.push(comment);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addLeadingComment</span>(<span class="hljs-params">node, comment</span>) </span>{
    comment.leading = <span class="hljs-literal">true</span>;
    comment.trailing = <span class="hljs-literal">false</span>;
    addCommentHelper(node, comment);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDanglingComment</span>(<span class="hljs-params">node, comment</span>) </span>{
    comment.leading = <span class="hljs-literal">false</span>;
    comment.trailing = <span class="hljs-literal">false</span>;
    addCommentHelper(node, comment);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTrailingComment</span>(<span class="hljs-params">node, comment</span>) </span>{
    comment.leading = <span class="hljs-literal">false</span>;
    comment.trailing = <span class="hljs-literal">true</span>;
    addCommentHelper(node, comment);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printLeadingComment</span>(<span class="hljs-params">commentPath, print</span>) </span>{
    <span class="hljs-keyword">var</span> comment = commentPath.getValue();
    n.Comment.assert(comment);

    <span class="hljs-keyword">var</span> loc = comment.loc;
    <span class="hljs-keyword">var</span> lines = loc &amp;&amp; loc.lines;
    <span class="hljs-keyword">var</span> parts = [print(commentPath)];

    <span class="hljs-keyword">if</span> (comment.trailing) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>When we print trailing comments as leading comments, we don't
want to bring any trailing spaces along.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        parts.push(<span class="hljs-string">"\n"</span>);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lines <span class="hljs-keyword">instanceof</span> Lines) {
        <span class="hljs-keyword">var</span> trailingSpace = lines.slice(
            loc.end,
            lines.skipSpaces(loc.end)
        );

        <span class="hljs-keyword">if</span> (trailingSpace.length === <span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>If the trailing space contains no newlines, then we want to
preserve it exactly as we found it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            parts.push(trailingSpace);
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>If the trailing space contains newlines, then replace it
with just that many newlines, with all other spaces removed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            parts.push(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(trailingSpace.length).join(<span class="hljs-string">"\n"</span>));
        }

    } <span class="hljs-keyword">else</span> {
        parts.push(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-keyword">return</span> concat(parts);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printTrailingComment</span>(<span class="hljs-params">commentPath, print</span>) </span>{
    <span class="hljs-keyword">var</span> comment = commentPath.getValue(commentPath);
    n.Comment.assert(comment);

    <span class="hljs-keyword">var</span> loc = comment.loc;
    <span class="hljs-keyword">var</span> lines = loc &amp;&amp; loc.lines;
    <span class="hljs-keyword">var</span> parts = [];

    <span class="hljs-keyword">if</span> (lines <span class="hljs-keyword">instanceof</span> Lines) {
        <span class="hljs-keyword">var</span> fromPos = lines.skipSpaces(loc.start, <span class="hljs-literal">true</span>) || lines.firstPos();
        <span class="hljs-keyword">var</span> leadingSpace = lines.slice(fromPos, loc.start);

        <span class="hljs-keyword">if</span> (leadingSpace.length === <span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>If the leading space contains no newlines, then we want to
preserve it exactly as we found it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            parts.push(leadingSpace);
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>If the leading space contains newlines, then replace it
with just that many newlines, sans all other spaces.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            parts.push(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(leadingSpace.length).join(<span class="hljs-string">"\n"</span>));
        }
    }

    parts.push(print(commentPath));

    <span class="hljs-keyword">return</span> concat(parts);
}

exports.printComments = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path, print</span>) </span>{
    <span class="hljs-keyword">var</span> value = path.getValue();
    <span class="hljs-keyword">var</span> innerLines = print(path);
    <span class="hljs-keyword">var</span> comments = n.Node.check(value) &amp;&amp;
        types.getFieldValue(value, <span class="hljs-string">"comments"</span>);

    <span class="hljs-keyword">if</span> (!comments || comments.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> innerLines;
    }

    <span class="hljs-keyword">var</span> leadingParts = [];
    <span class="hljs-keyword">var</span> trailingParts = [innerLines];

    path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">commentPath</span>) </span>{
        <span class="hljs-keyword">var</span> comment = commentPath.getValue();
        <span class="hljs-keyword">var</span> leading = types.getFieldValue(comment, <span class="hljs-string">"leading"</span>);
        <span class="hljs-keyword">var</span> trailing = types.getFieldValue(comment, <span class="hljs-string">"trailing"</span>);

        <span class="hljs-keyword">if</span> (leading || (trailing &amp;&amp; !(n.Statement.check(value) ||
                                      comment.type === <span class="hljs-string">"Block"</span> ||
                                      comment.type === <span class="hljs-string">"CommentBlock"</span>))) {
            leadingParts.push(printLeadingComment(commentPath, print));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (trailing) {
            trailingParts.push(printTrailingComment(commentPath, print));
        }
    }, <span class="hljs-string">"comments"</span>);

    leadingParts.push.apply(leadingParts, trailingParts);
    <span class="hljs-keyword">return</span> concat(leadingParts);
};

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
