<!DOCTYPE html>
<html>
<head>
  <title>fast-path.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/recast/lib/fast-path.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>fast-path.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">"assert"</span>);
<span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>);
<span class="hljs-keyword">var</span> n = types.namedTypes;
<span class="hljs-keyword">var</span> Node = n.Node;
<span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
<span class="hljs-keyword">var</span> isNumber = types.builtInTypes.number;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FastPath</span>(<span class="hljs-params">value</span>) </span>{
    assert.ok(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> FastPath);
    <span class="hljs-keyword">this</span>.stack = [value];
}

<span class="hljs-keyword">var</span> FPp = FastPath.prototype;
<span class="hljs-built_in">module</span>.exports = FastPath;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Static convenience function for coercing a value to a FastPath.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">FastPath.from = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> FastPath) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Return a defensive copy of any existing FastPath instances.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> obj.copy();
    }

    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> types.NodePath) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>For backwards compatibility, unroll NodePath instances into
lightweight FastPath [..., name, value] stacks.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> copy = <span class="hljs-built_in">Object</span>.create(FastPath.prototype);
        <span class="hljs-keyword">var</span> stack = [obj.value];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pp; (pp = obj.parentPath); obj = pp)
            stack.push(obj.name, pp.value);
        copy.stack = stack.reverse();
        <span class="hljs-keyword">return</span> copy;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Otherwise use obj as the value of the new FastPath instance.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FastPath(obj);
};

FPp.copy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copy</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> copy = <span class="hljs-built_in">Object</span>.create(FastPath.prototype);
    copy.stack = <span class="hljs-keyword">this</span>.stack.slice(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> copy;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>The name of the current property is always the penultimate element of
this.stack, and always a String.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">FPp.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">this</span>.stack;
    <span class="hljs-keyword">var</span> len = s.length;
    <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> s[len - <span class="hljs-number">2</span>];
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Since the name is always a string, null is a safe sentinel value to
return if we do not know the name of the (root) value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>The value of the current property is always the final element of
this.stack.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">FPp.getValue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValue</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">this</span>.stack;
    <span class="hljs-keyword">return</span> s[s.length - <span class="hljs-number">1</span>];
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeHelper</span>(<span class="hljs-params">path, count</span>) </span>{
    <span class="hljs-keyword">var</span> s = path.stack;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = s.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -= <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">var</span> value = s[i];
        <span class="hljs-keyword">if</span> (n.Node.check(value) &amp;&amp; --count &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> value;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

FPp.getNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNode</span>(<span class="hljs-params">count</span>) </span>{
    <span class="hljs-keyword">return</span> getNodeHelper(<span class="hljs-keyword">this</span>, ~~count);
};

FPp.getParentNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParentNode</span>(<span class="hljs-params">count</span>) </span>{
    <span class="hljs-keyword">return</span> getNodeHelper(<span class="hljs-keyword">this</span>, ~~count + <span class="hljs-number">1</span>);
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>The length of the stack can be either even or odd, depending on whether
or not we have a name for the root value. The difference between the
index of the root value and the index of the final value is always
even, though, which allows us to return the root value in constant time
(i.e. without iterating backwards through the stack).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">FPp.getRootValue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRootValue</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">this</span>.stack;
    <span class="hljs-keyword">if</span> (s.length % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> s[<span class="hljs-number">1</span>];
    }
    <span class="hljs-keyword">return</span> s[<span class="hljs-number">0</span>];
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Temporarily push properties named by string arguments given after the
callback function onto this.stack, then call the callback with a
reference to this (modified) FastPath object. Note that the stack will
be restored to its original state after the callback is finished, so it
is probably a mistake to retain a reference to the path.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">FPp.call = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span>(<span class="hljs-params">callback<span class="hljs-regexp">/*, name1, name2, ... */</span></span>) </span>{
    <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">this</span>.stack;
    <span class="hljs-keyword">var</span> origLen = s.length;
    <span class="hljs-keyword">var</span> value = s[origLen - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">var</span> argc = <span class="hljs-built_in">arguments</span>.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) {
        <span class="hljs-keyword">var</span> name = <span class="hljs-built_in">arguments</span>[i];
        value = value[name];
        s.push(name, value);
    }
    <span class="hljs-keyword">var</span> result = callback(<span class="hljs-keyword">this</span>);
    s.length = origLen;
    <span class="hljs-keyword">return</span> result;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Similar to FastPath.prototype.call, except that the value obtained by
accessing this.getValue()[name1][name2]... should be array-like. The
callback will be called with a reference to this path object for each
element of the array.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">FPp.each = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">callback<span class="hljs-regexp">/*, name1, name2, ... */</span></span>) </span>{
    <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">this</span>.stack;
    <span class="hljs-keyword">var</span> origLen = s.length;
    <span class="hljs-keyword">var</span> value = s[origLen - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">var</span> argc = <span class="hljs-built_in">arguments</span>.length;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) {
        <span class="hljs-keyword">var</span> name = <span class="hljs-built_in">arguments</span>[i];
        value = value[name];
        s.push(name, value);
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; value.length; ++i) {
        <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> value) {
            s.push(i, value[i]);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>If the callback needs to know the value of i, call
path.getName(), assuming path is the parameter name.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            callback(<span class="hljs-keyword">this</span>);
            s.length -= <span class="hljs-number">2</span>;
        }
    }

    s.length = origLen;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>Similar to FastPath.prototype.each, except that the results of the
callback function invocations are stored in an array and returned at
the end of the iteration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">FPp.map = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">callback<span class="hljs-regexp">/*, name1, name2, ... */</span></span>) </span>{
    <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">this</span>.stack;
    <span class="hljs-keyword">var</span> origLen = s.length;
    <span class="hljs-keyword">var</span> value = s[origLen - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">var</span> argc = <span class="hljs-built_in">arguments</span>.length;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) {
        <span class="hljs-keyword">var</span> name = <span class="hljs-built_in">arguments</span>[i];
        value = value[name];
        s.push(name, value);
    }

    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(value.length);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; value.length; ++i) {
        <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> value) {
            s.push(i, value[i]);
            result[i] = callback(<span class="hljs-keyword">this</span>, i);
            s.length -= <span class="hljs-number">2</span>;
        }
    }

    s.length = origLen;

    <span class="hljs-keyword">return</span> result;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Inspired by require(&quot;ast-types&quot;).NodePath.prototype.needsParens, but
more efficient because we're iterating backwards through a stack.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">FPp.needsParens = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">assumeExpressionContext</span>) </span>{
    <span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">this</span>.getParentNode();
    <span class="hljs-keyword">if</span> (!parent) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> name = <span class="hljs-keyword">this</span>.getName();
    <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.getNode();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>If the value of this path is some child of a Node and not a Node
itself, then it doesn't need parentheses. Only Node objects (in
fact, only Expression nodes) need parentheses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getValue() !== node) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Only expressions need parentheses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!n.Expression.check(node)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>Identifiers never need parentheses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">"Identifier"</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (parent.type === <span class="hljs-string">"ParenthesizedExpression"</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
        <span class="hljs-keyword">return</span> parent.type === <span class="hljs-string">"MemberExpression"</span>
            &amp;&amp; name === <span class="hljs-string">"object"</span>
            &amp;&amp; parent.object === node;

    <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
        <span class="hljs-keyword">switch</span> (parent.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"CallExpression"</span>:
            <span class="hljs-keyword">return</span> name === <span class="hljs-string">"callee"</span>
                &amp;&amp; parent.callee === node;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
            <span class="hljs-keyword">return</span> name === <span class="hljs-string">"object"</span>
                &amp;&amp; parent.object === node;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
            <span class="hljs-keyword">var</span> po = parent.operator;
            <span class="hljs-keyword">var</span> pp = PRECEDENCE[po];
            <span class="hljs-keyword">var</span> no = node.operator;
            <span class="hljs-keyword">var</span> np = PRECEDENCE[no];

            <span class="hljs-keyword">if</span> (pp &gt; np) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">if</span> (pp === np &amp;&amp; name === <span class="hljs-string">"right"</span>) {
                assert.strictEqual(parent.right, node);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

    <span class="hljs-keyword">case</span> <span class="hljs-string">"SequenceExpression"</span>:
        <span class="hljs-keyword">switch</span> (parent.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"ForStatement"</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>Although parentheses wouldn't hurt around sequence
expressions in the head of for loops, traditional style
dictates that e.g. i++, j++ should not be wrapped with
parentheses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"ExpressionStatement"</span>:
            <span class="hljs-keyword">return</span> name !== <span class="hljs-string">"expression"</span>;

        <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>Otherwise err on the side of overparenthesization, adding
explicit exceptions above if this proves overzealous.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

    <span class="hljs-keyword">case</span> <span class="hljs-string">"YieldExpression"</span>:
        <span class="hljs-keyword">switch</span> (parent.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"CallExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"NewExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"ConditionalExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"YieldExpression"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

    <span class="hljs-keyword">case</span> <span class="hljs-string">"Literal"</span>:
        <span class="hljs-keyword">return</span> parent.type === <span class="hljs-string">"MemberExpression"</span>
            &amp;&amp; isNumber.check(node.value)
            &amp;&amp; name === <span class="hljs-string">"object"</span>
            &amp;&amp; parent.object === node;

    <span class="hljs-keyword">case</span> <span class="hljs-string">"AssignmentExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"ConditionalExpression"</span>:
        <span class="hljs-keyword">switch</span> (parent.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"CallExpression"</span>:
            <span class="hljs-keyword">return</span> name === <span class="hljs-string">"callee"</span>
                &amp;&amp; parent.callee === node;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"ConditionalExpression"</span>:
            <span class="hljs-keyword">return</span> name === <span class="hljs-string">"test"</span>
                &amp;&amp; parent.test === node;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
            <span class="hljs-keyword">return</span> name === <span class="hljs-string">"object"</span>
                &amp;&amp; parent.object === node;

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ArrowFunctionExpression"</span>:
        <span class="hljs-keyword">if</span>(parent.type === <span class="hljs-string">'CallExpression'</span> &amp;&amp; 
           name === <span class="hljs-string">'callee'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        };

        <span class="hljs-keyword">return</span> isBinary(parent);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ObjectExpression"</span>:
        <span class="hljs-keyword">if</span> (parent.type === <span class="hljs-string">"ArrowFunctionExpression"</span> &amp;&amp;
            name === <span class="hljs-string">"body"</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">if</span> (parent.type === <span class="hljs-string">"NewExpression"</span> &amp;&amp;
            name === <span class="hljs-string">"callee"</span> &amp;&amp;
            parent.callee === node) {
            <span class="hljs-keyword">return</span> containsCallExpression(node);
        }
    }

    <span class="hljs-keyword">if</span> (assumeExpressionContext !== <span class="hljs-literal">true</span> &amp;&amp;
        !<span class="hljs-keyword">this</span>.canBeFirstInStatement() &amp;&amp;
        <span class="hljs-keyword">this</span>.firstInStatement())
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBinary</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> n.BinaryExpression.check(node)
        || n.LogicalExpression.check(node);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnaryLike</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> n.UnaryExpression.check(node)
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>I considered making SpreadElement and SpreadProperty subtypes
of UnaryExpression, but they're not really Expression nodes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        || (n.SpreadElement &amp;&amp; n.SpreadElement.check(node))
        || (n.SpreadProperty &amp;&amp; n.SpreadProperty.check(node));
}

<span class="hljs-keyword">var</span> PRECEDENCE = {};
[[<span class="hljs-string">"||"</span>],
 [<span class="hljs-string">"&amp;&amp;"</span>],
 [<span class="hljs-string">"|"</span>],
 [<span class="hljs-string">"^"</span>],
 [<span class="hljs-string">"&amp;"</span>],
 [<span class="hljs-string">"=="</span>, <span class="hljs-string">"==="</span>, <span class="hljs-string">"!="</span>, <span class="hljs-string">"!=="</span>],
 [<span class="hljs-string">"&lt;"</span>, <span class="hljs-string">"&gt;"</span>, <span class="hljs-string">"&lt;="</span>, <span class="hljs-string">"&gt;="</span>, <span class="hljs-string">"in"</span>, <span class="hljs-string">"instanceof"</span>],
 [<span class="hljs-string">"&gt;&gt;"</span>, <span class="hljs-string">"&lt;&lt;"</span>, <span class="hljs-string">"&gt;&gt;&gt;"</span>],
 [<span class="hljs-string">"+"</span>, <span class="hljs-string">"-"</span>],
 [<span class="hljs-string">"*"</span>, <span class="hljs-string">"/"</span>, <span class="hljs-string">"%"</span>]
].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tier, i</span>) </span>{
    tier.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">op</span>) </span>{
        PRECEDENCE[op] = i;
    });
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">containsCallExpression</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (n.CallExpression.check(node)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (isArray.check(node)) {
        <span class="hljs-keyword">return</span> node.some(containsCallExpression);
    }

    <span class="hljs-keyword">if</span> (n.Node.check(node)) {
        <span class="hljs-keyword">return</span> types.someField(node, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, child</span>) </span>{
            <span class="hljs-keyword">return</span> containsCallExpression(child);
        });
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

FPp.canBeFirstInStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.getNode();
    <span class="hljs-keyword">return</span> !n.FunctionExpression.check(node)
        &amp;&amp; !n.ObjectExpression.check(node);
};

FPp.firstInStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">this</span>.stack;
    <span class="hljs-keyword">var</span> parentName, parent;
    <span class="hljs-keyword">var</span> childName, child;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = s.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -= <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">if</span> (n.Node.check(s[i])) {
            childName = parentName;
            child = parent;
            parentName = s[i - <span class="hljs-number">1</span>];
            parent = s[i];
        }

        <span class="hljs-keyword">if</span> (!parent || !child) {
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (n.BlockStatement.check(parent) &amp;&amp;
            parentName === <span class="hljs-string">"body"</span> &amp;&amp;
            childName === <span class="hljs-number">0</span>) {
            assert.strictEqual(parent.body[<span class="hljs-number">0</span>], child);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (n.ExpressionStatement.check(parent) &amp;&amp;
            childName === <span class="hljs-string">"expression"</span>) {
            assert.strictEqual(parent.expression, child);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (n.SequenceExpression.check(parent) &amp;&amp;
            parentName === <span class="hljs-string">"expressions"</span> &amp;&amp;
            childName === <span class="hljs-number">0</span>) {
            assert.strictEqual(parent.expressions[<span class="hljs-number">0</span>], child);
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (n.CallExpression.check(parent) &amp;&amp;
            childName === <span class="hljs-string">"callee"</span>) {
            assert.strictEqual(parent.callee, child);
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (n.MemberExpression.check(parent) &amp;&amp;
            childName === <span class="hljs-string">"object"</span>) {
            assert.strictEqual(parent.object, child);
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (n.ConditionalExpression.check(parent) &amp;&amp;
            childName === <span class="hljs-string">"test"</span>) {
            assert.strictEqual(parent.test, child);
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (isBinary(parent) &amp;&amp;
            childName === <span class="hljs-string">"left"</span>) {
            assert.strictEqual(parent.left, child);
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (n.UnaryExpression.check(parent) &amp;&amp;
            !parent.prefix &amp;&amp;
            childName === <span class="hljs-string">"argument"</span>) {
            assert.strictEqual(parent.argument, child);
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
