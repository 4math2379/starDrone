<!DOCTYPE html>
<html>
<head>
  <title>printer.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/recast/lib/printer.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>printer.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">"assert"</span>);
<span class="hljs-keyword">var</span> sourceMap = <span class="hljs-built_in">require</span>(<span class="hljs-string">"source-map"</span>);
<span class="hljs-keyword">var</span> printComments = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./comments"</span>).printComments;
<span class="hljs-keyword">var</span> linesModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./lines"</span>);
<span class="hljs-keyword">var</span> fromString = linesModule.fromString;
<span class="hljs-keyword">var</span> concat = linesModule.concat;
<span class="hljs-keyword">var</span> normalizeOptions = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./options"</span>).normalize;
<span class="hljs-keyword">var</span> getReprinter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./patcher"</span>).getReprinter;
<span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>);
<span class="hljs-keyword">var</span> namedTypes = types.namedTypes;
<span class="hljs-keyword">var</span> isString = types.builtInTypes.string;
<span class="hljs-keyword">var</span> isObject = types.builtInTypes.object;
<span class="hljs-keyword">var</span> FastPath = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./fast-path"</span>);
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./util"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PrintResult</span>(<span class="hljs-params">code, sourceMap</span>) </span>{
    assert.ok(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> PrintResult);

    isString.assert(code);
    <span class="hljs-keyword">this</span>.code = code;

    <span class="hljs-keyword">if</span> (sourceMap) {
        isObject.assert(sourceMap);
        <span class="hljs-keyword">this</span>.map = sourceMap;
    }
}

<span class="hljs-keyword">var</span> PRp = PrintResult.prototype;
<span class="hljs-keyword">var</span> warnedAboutToString = <span class="hljs-literal">false</span>;

PRp.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (!warnedAboutToString) {
        <span class="hljs-built_in">console</span>.warn(
            <span class="hljs-string">"Deprecation warning: recast.print now returns an object with "</span> +
            <span class="hljs-string">"a .code property. You appear to be treating the object as a "</span> +
            <span class="hljs-string">"string, which might still work but is strongly discouraged."</span>
        );

        warnedAboutToString = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.code;
};

<span class="hljs-keyword">var</span> emptyPrintResult = <span class="hljs-keyword">new</span> PrintResult(<span class="hljs-string">""</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Printer</span>(<span class="hljs-params">originalOptions</span>) </span>{
    assert.ok(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Printer);

    <span class="hljs-keyword">var</span> explicitTabWidth = originalOptions &amp;&amp; originalOptions.tabWidth;
    <span class="hljs-keyword">var</span> options = normalizeOptions(originalOptions);
    assert.notStrictEqual(options, originalOptions);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>It's common for client code to pass the same options into both
recast.parse and recast.print, but the Printer doesn't need (and
can be confused by) options.sourceFileName, so we null it out.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    options.sourceFileName = <span class="hljs-literal">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printWithComments</span>(<span class="hljs-params">path</span>) </span>{
        assert.ok(path <span class="hljs-keyword">instanceof</span> FastPath);
        <span class="hljs-keyword">return</span> printComments(path, print);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">path, includeComments</span>) </span>{
        <span class="hljs-keyword">if</span> (includeComments)
            <span class="hljs-keyword">return</span> printWithComments(path);

        assert.ok(path <span class="hljs-keyword">instanceof</span> FastPath);

        <span class="hljs-keyword">if</span> (!explicitTabWidth) {
            <span class="hljs-keyword">var</span> oldTabWidth = options.tabWidth;
            <span class="hljs-keyword">var</span> loc = path.getNode().loc;
            <span class="hljs-keyword">if</span> (loc &amp;&amp; loc.lines &amp;&amp; loc.lines.guessTabWidth) {
                options.tabWidth = loc.lines.guessTabWidth();
                <span class="hljs-keyword">var</span> lines = maybeReprint(path);
                options.tabWidth = oldTabWidth;
                <span class="hljs-keyword">return</span> lines;
            }
        }

        <span class="hljs-keyword">return</span> maybeReprint(path);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeReprint</span>(<span class="hljs-params">path</span>) </span>{
        <span class="hljs-keyword">var</span> reprinter = getReprinter(path);
        <span class="hljs-keyword">if</span> (reprinter) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Since the print function that we pass to the reprinter will
be used to print &quot;new&quot; nodes, it's tempting to think we
should pass printRootGenerically instead of print, to avoid
calling maybeReprint again, but that would be a mistake
because the new nodes might not be entirely new, but merely
moved from elsewhere in the AST. The print function is the
right choice because it gives us the opportunity to reprint
such nodes using their original source.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> maybeAddParens(path, reprinter(print));
        }
        <span class="hljs-keyword">return</span> printRootGenerically(path);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>Print the root node generically, but then resume reprinting its
children non-generically.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printRootGenerically</span>(<span class="hljs-params">path, includeComments</span>) </span>{
        <span class="hljs-keyword">return</span> includeComments
            ? printComments(path, printRootGenerically)
            : genericPrint(path, options, printWithComments);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Print the entire AST generically.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printGenerically</span>(<span class="hljs-params">path</span>) </span>{
        <span class="hljs-keyword">return</span> genericPrint(path, options, printGenerically);
    }

    <span class="hljs-keyword">this</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ast</span>) </span>{
        <span class="hljs-keyword">if</span> (!ast) {
            <span class="hljs-keyword">return</span> emptyPrintResult;
        }

        <span class="hljs-keyword">var</span> lines = print(FastPath.from(ast), <span class="hljs-literal">true</span>);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PrintResult(
            lines.toString(options),
            util.composeSourceMaps(
                options.inputSourceMap,
                lines.getSourceMap(
                    options.sourceMapName,
                    options.sourceRoot
                )
            )
        );
    };

    <span class="hljs-keyword">this</span>.printGenerically = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ast</span>) </span>{
        <span class="hljs-keyword">if</span> (!ast) {
            <span class="hljs-keyword">return</span> emptyPrintResult;
        }

        <span class="hljs-keyword">var</span> path = FastPath.from(ast);
        <span class="hljs-keyword">var</span> oldReuseWhitespace = options.reuseWhitespace;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Do not reuse whitespace (or anything else, for that matter)
when printing generically.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        options.reuseWhitespace = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>TODO Allow printing of comments?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> pr = <span class="hljs-keyword">new</span> PrintResult(printGenerically(path).toString(options));
        options.reuseWhitespace = oldReuseWhitespace;
        <span class="hljs-keyword">return</span> pr;
    };
}

exports.Printer = Printer;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeAddParens</span>(<span class="hljs-params">path, lines</span>) </span>{
    <span class="hljs-keyword">return</span> path.needsParens() ? concat([<span class="hljs-string">"("</span>, lines, <span class="hljs-string">")"</span>]) : lines;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genericPrint</span>(<span class="hljs-params">path, options, printPath</span>) </span>{
    assert.ok(path <span class="hljs-keyword">instanceof</span> FastPath);

    <span class="hljs-keyword">var</span> node = path.getValue();
    <span class="hljs-keyword">var</span> parts = [];
    <span class="hljs-keyword">var</span> needsParens = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> linesWithoutParens =
        genericPrintNoParens(path, options, printPath);

    <span class="hljs-keyword">if</span> (! node || linesWithoutParens.isEmpty()) {
        <span class="hljs-keyword">return</span> linesWithoutParens;
    }

    <span class="hljs-keyword">if</span> (node.decorators &amp;&amp;
        node.decorators.length &gt; <span class="hljs-number">0</span> &amp;&amp;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>If the parent node is an export declaration, it will be
responsible for printing node.decorators.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        ! util.getParentExportDeclaration(path)) {

        path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">decoratorPath</span>) </span>{
            parts.push(printPath(decoratorPath), <span class="hljs-string">"\n"</span>);
        }, <span class="hljs-string">"decorators"</span>);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (util.isExportDeclaration(node) &amp;&amp;
               node.declaration &amp;&amp;
               node.declaration.decorators) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Export declarations are responsible for printing any decorators
that logically apply to node.declaration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">decoratorPath</span>) </span>{
            parts.push(printPath(decoratorPath), <span class="hljs-string">"\n"</span>);
        }, <span class="hljs-string">"declaration"</span>, <span class="hljs-string">"decorators"</span>);

    } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Nodes with decorators can't have parentheses, so we can avoid
computing path.needsParens() except in this case.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        needsParens = path.needsParens();
    }

    <span class="hljs-keyword">if</span> (needsParens) {
        parts.unshift(<span class="hljs-string">"("</span>);
    }

    parts.push(linesWithoutParens);

    <span class="hljs-keyword">if</span> (needsParens) {
        parts.push(<span class="hljs-string">")"</span>);
    }

    <span class="hljs-keyword">return</span> concat(parts);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genericPrintNoParens</span>(<span class="hljs-params">path, options, print</span>) </span>{
    <span class="hljs-keyword">var</span> n = path.getValue();

    <span class="hljs-keyword">if</span> (!n) {
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">""</span>);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n === <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">return</span> fromString(n, options);
    }

    namedTypes.Printable.assert(n);

    <span class="hljs-keyword">var</span> parts = [];

    <span class="hljs-keyword">switch</span> (n.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"File"</span>:
        <span class="hljs-keyword">return</span> path.call(print, <span class="hljs-string">"program"</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"Program"</span>:
        <span class="hljs-keyword">return</span> path.call(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bodyPath</span>) </span>{
            <span class="hljs-keyword">return</span> printStatementSequence(bodyPath, options, print);
        }, <span class="hljs-string">"body"</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"Noop"</span>: <span class="hljs-comment">// Babel extension.</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"EmptyStatement"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">""</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ExpressionStatement"</span>:
        <span class="hljs-keyword">return</span> concat([path.call(print, <span class="hljs-string">"expression"</span>), <span class="hljs-string">";"</span>]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ParenthesizedExpression"</span>: <span class="hljs-comment">// Babel extension.</span>
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"("</span>, path.call(print, <span class="hljs-string">"expression"</span>), <span class="hljs-string">")"</span>]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"AssignmentExpression"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">" "</span>).join([
            path.call(print, <span class="hljs-string">"left"</span>),
            n.operator,
            path.call(print, <span class="hljs-string">"right"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"AssignmentPattern"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"left"</span>),
            <span class="hljs-string">"="</span>,
            path.call(print, <span class="hljs-string">"right"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
        parts.push(path.call(print, <span class="hljs-string">"object"</span>));

        <span class="hljs-keyword">var</span> property = path.call(print, <span class="hljs-string">"property"</span>);
        <span class="hljs-keyword">if</span> (n.computed) {
            parts.push(<span class="hljs-string">"["</span>, property, <span class="hljs-string">"]"</span>);
        } <span class="hljs-keyword">else</span> {
            parts.push(<span class="hljs-string">"."</span>, property);
        }

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"MetaProperty"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"meta"</span>),
            <span class="hljs-string">"."</span>,
            path.call(print, <span class="hljs-string">"property"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"BindExpression"</span>:
        <span class="hljs-keyword">if</span> (n.object) {
            parts.push(path.call(print, <span class="hljs-string">"object"</span>));
        }

        parts.push(<span class="hljs-string">"::"</span>, path.call(print, <span class="hljs-string">"callee"</span>));

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"Path"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"."</span>).join(n.body);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"Identifier"</span>:
        <span class="hljs-keyword">return</span> concat([
            fromString(n.name, options),
            path.call(print, <span class="hljs-string">"typeAnnotation"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElementPattern"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadPropertyPattern"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"RestElement"</span>:
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"..."</span>, path.call(print, <span class="hljs-string">"argument"</span>)]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"FunctionDeclaration"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"FunctionExpression"</span>:
        <span class="hljs-keyword">if</span> (n.async)
            parts.push(<span class="hljs-string">"async "</span>);

        parts.push(<span class="hljs-string">"function"</span>);

        <span class="hljs-keyword">if</span> (n.generator)
            parts.push(<span class="hljs-string">"*"</span>);

        <span class="hljs-keyword">if</span> (n.id) {
            parts.push(
                <span class="hljs-string">" "</span>,
                path.call(print, <span class="hljs-string">"id"</span>),
                path.call(print, <span class="hljs-string">"typeParameters"</span>)
            );
        }

        parts.push(
            <span class="hljs-string">"("</span>,
            printFunctionParams(path, options, print),
            <span class="hljs-string">")"</span>,
            path.call(print, <span class="hljs-string">"returnType"</span>),
            <span class="hljs-string">" "</span>,
            path.call(print, <span class="hljs-string">"body"</span>)
        );

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ArrowFunctionExpression"</span>:
        <span class="hljs-keyword">if</span> (n.async)
            parts.push(<span class="hljs-string">"async "</span>);

        <span class="hljs-keyword">if</span> (
            n.params.length === <span class="hljs-number">1</span> &amp;&amp;
            !n.rest &amp;&amp;
            n.params[<span class="hljs-number">0</span>].type === <span class="hljs-string">'Identifier'</span> &amp;&amp;
            !n.params[<span class="hljs-number">0</span>].typeAnnotation
        ) {
            parts.push(path.call(print, <span class="hljs-string">"params"</span>, <span class="hljs-number">0</span>));
        } <span class="hljs-keyword">else</span> {
            parts.push(
                <span class="hljs-string">"("</span>,
                printFunctionParams(path, options, print),
                <span class="hljs-string">")"</span>
            );
        }

        parts.push(<span class="hljs-string">" =&gt; "</span>, path.call(print, <span class="hljs-string">"body"</span>));

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"MethodDefinition"</span>:
        <span class="hljs-keyword">if</span> (n.static) {
            parts.push(<span class="hljs-string">"static "</span>);
        }

        parts.push(printMethod(path, options, print));

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"YieldExpression"</span>:
        parts.push(<span class="hljs-string">"yield"</span>);

        <span class="hljs-keyword">if</span> (n.delegate)
            parts.push(<span class="hljs-string">"*"</span>);

        <span class="hljs-keyword">if</span> (n.argument)
            parts.push(<span class="hljs-string">" "</span>, path.call(print, <span class="hljs-string">"argument"</span>));

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"AwaitExpression"</span>:
        parts.push(<span class="hljs-string">"await"</span>);

        <span class="hljs-keyword">if</span> (n.all)
            parts.push(<span class="hljs-string">"*"</span>);

        <span class="hljs-keyword">if</span> (n.argument)
            parts.push(<span class="hljs-string">" "</span>, path.call(print, <span class="hljs-string">"argument"</span>));

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ModuleDeclaration"</span>:
        parts.push(<span class="hljs-string">"module"</span>, path.call(print, <span class="hljs-string">"id"</span>));

        <span class="hljs-keyword">if</span> (n.source) {
            assert.ok(!n.body);
            parts.push(<span class="hljs-string">"from"</span>, path.call(print, <span class="hljs-string">"source"</span>));
        } <span class="hljs-keyword">else</span> {
            parts.push(path.call(print, <span class="hljs-string">"body"</span>));
        }

        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">" "</span>).join(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ImportSpecifier"</span>:
        <span class="hljs-keyword">if</span> (n.imported) {
            parts.push(path.call(print, <span class="hljs-string">"imported"</span>));
            <span class="hljs-keyword">if</span> (n.local &amp;&amp;
                n.local.name !== n.imported.name) {
                parts.push(<span class="hljs-string">" as "</span>, path.call(print, <span class="hljs-string">"local"</span>));
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.id) {
            parts.push(path.call(print, <span class="hljs-string">"id"</span>));
            <span class="hljs-keyword">if</span> (n.name) {
                parts.push(<span class="hljs-string">" as "</span>, path.call(print, <span class="hljs-string">"name"</span>));
            }
        }

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportSpecifier"</span>:
        <span class="hljs-keyword">if</span> (n.local) {
            parts.push(path.call(print, <span class="hljs-string">"local"</span>));
            <span class="hljs-keyword">if</span> (n.exported &amp;&amp;
                n.exported.name !== n.local.name) {
                parts.push(<span class="hljs-string">" as "</span>, path.call(print, <span class="hljs-string">"exported"</span>));
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.id) {
            parts.push(path.call(print, <span class="hljs-string">"id"</span>));
            <span class="hljs-keyword">if</span> (n.name) {
                parts.push(<span class="hljs-string">" as "</span>, path.call(print, <span class="hljs-string">"name"</span>));
            }
        }

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportBatchSpecifier"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"*"</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ImportNamespaceSpecifier"</span>:
        parts.push(<span class="hljs-string">"* as "</span>);
        <span class="hljs-keyword">if</span> (n.local) {
            parts.push(path.call(print, <span class="hljs-string">"local"</span>));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.id) {
            parts.push(path.call(print, <span class="hljs-string">"id"</span>));
        }
        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ImportDefaultSpecifier"</span>:
        <span class="hljs-keyword">if</span> (n.local) {
            <span class="hljs-keyword">return</span> path.call(print, <span class="hljs-string">"local"</span>);
        }
        <span class="hljs-keyword">return</span> path.call(print, <span class="hljs-string">"id"</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportDeclaration"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportDefaultDeclaration"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportNamedDeclaration"</span>:
        <span class="hljs-keyword">return</span> printExportDeclaration(path, options, print);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportAllDeclaration"</span>:
        parts.push(<span class="hljs-string">"export *"</span>);

        <span class="hljs-keyword">if</span> (n.exported) {
            parts.push(<span class="hljs-string">" as "</span>, path.call(print, <span class="hljs-string">"exported"</span>));
        }

        parts.push(
            <span class="hljs-string">" from "</span>,
            path.call(print, <span class="hljs-string">"source"</span>)
        );

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportNamespaceSpecifier"</span>:
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"* as "</span>, path.call(print, <span class="hljs-string">"exported"</span>)]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportDefaultSpecifier"</span>:
        <span class="hljs-keyword">return</span> path.call(print, <span class="hljs-string">"exported"</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ImportDeclaration"</span>:
        parts.push(<span class="hljs-string">"import "</span>);

        <span class="hljs-keyword">if</span> (n.importKind &amp;&amp; n.importKind !== <span class="hljs-string">"value"</span>) {
            parts.push(n.importKind + <span class="hljs-string">" "</span>);
        }

        <span class="hljs-keyword">if</span> (n.specifiers &amp;&amp;
            n.specifiers.length &gt; <span class="hljs-number">0</span>) {

            <span class="hljs-keyword">var</span> foundImportSpecifier = <span class="hljs-literal">false</span>;

            path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">specifierPath</span>) </span>{
                <span class="hljs-keyword">var</span> i = specifierPath.getName();
                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
                    parts.push(<span class="hljs-string">", "</span>);
                }

                <span class="hljs-keyword">var</span> value = specifierPath.getValue();

                <span class="hljs-keyword">if</span> (namedTypes.ImportDefaultSpecifier.check(value) ||
                    namedTypes.ImportNamespaceSpecifier.check(value)) {
                    assert.strictEqual(foundImportSpecifier, <span class="hljs-literal">false</span>);
                } <span class="hljs-keyword">else</span> {
                    namedTypes.ImportSpecifier.assert(value);
                    <span class="hljs-keyword">if</span> (!foundImportSpecifier) {
                        foundImportSpecifier = <span class="hljs-literal">true</span>;
                        parts.push(<span class="hljs-string">"{"</span>);
                    }
                }

                parts.push(print(specifierPath));
            }, <span class="hljs-string">"specifiers"</span>);

            <span class="hljs-keyword">if</span> (foundImportSpecifier) {
                parts.push(<span class="hljs-string">"}"</span>);
            }

            parts.push(<span class="hljs-string">" from "</span>);
        }

        parts.push(path.call(print, <span class="hljs-string">"source"</span>), <span class="hljs-string">";"</span>);

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"BlockStatement"</span>:
        <span class="hljs-keyword">var</span> naked = path.call(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bodyPath</span>) </span>{
            <span class="hljs-keyword">return</span> printStatementSequence(bodyPath, options, print);
        }, <span class="hljs-string">"body"</span>);

        <span class="hljs-keyword">if</span> (naked.isEmpty()) {
            <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"{}"</span>);
        }

        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"{\n"</span>,
            naked.indent(options.tabWidth),
            <span class="hljs-string">"\n}"</span>
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ReturnStatement"</span>:
        parts.push(<span class="hljs-string">"return"</span>);

        <span class="hljs-keyword">if</span> (n.argument) {
            <span class="hljs-keyword">var</span> argLines = path.call(print, <span class="hljs-string">"argument"</span>);
            <span class="hljs-keyword">if</span> (argLines.length &gt; <span class="hljs-number">1</span> &amp;&amp;
                namedTypes.JSXElement &amp;&amp;
                namedTypes.JSXElement.check(n.argument)) {
                parts.push(
                    <span class="hljs-string">" (\n"</span>,
                    argLines.indent(options.tabWidth),
                    <span class="hljs-string">"\n)"</span>
                );
            } <span class="hljs-keyword">else</span> {
                parts.push(<span class="hljs-string">" "</span>, argLines);
            }
        }

        parts.push(<span class="hljs-string">";"</span>);

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"CallExpression"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"callee"</span>),
            printArgumentsList(path, options, print)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ObjectExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"ObjectPattern"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"ObjectTypeAnnotation"</span>:
        <span class="hljs-keyword">var</span> allowBreak = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">var</span> isTypeAnnotation = n.type === <span class="hljs-string">"ObjectTypeAnnotation"</span>;
        <span class="hljs-keyword">var</span> separator = isTypeAnnotation ? <span class="hljs-string">';'</span> : <span class="hljs-string">','</span>;
        <span class="hljs-keyword">var</span> fields = [];

        <span class="hljs-keyword">if</span> (isTypeAnnotation) {
            fields.push(<span class="hljs-string">"indexers"</span>, <span class="hljs-string">"callProperties"</span>);
        }

        fields.push(<span class="hljs-string">"properties"</span>);

        <span class="hljs-keyword">var</span> len = <span class="hljs-number">0</span>;
        fields.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">field</span>) </span>{
            len += n[field].length;
        });

        <span class="hljs-keyword">var</span> oneLine = (isTypeAnnotation &amp;&amp; len === <span class="hljs-number">1</span>) || len === <span class="hljs-number">0</span>;
        parts.push(oneLine ? <span class="hljs-string">"{"</span> : <span class="hljs-string">"{\n"</span>);

        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
        fields.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">field</span>) </span>{
            path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">childPath</span>) </span>{
                <span class="hljs-keyword">var</span> lines = print(childPath);

                <span class="hljs-keyword">if</span> (!oneLine) {
                    lines = lines.indent(options.tabWidth);
                }

                <span class="hljs-keyword">var</span> multiLine = !isTypeAnnotation &amp;&amp; lines.length &gt; <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> (multiLine &amp;&amp; allowBreak) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Similar to the logic for BlockStatement.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    parts.push(<span class="hljs-string">"\n"</span>);
                }

                parts.push(lines);

                <span class="hljs-keyword">if</span> (i &lt; len - <span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Add an extra line break if the previous object property
had a multi-line value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    parts.push(separator + (multiLine ? <span class="hljs-string">"\n\n"</span> : <span class="hljs-string">"\n"</span>));
                    allowBreak = !multiLine;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len !== <span class="hljs-number">1</span> &amp;&amp; isTypeAnnotation) {
                    parts.push(separator);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.trailingComma) {
                    parts.push(separator);
                }
                i++;
            }, field);
        });

        parts.push(oneLine ? <span class="hljs-string">"}"</span> : <span class="hljs-string">"\n}"</span>);

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"PropertyPattern"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"key"</span>),
            <span class="hljs-string">": "</span>,
            path.call(print, <span class="hljs-string">"pattern"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"Property"</span>: <span class="hljs-comment">// Non-standard AST node type.</span>
        <span class="hljs-keyword">if</span> (n.method || n.kind === <span class="hljs-string">"get"</span> || n.kind === <span class="hljs-string">"set"</span>) {
            <span class="hljs-keyword">return</span> printMethod(path, options, print);
        }

        <span class="hljs-keyword">var</span> key = path.call(print, <span class="hljs-string">"key"</span>);
        <span class="hljs-keyword">if</span> (n.computed) {
            parts.push(<span class="hljs-string">"["</span>, key, <span class="hljs-string">"]"</span>);
        } <span class="hljs-keyword">else</span> {
            parts.push(key);
        }

        <span class="hljs-keyword">if</span> (! n.shorthand) {
            parts.push(<span class="hljs-string">": "</span>, path.call(print, <span class="hljs-string">"value"</span>));
        }

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"Decorator"</span>:
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"@"</span>, path.call(print, <span class="hljs-string">"expression"</span>)]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ArrayExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"ArrayPattern"</span>:
        <span class="hljs-keyword">var</span> elems = n.elements,
            len = elems.length;

        <span class="hljs-keyword">var</span> printed = path.map(print, <span class="hljs-string">"elements"</span>);
        <span class="hljs-keyword">var</span> joined = fromString(<span class="hljs-string">", "</span>).join(printed);
        <span class="hljs-keyword">var</span> oneLine = joined.getLineLength(<span class="hljs-number">1</span>) &lt;= options.wrapColumn;
        parts.push(oneLine ? <span class="hljs-string">"["</span> : <span class="hljs-string">"[\n"</span>);

        path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elemPath</span>) </span>{
            <span class="hljs-keyword">var</span> i = elemPath.getName();
            <span class="hljs-keyword">var</span> elem = elemPath.getValue();
            <span class="hljs-keyword">if</span> (!elem) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>If the array expression ends with a hole, that hole
will be ignored by the interpreter, but if it ends with
two (or more) holes, we need to write out two (or more)
commas so that the resulting code is interpreted with
both (all) of the holes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                parts.push(<span class="hljs-string">","</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> lines = printed[i];
                <span class="hljs-keyword">if</span> (oneLine) {
                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)
                        parts.push(<span class="hljs-string">" "</span>);
                } <span class="hljs-keyword">else</span> {
                    lines = lines.indent(options.tabWidth);
                }
                parts.push(lines);
                <span class="hljs-keyword">if</span> (i &lt; len - <span class="hljs-number">1</span> || (!oneLine &amp;&amp; options.trailingComma))
                    parts.push(<span class="hljs-string">","</span>);
                <span class="hljs-keyword">if</span> (!oneLine)
                    parts.push(<span class="hljs-string">"\n"</span>);
            }
        }, <span class="hljs-string">"elements"</span>);

        parts.push(<span class="hljs-string">"]"</span>);

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"SequenceExpression"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">", "</span>).join(path.map(print, <span class="hljs-string">"expressions"</span>));

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ThisExpression"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"this"</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"Super"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"super"</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"Literal"</span>:
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n.value !== <span class="hljs-string">"string"</span>)
            <span class="hljs-keyword">return</span> fromString(n.value, options);

        <span class="hljs-keyword">return</span> fromString(nodeStr(n.value, options), options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ModuleSpecifier"</span>:
        <span class="hljs-keyword">if</span> (n.local) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                <span class="hljs-string">"The ESTree ModuleSpecifier type should be abstract"</span>
            );
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>The Esprima ModuleSpecifier type is just a string-valued
Literal identifying the imported-from module.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> fromString(nodeStr(n.value, options), options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
        parts.push(n.operator);
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/[a-z]$/</span>.test(n.operator))
            parts.push(<span class="hljs-string">" "</span>);
        parts.push(path.call(print, <span class="hljs-string">"argument"</span>));
        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"UpdateExpression"</span>:
        parts.push(
            path.call(print, <span class="hljs-string">"argument"</span>),
            n.operator
        );

        <span class="hljs-keyword">if</span> (n.prefix)
            parts.reverse();

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ConditionalExpression"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"("</span>, path.call(print, <span class="hljs-string">"test"</span>),
            <span class="hljs-string">" ? "</span>, path.call(print, <span class="hljs-string">"consequent"</span>),
            <span class="hljs-string">" : "</span>, path.call(print, <span class="hljs-string">"alternate"</span>), <span class="hljs-string">")"</span>
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"NewExpression"</span>:
        parts.push(<span class="hljs-string">"new "</span>, path.call(print, <span class="hljs-string">"callee"</span>));
        <span class="hljs-keyword">var</span> args = n.arguments;
        <span class="hljs-keyword">if</span> (args) {
            parts.push(printArgumentsList(path, options, print));
        }

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"VariableDeclaration"</span>:
        parts.push(n.kind, <span class="hljs-string">" "</span>);
        <span class="hljs-keyword">var</span> maxLen = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> printed = path.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">childPath</span>) </span>{
            <span class="hljs-keyword">var</span> lines = print(childPath);
            maxLen = <span class="hljs-built_in">Math</span>.max(lines.length, maxLen);
            <span class="hljs-keyword">return</span> lines;
        }, <span class="hljs-string">"declarations"</span>);

        <span class="hljs-keyword">if</span> (maxLen === <span class="hljs-number">1</span>) {
            parts.push(fromString(<span class="hljs-string">", "</span>).join(printed));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (printed.length &gt; <span class="hljs-number">1</span> ) {
            parts.push(
                fromString(<span class="hljs-string">",\n"</span>).join(printed)
                    .indentTail(n.kind.length + <span class="hljs-number">1</span>)
            );
        } <span class="hljs-keyword">else</span> {
            parts.push(printed[<span class="hljs-number">0</span>]);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>We generally want to terminate all variable declarations with a
semicolon, except when they are children of for loops.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> parentNode = path.getParentNode();
        <span class="hljs-keyword">if</span> (!namedTypes.ForStatement.check(parentNode) &amp;&amp;
            !namedTypes.ForInStatement.check(parentNode) &amp;&amp;
            !(namedTypes.ForOfStatement &amp;&amp;
              namedTypes.ForOfStatement.check(parentNode))) {
            parts.push(<span class="hljs-string">";"</span>);
        }

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"VariableDeclarator"</span>:
        <span class="hljs-keyword">return</span> n.init ? fromString(<span class="hljs-string">" = "</span>).join([
            path.call(print, <span class="hljs-string">"id"</span>),
            path.call(print, <span class="hljs-string">"init"</span>)
        ]) : path.call(print, <span class="hljs-string">"id"</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"WithStatement"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"with ("</span>,
            path.call(print, <span class="hljs-string">"object"</span>),
            <span class="hljs-string">") "</span>,
            path.call(print, <span class="hljs-string">"body"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"IfStatement"</span>:
        <span class="hljs-keyword">var</span> con = adjustClause(path.call(print, <span class="hljs-string">"consequent"</span>), options),
            parts = [<span class="hljs-string">"if ("</span>, path.call(print, <span class="hljs-string">"test"</span>), <span class="hljs-string">")"</span>, con];

        <span class="hljs-keyword">if</span> (n.alternate)
            parts.push(
                endsWithBrace(con) ? <span class="hljs-string">" else"</span> : <span class="hljs-string">"\nelse"</span>,
                adjustClause(path.call(print, <span class="hljs-string">"alternate"</span>), options));

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ForStatement"</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>TODO Get the for (;;) case right.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> init = path.call(print, <span class="hljs-string">"init"</span>),
            sep = init.length &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">";\n"</span> : <span class="hljs-string">"; "</span>,
            forParen = <span class="hljs-string">"for ("</span>,
            indented = fromString(sep).join([
                init,
                path.call(print, <span class="hljs-string">"test"</span>),
                path.call(print, <span class="hljs-string">"update"</span>)
            ]).indentTail(forParen.length),
            head = concat([forParen, indented, <span class="hljs-string">")"</span>]),
            clause = adjustClause(path.call(print, <span class="hljs-string">"body"</span>), options),
            parts = [head];

        <span class="hljs-keyword">if</span> (head.length &gt; <span class="hljs-number">1</span>) {
            parts.push(<span class="hljs-string">"\n"</span>);
            clause = clause.trimLeft();
        }

        parts.push(clause);

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"WhileStatement"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"while ("</span>,
            path.call(print, <span class="hljs-string">"test"</span>),
            <span class="hljs-string">")"</span>,
            adjustClause(path.call(print, <span class="hljs-string">"body"</span>), options)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ForInStatement"</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>Note: esprima can't actually parse &quot;for each (&quot;.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> concat([
            n.each ? <span class="hljs-string">"for each ("</span> : <span class="hljs-string">"for ("</span>,
            path.call(print, <span class="hljs-string">"left"</span>),
            <span class="hljs-string">" in "</span>,
            path.call(print, <span class="hljs-string">"right"</span>),
            <span class="hljs-string">")"</span>,
            adjustClause(path.call(print, <span class="hljs-string">"body"</span>), options)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ForOfStatement"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"for ("</span>,
            path.call(print, <span class="hljs-string">"left"</span>),
            <span class="hljs-string">" of "</span>,
            path.call(print, <span class="hljs-string">"right"</span>),
            <span class="hljs-string">")"</span>,
            adjustClause(path.call(print, <span class="hljs-string">"body"</span>), options)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"DoWhileStatement"</span>:
        <span class="hljs-keyword">var</span> doBody = concat([
            <span class="hljs-string">"do"</span>,
            adjustClause(path.call(print, <span class="hljs-string">"body"</span>), options)
        ]), parts = [doBody];

        <span class="hljs-keyword">if</span> (endsWithBrace(doBody))
            parts.push(<span class="hljs-string">" while"</span>);
        <span class="hljs-keyword">else</span>
            parts.push(<span class="hljs-string">"\nwhile"</span>);

        parts.push(<span class="hljs-string">" ("</span>, path.call(print, <span class="hljs-string">"test"</span>), <span class="hljs-string">");"</span>);

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"DoExpression"</span>:
        <span class="hljs-keyword">var</span> statements = path.call(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bodyPath</span>) </span>{
            <span class="hljs-keyword">return</span> printStatementSequence(bodyPath, options, print);
        }, <span class="hljs-string">"body"</span>);

        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"do {\n"</span>,
            statements.indent(options.tabWidth),
            <span class="hljs-string">"\n}"</span>
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"BreakStatement"</span>:
        parts.push(<span class="hljs-string">"break"</span>);
        <span class="hljs-keyword">if</span> (n.label)
            parts.push(<span class="hljs-string">" "</span>, path.call(print, <span class="hljs-string">"label"</span>));
        parts.push(<span class="hljs-string">";"</span>);
        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ContinueStatement"</span>:
        parts.push(<span class="hljs-string">"continue"</span>);
        <span class="hljs-keyword">if</span> (n.label)
            parts.push(<span class="hljs-string">" "</span>, path.call(print, <span class="hljs-string">"label"</span>));
        parts.push(<span class="hljs-string">";"</span>);
        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"LabeledStatement"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"label"</span>),
            <span class="hljs-string">":\n"</span>,
            path.call(print, <span class="hljs-string">"body"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"TryStatement"</span>:
        parts.push(
            <span class="hljs-string">"try "</span>,
            path.call(print, <span class="hljs-string">"block"</span>)
        );

        <span class="hljs-keyword">if</span> (n.handler) {
            parts.push(<span class="hljs-string">" "</span>, path.call(print, <span class="hljs-string">"handler"</span>));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.handlers) {
            path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handlerPath</span>) </span>{
                parts.push(<span class="hljs-string">" "</span>, print(handlerPath));
            }, <span class="hljs-string">"handlers"</span>);
        }

        <span class="hljs-keyword">if</span> (n.finalizer) {
            parts.push(<span class="hljs-string">" finally "</span>, path.call(print, <span class="hljs-string">"finalizer"</span>));
        }

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"CatchClause"</span>:
        parts.push(<span class="hljs-string">"catch ("</span>, path.call(print, <span class="hljs-string">"param"</span>));

        <span class="hljs-keyword">if</span> (n.guard)
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>Note: esprima does not recognize conditional catch clauses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            parts.push(<span class="hljs-string">" if "</span>, path.call(print, <span class="hljs-string">"guard"</span>));

        parts.push(<span class="hljs-string">") "</span>, path.call(print, <span class="hljs-string">"body"</span>));

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ThrowStatement"</span>:
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"throw "</span>, path.call(print, <span class="hljs-string">"argument"</span>), <span class="hljs-string">";"</span>]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"SwitchStatement"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"switch ("</span>,
            path.call(print, <span class="hljs-string">"discriminant"</span>),
            <span class="hljs-string">") {\n"</span>,
            fromString(<span class="hljs-string">"\n"</span>).join(path.map(print, <span class="hljs-string">"cases"</span>)),
            <span class="hljs-string">"\n}"</span>
        ]);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>Note: ignoring n.lexical because it has no printing consequences.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">case</span> <span class="hljs-string">"SwitchCase"</span>:
        <span class="hljs-keyword">if</span> (n.test)
            parts.push(<span class="hljs-string">"case "</span>, path.call(print, <span class="hljs-string">"test"</span>), <span class="hljs-string">":"</span>);
        <span class="hljs-keyword">else</span>
            parts.push(<span class="hljs-string">"default:"</span>);

        <span class="hljs-keyword">if</span> (n.consequent.length &gt; <span class="hljs-number">0</span>) {
            parts.push(<span class="hljs-string">"\n"</span>, path.call(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">consequentPath</span>) </span>{
                <span class="hljs-keyword">return</span> printStatementSequence(consequentPath, options, print);
            }, <span class="hljs-string">"consequent"</span>).indent(options.tabWidth));
        }

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"DebuggerStatement"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"debugger;"</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>JSX extensions below.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXAttribute"</span>:
        parts.push(path.call(print, <span class="hljs-string">"name"</span>));
        <span class="hljs-keyword">if</span> (n.value)
            parts.push(<span class="hljs-string">"="</span>, path.call(print, <span class="hljs-string">"value"</span>));
        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXIdentifier"</span>:
        <span class="hljs-keyword">return</span> fromString(n.name, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXNamespacedName"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">":"</span>).join([
            path.call(print, <span class="hljs-string">"namespace"</span>),
            path.call(print, <span class="hljs-string">"name"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXMemberExpression"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"."</span>).join([
            path.call(print, <span class="hljs-string">"object"</span>),
            path.call(print, <span class="hljs-string">"property"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXSpreadAttribute"</span>:
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"{..."</span>, path.call(print, <span class="hljs-string">"argument"</span>), <span class="hljs-string">"}"</span>]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXExpressionContainer"</span>:
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"{"</span>, path.call(print, <span class="hljs-string">"expression"</span>), <span class="hljs-string">"}"</span>]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXElement"</span>:
        <span class="hljs-keyword">var</span> openingLines = path.call(print, <span class="hljs-string">"openingElement"</span>);

        <span class="hljs-keyword">if</span> (n.openingElement.selfClosing) {
            assert.ok(!n.closingElement);
            <span class="hljs-keyword">return</span> openingLines;
        }

        <span class="hljs-keyword">var</span> childLines = concat(
            path.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">childPath</span>) </span>{
                <span class="hljs-keyword">var</span> child = childPath.getValue();

                <span class="hljs-keyword">if</span> (namedTypes.Literal.check(child) &amp;&amp;
                    <span class="hljs-keyword">typeof</span> child.value === <span class="hljs-string">"string"</span>) {
                    <span class="hljs-keyword">return</span> child.value;
                }

                <span class="hljs-keyword">return</span> print(childPath);
            }, <span class="hljs-string">"children"</span>)
        ).indentTail(options.tabWidth);

        <span class="hljs-keyword">var</span> closingLines = path.call(print, <span class="hljs-string">"closingElement"</span>);

        <span class="hljs-keyword">return</span> concat([
            openingLines,
            childLines,
            closingLines
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXOpeningElement"</span>:
        parts.push(<span class="hljs-string">"&lt;"</span>, path.call(print, <span class="hljs-string">"name"</span>));
        <span class="hljs-keyword">var</span> attrParts = [];

        path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attrPath</span>) </span>{
            attrParts.push(<span class="hljs-string">" "</span>, print(attrPath));
        }, <span class="hljs-string">"attributes"</span>);

        <span class="hljs-keyword">var</span> attrLines = concat(attrParts);

        <span class="hljs-keyword">var</span> needLineWrap = (
            attrLines.length &gt; <span class="hljs-number">1</span> ||
            attrLines.getLineLength(<span class="hljs-number">1</span>) &gt; options.wrapColumn
        );

        <span class="hljs-keyword">if</span> (needLineWrap) {
            attrParts.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">part, i</span>) </span>{
                <span class="hljs-keyword">if</span> (part === <span class="hljs-string">" "</span>) {
                    assert.strictEqual(i % <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);
                    attrParts[i] = <span class="hljs-string">"\n"</span>;
                }
            });

            attrLines = concat(attrParts).indentTail(options.tabWidth);
        }

        parts.push(attrLines, n.selfClosing ? <span class="hljs-string">" /&gt;"</span> : <span class="hljs-string">"&gt;"</span>);

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXClosingElement"</span>:
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"&lt;/"</span>, path.call(print, <span class="hljs-string">"name"</span>), <span class="hljs-string">"&gt;"</span>]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXText"</span>:
        <span class="hljs-keyword">return</span> fromString(n.value, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"JSXEmptyExpression"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">""</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"TypeAnnotatedIdentifier"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"annotation"</span>),
            <span class="hljs-string">" "</span>,
            path.call(print, <span class="hljs-string">"identifier"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ClassBody"</span>:
        <span class="hljs-keyword">if</span> (n.body.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"{}"</span>);
        }

        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"{\n"</span>,
            path.call(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bodyPath</span>) </span>{
                <span class="hljs-keyword">return</span> printStatementSequence(bodyPath, options, print);
            }, <span class="hljs-string">"body"</span>).indent(options.tabWidth),
            <span class="hljs-string">"\n}"</span>
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ClassPropertyDefinition"</span>:
        parts.push(<span class="hljs-string">"static "</span>, path.call(print, <span class="hljs-string">"definition"</span>));
        <span class="hljs-keyword">if</span> (!namedTypes.MethodDefinition.check(n.definition))
            parts.push(<span class="hljs-string">";"</span>);
        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ClassProperty"</span>:
        <span class="hljs-keyword">if</span> (n.static)
            parts.push(<span class="hljs-string">"static "</span>);

        parts.push(path.call(print, <span class="hljs-string">"key"</span>));
        <span class="hljs-keyword">if</span> (n.typeAnnotation)
            parts.push(path.call(print, <span class="hljs-string">"typeAnnotation"</span>));

        <span class="hljs-keyword">if</span> (n.value)
            parts.push(<span class="hljs-string">" = "</span>, path.call(print, <span class="hljs-string">"value"</span>));

        parts.push(<span class="hljs-string">";"</span>);
        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ClassDeclaration"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"ClassExpression"</span>:
        parts.push(<span class="hljs-string">"class"</span>);

        <span class="hljs-keyword">if</span> (n.id) {
            parts.push(
                <span class="hljs-string">" "</span>,
                path.call(print, <span class="hljs-string">"id"</span>),
                path.call(print, <span class="hljs-string">"typeParameters"</span>)
            );
        }

        <span class="hljs-keyword">if</span> (n.superClass) {
            parts.push(
                <span class="hljs-string">" extends "</span>,
                path.call(print, <span class="hljs-string">"superClass"</span>),
                path.call(print, <span class="hljs-string">"superTypeParameters"</span>)
            );
        }

        <span class="hljs-keyword">if</span> (n[<span class="hljs-string">"implements"</span>] &amp;&amp; n[<span class="hljs-string">'implements'</span>].length &gt; <span class="hljs-number">0</span>) {
            parts.push(
                <span class="hljs-string">" implements "</span>,
                fromString(<span class="hljs-string">", "</span>).join(path.map(print, <span class="hljs-string">"implements"</span>))
            );
        }

        parts.push(<span class="hljs-string">" "</span>, path.call(print, <span class="hljs-string">"body"</span>));

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"TemplateElement"</span>:
        <span class="hljs-keyword">return</span> fromString(n.value.raw, options).lockIndentTail();

    <span class="hljs-keyword">case</span> <span class="hljs-string">"TemplateLiteral"</span>:
        <span class="hljs-keyword">var</span> expressions = path.map(print, <span class="hljs-string">"expressions"</span>);
        parts.push(<span class="hljs-string">"`"</span>);

        path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">childPath</span>) </span>{
            <span class="hljs-keyword">var</span> i = childPath.getName();
            parts.push(print(childPath));
            <span class="hljs-keyword">if</span> (i &lt; expressions.length) {
                parts.push(<span class="hljs-string">"${"</span>, expressions[i], <span class="hljs-string">"}"</span>);
            }
        }, <span class="hljs-string">"quasis"</span>);

        parts.push(<span class="hljs-string">"`"</span>);

        <span class="hljs-keyword">return</span> concat(parts).lockIndentTail();

    <span class="hljs-keyword">case</span> <span class="hljs-string">"TaggedTemplateExpression"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"tag"</span>),
            path.call(print, <span class="hljs-string">"quasi"</span>)
        ]);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>These types are unprintable because they serve as abstract
supertypes for other (printable) types.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">case</span> <span class="hljs-string">"Node"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Printable"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"SourceLocation"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Position"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Statement"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Function"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Pattern"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Expression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Declaration"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Specifier"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"NamedSpecifier"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Comment"</span>: <span class="hljs-comment">// Supertype of Block and Line.</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberTypeAnnotation"</span>: <span class="hljs-comment">// Flow</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"TupleTypeAnnotation"</span>: <span class="hljs-comment">// Flow</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Type"</span>: <span class="hljs-comment">// Flow</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"unprintable type: "</span> + <span class="hljs-built_in">JSON</span>.stringify(n.type));

    <span class="hljs-keyword">case</span> <span class="hljs-string">"CommentBlock"</span>: <span class="hljs-comment">// Babel block comment.</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Block"</span>: <span class="hljs-comment">// Esprima block comment.</span>
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"/*"</span>, fromString(n.value, options), <span class="hljs-string">"*/"</span>]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"CommentLine"</span>: <span class="hljs-comment">// Babel line comment.</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Line"</span>: <span class="hljs-comment">// Esprima line comment.</span>
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"//"</span>, fromString(n.value, options)]);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>Type Annotations for Facebook Flow, typically stripped out or
transformed away before printing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">case</span> <span class="hljs-string">"TypeAnnotation"</span>:
        <span class="hljs-keyword">if</span> (n.typeAnnotation) {
            <span class="hljs-keyword">if</span> (n.typeAnnotation.type !== <span class="hljs-string">"FunctionTypeAnnotation"</span>) {
                parts.push(<span class="hljs-string">": "</span>);
            }
            parts.push(path.call(print, <span class="hljs-string">"typeAnnotation"</span>));
            <span class="hljs-keyword">return</span> concat(parts);
        }

        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">""</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"AnyTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"any"</span>, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"MixedTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"mixed"</span>, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ArrayTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"elementType"</span>),
            <span class="hljs-string">"[]"</span>
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"BooleanTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"boolean"</span>, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"BooleanLiteralTypeAnnotation"</span>:
        assert.strictEqual(<span class="hljs-keyword">typeof</span> n.value, <span class="hljs-string">"boolean"</span>);
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">""</span> + n.value, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"DeclareClass"</span>:
        <span class="hljs-keyword">return</span> printFlowDeclaration(path, [
            <span class="hljs-string">"class "</span>,
            path.call(print, <span class="hljs-string">"id"</span>),
            <span class="hljs-string">" "</span>,
            path.call(print, <span class="hljs-string">"body"</span>),
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"DeclareFunction"</span>:
        <span class="hljs-keyword">return</span> printFlowDeclaration(path, [
            <span class="hljs-string">"function "</span>,
            path.call(print, <span class="hljs-string">"id"</span>),
            <span class="hljs-string">";"</span>
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"DeclareModule"</span>:
        <span class="hljs-keyword">return</span> printFlowDeclaration(path, [
            <span class="hljs-string">"module "</span>,
            path.call(print, <span class="hljs-string">"id"</span>),
            <span class="hljs-string">" "</span>,
            path.call(print, <span class="hljs-string">"body"</span>),
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"DeclareVariable"</span>:
        <span class="hljs-keyword">return</span> printFlowDeclaration(path, [
            <span class="hljs-string">"var "</span>,
            path.call(print, <span class="hljs-string">"id"</span>),
            <span class="hljs-string">";"</span>
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"DeclareExportDeclaration"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"declare "</span>,
            printExportDeclaration(path, options, print)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"FunctionTypeAnnotation"</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>FunctionTypeAnnotation is ambiguous:
declare function(a: B): void; OR
var A: (a: B) =&gt; void;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> parent = path.getParentNode(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">var</span> isArrowFunctionTypeAnnotation = !(
            namedTypes.ObjectTypeCallProperty.check(parent) ||
            namedTypes.DeclareFunction.check(path.getParentNode(<span class="hljs-number">2</span>))
        );

        <span class="hljs-keyword">var</span> needsColon =
            isArrowFunctionTypeAnnotation &amp;&amp;
            !namedTypes.FunctionTypeParam.check(parent);

        <span class="hljs-keyword">if</span> (needsColon) {
            parts.push(<span class="hljs-string">": "</span>);
        }

        parts.push(
            <span class="hljs-string">"("</span>,
            fromString(<span class="hljs-string">", "</span>).join(path.map(print, <span class="hljs-string">"params"</span>)),
            <span class="hljs-string">")"</span>
        );

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>The returnType is not wrapped in a TypeAnnotation, so the colon
needs to be added separately.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (n.returnType) {
            parts.push(
                isArrowFunctionTypeAnnotation ? <span class="hljs-string">" =&gt; "</span> : <span class="hljs-string">": "</span>,
                path.call(print, <span class="hljs-string">"returnType"</span>)
            );
        }

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"FunctionTypeParam"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"name"</span>),
            n.optional ? <span class="hljs-string">'?'</span> : <span class="hljs-string">''</span>,
            <span class="hljs-string">": "</span>,
            path.call(print, <span class="hljs-string">"typeAnnotation"</span>),
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"GenericTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"id"</span>),
            path.call(print, <span class="hljs-string">"typeParameters"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"DeclareInterface"</span>:
        parts.push(<span class="hljs-string">"declare "</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"InterfaceDeclaration"</span>:
        parts.push(
            fromString(<span class="hljs-string">"interface "</span>, options),
            path.call(print, <span class="hljs-string">"id"</span>),
            path.call(print, <span class="hljs-string">"typeParameters"</span>),
            <span class="hljs-string">" "</span>
        );

        <span class="hljs-keyword">if</span> (n[<span class="hljs-string">"extends"</span>]) {
            parts.push(
                <span class="hljs-string">"extends "</span>,
                fromString(<span class="hljs-string">", "</span>).join(path.map(print, <span class="hljs-string">"extends"</span>))
            );
        }

        parts.push(<span class="hljs-string">" "</span>, path.call(print, <span class="hljs-string">"body"</span>));

        <span class="hljs-keyword">return</span> concat(parts);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ClassImplements"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"InterfaceExtends"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"id"</span>),
            path.call(print, <span class="hljs-string">"typeParameters"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"IntersectionTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">" &amp; "</span>).join(path.map(print, <span class="hljs-string">"types"</span>));

    <span class="hljs-keyword">case</span> <span class="hljs-string">"NullableTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"?"</span>,
            path.call(print, <span class="hljs-string">"typeAnnotation"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"NullLiteralTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"null"</span>, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ThisTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"this"</span>, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"NumberTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"number"</span>, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ObjectTypeCallProperty"</span>:
        <span class="hljs-keyword">return</span> path.call(print, <span class="hljs-string">"value"</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ObjectTypeIndexer"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"["</span>,
            path.call(print, <span class="hljs-string">"id"</span>),
            <span class="hljs-string">": "</span>,
            path.call(print, <span class="hljs-string">"key"</span>),
            <span class="hljs-string">"]: "</span>,
            path.call(print, <span class="hljs-string">"value"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"ObjectTypeProperty"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"key"</span>),
            n.optional ? <span class="hljs-string">"?"</span> : <span class="hljs-string">""</span>,
            <span class="hljs-string">": "</span>,
            path.call(print, <span class="hljs-string">"value"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"QualifiedTypeIdentifier"</span>:
        <span class="hljs-keyword">return</span> concat([
            path.call(print, <span class="hljs-string">"qualification"</span>),
            <span class="hljs-string">"."</span>,
            path.call(print, <span class="hljs-string">"id"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"StringLiteralTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(nodeStr(n.value, options), options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"NumberLiteralTypeAnnotation"</span>:
        assert.strictEqual(<span class="hljs-keyword">typeof</span> n.value, <span class="hljs-string">"number"</span>);
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">""</span> + n.value, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"StringTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"string"</span>, options);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"DeclareTypeAlias"</span>:
        parts.push(<span class="hljs-string">"declare "</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"TypeAlias"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"type "</span>,
            path.call(print, <span class="hljs-string">"id"</span>),
            <span class="hljs-string">" = "</span>,
            path.call(print, <span class="hljs-string">"right"</span>),
            <span class="hljs-string">";"</span>
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"TypeCastExpression"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"("</span>,
            path.call(print, <span class="hljs-string">"expression"</span>),
            path.call(print, <span class="hljs-string">"typeAnnotation"</span>),
            <span class="hljs-string">")"</span>
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"TypeParameterDeclaration"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"TypeParameterInstantiation"</span>:
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"&lt;"</span>,
            fromString(<span class="hljs-string">", "</span>).join(path.map(print, <span class="hljs-string">"params"</span>)),
            <span class="hljs-string">"&gt;"</span>
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"TypeofTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> concat([
            fromString(<span class="hljs-string">"typeof "</span>, options),
            path.call(print, <span class="hljs-string">"argument"</span>)
        ]);

    <span class="hljs-keyword">case</span> <span class="hljs-string">"UnionTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">" | "</span>).join(path.map(print, <span class="hljs-string">"types"</span>));

    <span class="hljs-keyword">case</span> <span class="hljs-string">"VoidTypeAnnotation"</span>:
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">"void"</span>, options);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>Unhandled types below. If encountered, nodes of these types should
be either left alone or desugared into AST types that are fully
supported by the pretty-printer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">case</span> <span class="hljs-string">"ClassHeritage"</span>: <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"ComprehensionBlock"</span>: <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"ComprehensionExpression"</span>: <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Glob"</span>: <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"GeneratorExpression"</span>: <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"LetStatement"</span>: <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"LetExpression"</span>: <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"GraphExpression"</span>: <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"GraphIndexExpression"</span>: <span class="hljs-comment">// TODO</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>XML types that nobody cares about or needs to print.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLDefaultDeclaration"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLAnyName"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLQualifiedIdentifier"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLFunctionQualifiedIdentifier"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLAttributeSelector"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLFilterExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XML"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLElement"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLList"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLEscape"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLText"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLStartTag"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLEndTag"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLPointTag"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLName"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLAttribute"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLCdata"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLComment"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"XMLProcessingInstruction"</span>:
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">debugger</span>;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"unknown type: "</span> + <span class="hljs-built_in">JSON</span>.stringify(n.type));
    }

    <span class="hljs-keyword">return</span> p;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printStatementSequence</span>(<span class="hljs-params">path, options, print</span>) </span>{
    <span class="hljs-keyword">var</span> inClassBody =
        namedTypes.ClassBody &amp;&amp;
        namedTypes.ClassBody.check(path.getParentNode());

    <span class="hljs-keyword">var</span> filtered = [];
    <span class="hljs-keyword">var</span> sawComment = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> sawStatement = <span class="hljs-literal">false</span>;

    path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stmtPath</span>) </span>{
        <span class="hljs-keyword">var</span> i = stmtPath.getName();
        <span class="hljs-keyword">var</span> stmt = stmtPath.getValue();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>Just in case the AST has been modified to contain falsy
&quot;statements,&quot; it's safer simply to skip them.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!stmt) {
            <span class="hljs-keyword">return</span>;
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>Skip printing EmptyStatement nodes to avoid leaving stray
semicolons lying around.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (stmt.type === <span class="hljs-string">"EmptyStatement"</span>) {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (namedTypes.Comment.check(stmt)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>The pretty printer allows a dangling Comment node to act as
a Statement when the Comment can't be attached to any other
non-Comment node in the tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            sawComment = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.Statement.check(stmt)) {
            sawStatement = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>When the pretty printer encounters a string instead of an
AST node, it just prints the string. This behavior can be
useful for fine-grained formatting decisions like inserting
blank lines.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            isString.assert(stmt);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>We can't hang onto stmtPath outside of this function, because
it's just a reference to a mutable FastPath object, so we have
to go ahead and print it here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        filtered.push({
            <span class="hljs-attr">node</span>: stmt,
            <span class="hljs-attr">printed</span>: print(stmtPath)
        });
    });

    <span class="hljs-keyword">if</span> (sawComment) {
        assert.strictEqual(
            sawStatement, <span class="hljs-literal">false</span>,
            <span class="hljs-string">"Comments may appear as statements in otherwise empty statement "</span> +
                <span class="hljs-string">"lists, but may not coexist with non-Comment nodes."</span>
        );
    }

    <span class="hljs-keyword">var</span> prevTrailingSpace = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> len = filtered.length;
    <span class="hljs-keyword">var</span> parts = [];

    filtered.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">info, i</span>) </span>{
        <span class="hljs-keyword">var</span> printed = info.printed;
        <span class="hljs-keyword">var</span> stmt = info.node;
        <span class="hljs-keyword">var</span> multiLine = printed.length &gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> notFirst = i &gt; <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> notLast = i &lt; len - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> leadingSpace;
        <span class="hljs-keyword">var</span> trailingSpace;
        <span class="hljs-keyword">var</span> lines = stmt &amp;&amp; stmt.loc &amp;&amp; stmt.loc.lines;
        <span class="hljs-keyword">var</span> trueLoc = lines &amp;&amp; options.reuseWhitespace &amp;&amp;
            util.getTrueLoc(stmt, lines);

        <span class="hljs-keyword">if</span> (notFirst) {
            <span class="hljs-keyword">if</span> (trueLoc) {
                <span class="hljs-keyword">var</span> beforeStart = lines.skipSpaces(trueLoc.start, <span class="hljs-literal">true</span>);
                <span class="hljs-keyword">var</span> beforeStartLine = beforeStart ? beforeStart.line : <span class="hljs-number">1</span>;
                <span class="hljs-keyword">var</span> leadingGap = trueLoc.start.line - beforeStartLine;
                leadingSpace = <span class="hljs-built_in">Array</span>(leadingGap + <span class="hljs-number">1</span>).join(<span class="hljs-string">"\n"</span>);
            } <span class="hljs-keyword">else</span> {
                leadingSpace = multiLine ? <span class="hljs-string">"\n\n"</span> : <span class="hljs-string">"\n"</span>;
            }
        } <span class="hljs-keyword">else</span> {
            leadingSpace = <span class="hljs-string">""</span>;
        }

        <span class="hljs-keyword">if</span> (notLast) {
            <span class="hljs-keyword">if</span> (trueLoc) {
                <span class="hljs-keyword">var</span> afterEnd = lines.skipSpaces(trueLoc.end);
                <span class="hljs-keyword">var</span> afterEndLine = afterEnd ? afterEnd.line : lines.length;
                <span class="hljs-keyword">var</span> trailingGap = afterEndLine - trueLoc.end.line;
                trailingSpace = <span class="hljs-built_in">Array</span>(trailingGap + <span class="hljs-number">1</span>).join(<span class="hljs-string">"\n"</span>);
            } <span class="hljs-keyword">else</span> {
                trailingSpace = multiLine ? <span class="hljs-string">"\n\n"</span> : <span class="hljs-string">"\n"</span>;
            }
        } <span class="hljs-keyword">else</span> {
            trailingSpace = <span class="hljs-string">""</span>;
        }

        parts.push(
            maxSpace(prevTrailingSpace, leadingSpace),
            printed
        );

        <span class="hljs-keyword">if</span> (notLast) {
            prevTrailingSpace = trailingSpace;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (trailingSpace) {
            parts.push(trailingSpace);
        }
    });

    <span class="hljs-keyword">return</span> concat(parts);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxSpace</span>(<span class="hljs-params">s1, s2</span>) </span>{
    <span class="hljs-keyword">if</span> (!s1 &amp;&amp; !s2) {
        <span class="hljs-keyword">return</span> fromString(<span class="hljs-string">""</span>);
    }

    <span class="hljs-keyword">if</span> (!s1) {
        <span class="hljs-keyword">return</span> fromString(s2);
    }

    <span class="hljs-keyword">if</span> (!s2) {
        <span class="hljs-keyword">return</span> fromString(s1);
    }

    <span class="hljs-keyword">var</span> spaceLines1 = fromString(s1);
    <span class="hljs-keyword">var</span> spaceLines2 = fromString(s2);

    <span class="hljs-keyword">if</span> (spaceLines2.length &gt; spaceLines1.length) {
        <span class="hljs-keyword">return</span> spaceLines2;
    }

    <span class="hljs-keyword">return</span> spaceLines1;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printMethod</span>(<span class="hljs-params">path, options, print</span>) </span>{
    <span class="hljs-keyword">var</span> node = path.getNode();
    <span class="hljs-keyword">var</span> kind = node.kind;
    <span class="hljs-keyword">var</span> parts = [];

    namedTypes.FunctionExpression.assert(node.value);

    <span class="hljs-keyword">if</span> (node.value.async) {
        parts.push(<span class="hljs-string">"async "</span>);
    }

    <span class="hljs-keyword">if</span> (!kind || kind === <span class="hljs-string">"init"</span> || kind === <span class="hljs-string">"method"</span> || kind === <span class="hljs-string">"constructor"</span>) {
        <span class="hljs-keyword">if</span> (node.value.generator) {
            parts.push(<span class="hljs-string">"*"</span>);
        }
    } <span class="hljs-keyword">else</span> {
        assert.ok(kind === <span class="hljs-string">"get"</span> || kind === <span class="hljs-string">"set"</span>);
        parts.push(kind, <span class="hljs-string">" "</span>);
    }

    <span class="hljs-keyword">var</span> key = path.call(print, <span class="hljs-string">"key"</span>);
    <span class="hljs-keyword">if</span> (node.computed) {
        key = concat([<span class="hljs-string">"["</span>, key, <span class="hljs-string">"]"</span>]);
    }

    parts.push(
        key,
        path.call(print, <span class="hljs-string">"value"</span>, <span class="hljs-string">"typeParameters"</span>),
        <span class="hljs-string">"("</span>,
        path.call(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">valuePath</span>) </span>{
            <span class="hljs-keyword">return</span> printFunctionParams(valuePath, options, print);
        }, <span class="hljs-string">"value"</span>),
        <span class="hljs-string">")"</span>,
        path.call(print, <span class="hljs-string">"value"</span>, <span class="hljs-string">"returnType"</span>),
        <span class="hljs-string">" "</span>,
        path.call(print, <span class="hljs-string">"value"</span>, <span class="hljs-string">"body"</span>)
    );

    <span class="hljs-keyword">return</span> concat(parts);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printArgumentsList</span>(<span class="hljs-params">path, options, print</span>) </span>{
    <span class="hljs-keyword">var</span> printed = path.map(print, <span class="hljs-string">"arguments"</span>);

    <span class="hljs-keyword">var</span> joined = fromString(<span class="hljs-string">", "</span>).join(printed);
    <span class="hljs-keyword">if</span> (joined.getLineLength(<span class="hljs-number">1</span>) &gt; options.wrapColumn) {
        joined = fromString(<span class="hljs-string">",\n"</span>).join(printed);
        <span class="hljs-keyword">return</span> concat([
            <span class="hljs-string">"(\n"</span>,
            joined.indent(options.tabWidth),
            options.trailingComma ? <span class="hljs-string">",\n)"</span> : <span class="hljs-string">"\n)"</span>
        ]);
    }

    <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"("</span>, joined, <span class="hljs-string">")"</span>]);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printFunctionParams</span>(<span class="hljs-params">path, options, print</span>) </span>{
    <span class="hljs-keyword">var</span> fun = path.getValue();
    namedTypes.Function.assert(fun);

    <span class="hljs-keyword">var</span> printed = path.map(print, <span class="hljs-string">"params"</span>);

    <span class="hljs-keyword">if</span> (fun.defaults) {
        path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">defExprPath</span>) </span>{
            <span class="hljs-keyword">var</span> i = defExprPath.getName();
            <span class="hljs-keyword">var</span> p = printed[i];
            <span class="hljs-keyword">if</span> (p &amp;&amp; defExprPath.getValue()) {
                printed[i] = concat([p, <span class="hljs-string">"="</span>, print(defExprPath)]);
            }
        }, <span class="hljs-string">"defaults"</span>);
    }

    <span class="hljs-keyword">if</span> (fun.rest) {
        printed.push(concat([<span class="hljs-string">"..."</span>, path.call(print, <span class="hljs-string">"rest"</span>)]));
    }

    <span class="hljs-keyword">var</span> joined = fromString(<span class="hljs-string">", "</span>).join(printed);
    <span class="hljs-keyword">if</span> (joined.length &gt; <span class="hljs-number">1</span> ||
        joined.getLineLength(<span class="hljs-number">1</span>) &gt; options.wrapColumn) {
        joined = fromString(<span class="hljs-string">",\n"</span>).join(printed);
        <span class="hljs-keyword">if</span> (options.trailingComma &amp;&amp; !fun.rest) {
            joined = concat([joined, <span class="hljs-string">",\n"</span>]);
        }
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">"\n"</span>, joined.indent(options.tabWidth)]);
    }

    <span class="hljs-keyword">return</span> joined;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printExportDeclaration</span>(<span class="hljs-params">path, options, print</span>) </span>{
    <span class="hljs-keyword">var</span> decl = path.getValue();
    <span class="hljs-keyword">var</span> parts = [<span class="hljs-string">"export "</span>];

    namedTypes.Declaration.assert(decl);

    <span class="hljs-keyword">if</span> (decl[<span class="hljs-string">"default"</span>] ||
        decl.type === <span class="hljs-string">"ExportDefaultDeclaration"</span>) {
        parts.push(<span class="hljs-string">"default "</span>);
    }

    <span class="hljs-keyword">if</span> (decl.declaration) {
        parts.push(path.call(print, <span class="hljs-string">"declaration"</span>));

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (decl.specifiers &amp;&amp;
               decl.specifiers.length &gt; <span class="hljs-number">0</span>) {

        <span class="hljs-keyword">if</span> (decl.specifiers.length === <span class="hljs-number">1</span> &amp;&amp;
            decl.specifiers[<span class="hljs-number">0</span>].type === <span class="hljs-string">"ExportBatchSpecifier"</span>) {
            parts.push(<span class="hljs-string">"*"</span>);
        } <span class="hljs-keyword">else</span> {
            parts.push(
                <span class="hljs-string">"{"</span>,
                fromString(<span class="hljs-string">", "</span>).join(path.map(print, <span class="hljs-string">"specifiers"</span>)),
                <span class="hljs-string">"}"</span>
            );
        }

        <span class="hljs-keyword">if</span> (decl.source) {
            parts.push(<span class="hljs-string">" from "</span>, path.call(print, <span class="hljs-string">"source"</span>));
        }
    }

    <span class="hljs-keyword">var</span> lines = concat(parts);

    <span class="hljs-keyword">if</span> (lastNonSpaceCharacter(lines) !== <span class="hljs-string">";"</span>) {
        lines = concat([lines, <span class="hljs-string">";"</span>]);
    }

    <span class="hljs-keyword">return</span> lines;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printFlowDeclaration</span>(<span class="hljs-params">path, parts</span>) </span>{
    <span class="hljs-keyword">var</span> parentExportDecl = util.getParentExportDeclaration(path);

    <span class="hljs-keyword">if</span> (parentExportDecl) {
        assert.strictEqual(
            parentExportDecl.type,
            <span class="hljs-string">"DeclareExportDeclaration"</span>
        );
    } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>If the parent node has type DeclareExportDeclaration, then it
will be responsible for printing the &quot;declare&quot; token. Otherwise
it needs to be printed with this non-exported declaration node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        parts.unshift(<span class="hljs-string">"declare "</span>);
    }

    <span class="hljs-keyword">return</span> concat(parts);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adjustClause</span>(<span class="hljs-params">clause, options</span>) </span>{
    <span class="hljs-keyword">if</span> (clause.length &gt; <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> concat([<span class="hljs-string">" "</span>, clause]);

    <span class="hljs-keyword">return</span> concat([
        <span class="hljs-string">"\n"</span>,
        maybeAddSemicolon(clause).indent(options.tabWidth)
    ]);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastNonSpaceCharacter</span>(<span class="hljs-params">lines</span>) </span>{
    <span class="hljs-keyword">var</span> pos = lines.lastPos();
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">var</span> ch = lines.charAt(pos);
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\S/</span>.test(ch))
            <span class="hljs-keyword">return</span> ch;
    } <span class="hljs-keyword">while</span> (lines.prevPos(pos));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endsWithBrace</span>(<span class="hljs-params">lines</span>) </span>{
    <span class="hljs-keyword">return</span> lastNonSpaceCharacter(lines) === <span class="hljs-string">"}"</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swapQuotes</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/['"]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>) </span>{
        <span class="hljs-keyword">return</span> m === <span class="hljs-string">'"'</span> ? <span class="hljs-string">'\''</span> : <span class="hljs-string">'"'</span>;
    });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nodeStr</span>(<span class="hljs-params">str, options</span>) </span>{
    isString.assert(str);
    <span class="hljs-keyword">switch</span> (options.quote) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"auto"</span>:
        <span class="hljs-keyword">var</span> double = <span class="hljs-built_in">JSON</span>.stringify(str);
        <span class="hljs-keyword">var</span> single = swapQuotes(<span class="hljs-built_in">JSON</span>.stringify(swapQuotes(str)));
        <span class="hljs-keyword">return</span> double.length &gt; single.length ? single : double;
    <span class="hljs-keyword">case</span> <span class="hljs-string">"single"</span>:
        <span class="hljs-keyword">return</span> swapQuotes(<span class="hljs-built_in">JSON</span>.stringify(swapQuotes(str)));
    <span class="hljs-keyword">case</span> <span class="hljs-string">"double"</span>:
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(str);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeAddSemicolon</span>(<span class="hljs-params">lines</span>) </span>{
    <span class="hljs-keyword">var</span> eoc = lastNonSpaceCharacter(lines);
    <span class="hljs-keyword">if</span> (!eoc || <span class="hljs-string">"\n};"</span>.indexOf(eoc) &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> concat([lines, <span class="hljs-string">";"</span>]);
    <span class="hljs-keyword">return</span> lines;
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
