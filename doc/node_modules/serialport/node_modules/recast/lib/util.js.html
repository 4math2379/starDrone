<!DOCTYPE html>
<html>
<head>
  <title>util.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/recast/lib/util.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>util.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">"assert"</span>);
<span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>);
<span class="hljs-keyword">var</span> getFieldValue = types.getFieldValue;
<span class="hljs-keyword">var</span> n = types.namedTypes;
<span class="hljs-keyword">var</span> sourceMap = <span class="hljs-built_in">require</span>(<span class="hljs-string">"source-map"</span>);
<span class="hljs-keyword">var</span> SourceMapConsumer = sourceMap.SourceMapConsumer;
<span class="hljs-keyword">var</span> SourceMapGenerator = sourceMap.SourceMapGenerator;
<span class="hljs-keyword">var</span> hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
<span class="hljs-keyword">var</span> util = exports;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUnionOfKeys</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> result = {};
  <span class="hljs-keyword">var</span> argc = <span class="hljs-built_in">arguments</span>.length;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; argc; ++i) {
    <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">arguments</span>[i]);
    <span class="hljs-keyword">var</span> keyCount = keys.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; keyCount; ++j) {
      result[keys[j]] = <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-keyword">return</span> result;
}
util.getUnionOfKeys = getUnionOfKeys;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">comparePos</span>(<span class="hljs-params">pos1, pos2</span>) </span>{
  <span class="hljs-keyword">return</span> (pos1.line - pos2.line) || (pos1.column - pos2.column);
}
util.comparePos = comparePos;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyPos</span>(<span class="hljs-params">pos</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">line</span>: pos.line,
    <span class="hljs-attr">column</span>: pos.column
  };
}
util.copyPos = copyPos;

util.composeSourceMaps = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">formerMap, latterMap</span>) </span>{
  <span class="hljs-keyword">if</span> (formerMap) {
    <span class="hljs-keyword">if</span> (!latterMap) {
      <span class="hljs-keyword">return</span> formerMap;
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> latterMap || <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> smcFormer = <span class="hljs-keyword">new</span> SourceMapConsumer(formerMap);
  <span class="hljs-keyword">var</span> smcLatter = <span class="hljs-keyword">new</span> SourceMapConsumer(latterMap);
  <span class="hljs-keyword">var</span> smg = <span class="hljs-keyword">new</span> SourceMapGenerator({
    <span class="hljs-attr">file</span>: latterMap.file,
    <span class="hljs-attr">sourceRoot</span>: latterMap.sourceRoot
  });

  <span class="hljs-keyword">var</span> sourcesToContents = {};

  smcLatter.eachMapping(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mapping</span>) </span>{
    <span class="hljs-keyword">var</span> origPos = smcFormer.originalPositionFor({
      <span class="hljs-attr">line</span>: mapping.originalLine,
      <span class="hljs-attr">column</span>: mapping.originalColumn
    });

    <span class="hljs-keyword">var</span> sourceName = origPos.source;
    <span class="hljs-keyword">if</span> (sourceName === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span>;
    }

    smg.addMapping({
      <span class="hljs-attr">source</span>: sourceName,
      <span class="hljs-attr">original</span>: copyPos(origPos),
      <span class="hljs-attr">generated</span>: {
        <span class="hljs-attr">line</span>: mapping.generatedLine,
        <span class="hljs-attr">column</span>: mapping.generatedColumn
      },
      <span class="hljs-attr">name</span>: mapping.name
    });

    <span class="hljs-keyword">var</span> sourceContent = smcFormer.sourceContentFor(sourceName);
    <span class="hljs-keyword">if</span> (sourceContent &amp;&amp; !hasOwn.call(sourcesToContents, sourceName)) {
      sourcesToContents[sourceName] = sourceContent;
      smg.setSourceContent(sourceName, sourceContent);
    }
  });

  <span class="hljs-keyword">return</span> smg.toJSON();
};

util.getTrueLoc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, lines</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>It's possible that node is newly-created (not parsed by Esprima),
in which case it probably won't have a .loc property (or an
.original property for that matter). That's fine; we'll just
pretty-print it as usual.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (!node.loc) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> result = {
    <span class="hljs-attr">start</span>: node.loc.start,
    <span class="hljs-attr">end</span>: node.loc.end
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">include</span>(<span class="hljs-params">node</span>) </span>{
    expandLoc(result, node.loc);
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>If the node has any comments, their locations might contribute to
the true start/end positions of the node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (node.comments) {
    node.comments.forEach(include);
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>If the node is an export declaration and its .declaration has any
decorators, their locations might contribute to the true start/end
positions of the export declaration node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (util.isExportDeclaration(node) &amp;&amp;
      node.declaration.decorators) {
    node.declaration.decorators.forEach(include);
  }

  <span class="hljs-keyword">if</span> (comparePos(result.start, result.end) &lt; <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Trim leading whitespace.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    result.start = copyPos(result.start);
    lines.skipSpaces(result.start, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);

    <span class="hljs-keyword">if</span> (comparePos(result.start, result.end) &lt; <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Trim trailing whitespace, if the end location is not already the
same as the start location.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      result.end = copyPos(result.end);
      lines.skipSpaces(result.end, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
    }
  }

  <span class="hljs-keyword">return</span> result;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expandLoc</span>(<span class="hljs-params">parentLoc, childLoc</span>) </span>{
  <span class="hljs-keyword">if</span> (parentLoc &amp;&amp; childLoc) {
    <span class="hljs-keyword">if</span> (comparePos(childLoc.start, parentLoc.start) &lt; <span class="hljs-number">0</span>) {
      parentLoc.start = childLoc.start;
    }

    <span class="hljs-keyword">if</span> (comparePos(parentLoc.end, childLoc.end) &lt; <span class="hljs-number">0</span>) {
      parentLoc.end = childLoc.end;
    }
  }
}

util.fixFaultyLocations = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, lines</span>) </span>{
  <span class="hljs-keyword">var</span> loc = node.loc;
  <span class="hljs-keyword">if</span> (loc) {
    <span class="hljs-keyword">if</span> (loc.start.line &lt; <span class="hljs-number">1</span>) {
      loc.start.line = <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">if</span> (loc.end.line &lt; <span class="hljs-number">1</span>) {
      loc.end.line = <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">"TemplateLiteral"</span>) {
    fixTemplateLiteral(node, lines);

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (loc &amp;&amp; node.decorators) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Expand the .loc of the node responsible for printing the decorators
(here, the decorated node) so that it includes node.decorators.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    node.decorators.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">decorator</span>) </span>{
      expandLoc(loc, decorator.loc);
    });

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.declaration &amp;&amp; util.isExportDeclaration(node)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Nullify .loc information for the child declaration so that we never
try to reprint it without also reprinting the export declaration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    node.declaration.loc = <span class="hljs-literal">null</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Expand the .loc of the node responsible for printing the decorators
(here, the export declaration) so that it includes node.decorators.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> decorators = node.declaration.decorators;
    <span class="hljs-keyword">if</span> (decorators) {
      decorators.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">decorator</span>) </span>{
        expandLoc(loc, decorator.loc);
      });
    }

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((n.MethodDefinition &amp;&amp; n.MethodDefinition.check(node)) ||
             (n.Property.check(node) &amp;&amp; (node.method || node.shorthand))) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>If the node is a MethodDefinition or a .method or .shorthand
Property, then the location information stored in
node.value.loc is very likely untrustworthy (just the {body}
part of a method, or nothing in the case of shorthand
properties), so we null out that information to prevent
accidental reuse of bogus source code during reprinting.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    node.value.loc = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (n.FunctionExpression.check(node.value)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>FunctionExpression method values should be anonymous,
because their .id fields are ignored anyway.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      node.value.id = <span class="hljs-literal">null</span>;
    }
  }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixTemplateLiteral</span>(<span class="hljs-params">node, lines</span>) </span>{
  assert.strictEqual(node.type, <span class="hljs-string">"TemplateLiteral"</span>);

  <span class="hljs-keyword">if</span> (node.quasis.length === <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>If there are no quasi elements, then there is nothing to fix.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span>;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>First we need to exclude the opening ` from the .loc of the first
quasi element, in case the parser accidentally decided to include it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> afterLeftBackTickPos = copyPos(node.loc.start);
  assert.strictEqual(lines.charAt(afterLeftBackTickPos), <span class="hljs-string">"`"</span>);
  assert.ok(lines.nextPos(afterLeftBackTickPos));
  <span class="hljs-keyword">var</span> firstQuasi = node.quasis[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">if</span> (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) &lt; <span class="hljs-number">0</span>) {
    firstQuasi.loc.start = afterLeftBackTickPos;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Next we need to exclude the closing ` from the .loc of the last quasi
element, in case the parser accidentally decided to include it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> rightBackTickPos = copyPos(node.loc.end);
  assert.ok(lines.prevPos(rightBackTickPos));
  assert.strictEqual(lines.charAt(rightBackTickPos), <span class="hljs-string">"`"</span>);
  <span class="hljs-keyword">var</span> lastQuasi = node.quasis[node.quasis.length - <span class="hljs-number">1</span>];
  <span class="hljs-keyword">if</span> (comparePos(rightBackTickPos, lastQuasi.loc.end) &lt; <span class="hljs-number">0</span>) {
    lastQuasi.loc.end = rightBackTickPos;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>Now we need to exclude ${ and } characters from the .loc's of all
quasi elements, since some parsers accidentally include them.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  node.expressions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">expr, i</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Rewind from expr.loc.start over any whitespace and the ${ that
precedes the expression. The position of the $ should be the same
as the .loc.end of the preceding quasi element, but some parsers
accidentally include the ${ in the .loc of the quasi element.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> dollarCurlyPos = lines.skipSpaces(expr.loc.start, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">if</span> (lines.prevPos(dollarCurlyPos) &amp;&amp;
        lines.charAt(dollarCurlyPos) === <span class="hljs-string">"{"</span> &amp;&amp;
        lines.prevPos(dollarCurlyPos) &amp;&amp;
        lines.charAt(dollarCurlyPos) === <span class="hljs-string">"$"</span>) {
      <span class="hljs-keyword">var</span> quasiBefore = node.quasis[i];
      <span class="hljs-keyword">if</span> (comparePos(dollarCurlyPos, quasiBefore.loc.end) &lt; <span class="hljs-number">0</span>) {
        quasiBefore.loc.end = dollarCurlyPos;
      }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>Likewise, some parsers accidentally include the } that follows
the expression in the .loc of the following quasi element.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> rightCurlyPos = lines.skipSpaces(expr.loc.end, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">if</span> (lines.charAt(rightCurlyPos) === <span class="hljs-string">"}"</span>) {
      assert.ok(lines.nextPos(rightCurlyPos));
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>Now rightCurlyPos is technically the position just after the }.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> quasiAfter = node.quasis[i + <span class="hljs-number">1</span>];
      <span class="hljs-keyword">if</span> (comparePos(quasiAfter.loc.start, rightCurlyPos) &lt; <span class="hljs-number">0</span>) {
        quasiAfter.loc.start = rightCurlyPos;
      }
    }
  });
}

util.isExportDeclaration = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (node) <span class="hljs-keyword">switch</span> (node.type) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportDeclaration"</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportDefaultDeclaration"</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportDefaultSpecifier"</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">"DeclareExportDeclaration"</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportNamedDeclaration"</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">"ExportAllDeclaration"</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};

util.getParentExportDeclaration = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>{
  <span class="hljs-keyword">var</span> parentNode = path.getParentNode();
  <span class="hljs-keyword">if</span> (path.getName() === <span class="hljs-string">"declaration"</span> &amp;&amp;
      util.isExportDeclaration(parentNode)) {
    <span class="hljs-keyword">return</span> parentNode;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
