<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../doc-style.css" />
  <script src="../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../";
    var thisFile = "node_modules/serialport/node_modules/ast-types/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#ast-types">AST Types</a>
      </div>

      <div class="heading h2">
        <a href="#installation">Installation</a>
      </div>

      <div class="heading h2">
        <a href="#basic-usage">Basic Usage</a>
      </div>

      <div class="heading h2">
        <a href="#ast-traversal">AST Traversal</a>
      </div>

      <div class="heading h2">
        <a href="#nodepath">NodePath</a>
      </div>

      <div class="heading h2">
        <a href="#scope">Scope</a>
      </div>

      <div class="heading h2">
        <a href="#custom-ast-node-types">Custom AST Node Types</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="ast-types">
  <h1>
    <a href="#ast-types" name="ast-types" class="pilcrow"></a>
AST Types
  </h1>
</div>
<p>This module provides an efficient, modular,
<a href="https://github.com/ariya/esprima">Esprima</a>-compatible implementation of
the <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax
tree</a> type hierarchy
pioneered by the <a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">Mozilla Parser
API</a>.</p>
<p><a href="https://travis-ci.org/benjamn/ast-types"><img src="https://travis-ci.org/benjamn/ast-types.png?branch=master" alt="Build Status"></a></p>
<div class="pilwrap" id="installation">
  <h2>
    <a href="#installation" name="installation" class="pilcrow"></a>
Installation
  </h2>
</div>
<p>From NPM:</p>
<pre><code>npm install ast-types
</code></pre>
<p>From GitHub:</p>
<pre><code>cd path/to/node_modules
git clone git://github.com/benjamn/ast-types.git
cd ast-types
npm install .
</code></pre>
<div class="pilwrap" id="basic-usage">
  <h2>
    <a href="#basic-usage" name="basic-usage" class="pilcrow"></a>
Basic Usage
  </h2>
</div>
<pre><code class="js"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">"assert"</span>);
<span class="hljs-keyword">var</span> n = <span class="hljs-built_in">require</span>(<span class="hljs-string">"ast-types"</span>).namedTypes;
<span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">"ast-types"</span>).builders;

<span class="hljs-keyword">var</span> fooId = b.identifier(<span class="hljs-string">"foo"</span>);
<span class="hljs-keyword">var</span> ifFoo = b.ifStatement(fooId, b.blockStatement([
    b.expressionStatement(b.callExpression(fooId, []))
]));

assert.ok(n.IfStatement.check(ifFoo));
assert.ok(n.Statement.check(ifFoo));
assert.ok(n.Node.check(ifFoo));

assert.ok(n.BlockStatement.check(ifFoo.consequent));
assert.strictEqual(
    ifFoo.consequent.body[<span class="hljs-number">0</span>].expression.arguments.length,
    <span class="hljs-number">0</span>);

assert.strictEqual(ifFoo.test, fooId);
assert.ok(n.Expression.check(ifFoo.test));
assert.ok(n.Identifier.check(ifFoo.test));
assert.ok(!n.Statement.check(ifFoo.test));
</code></pre>
<div class="pilwrap" id="ast-traversal">
  <h2>
    <a href="#ast-traversal" name="ast-traversal" class="pilcrow"></a>
AST Traversal
  </h2>
</div>
<p>Because it understands the AST type system so thoroughly, this library
is able to provide excellent node iteration and traversal mechanisms.</p>
<p>If you want complete control over the traversal, and all you need is a way
of enumerating the known fields of your AST nodes and getting their
values, you may be interested in the primitives <code>getFieldNames</code> and
<code>getFieldValue</code>:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"ast-types"</span>);
<span class="hljs-keyword">var</span> partialFunExpr = { <span class="hljs-attr">type</span>: <span class="hljs-string">"FunctionExpression"</span> };

<span class="hljs-comment">// Even though partialFunExpr doesn't actually contain all the fields that</span>
<span class="hljs-comment">// are expected for a FunctionExpression, types.getFieldNames knows:</span>
<span class="hljs-built_in">console</span>.log(types.getFieldNames(partialFunExpr));
<span class="hljs-comment">// [ 'type', 'id', 'params', 'body', 'generator', 'expression',</span>
<span class="hljs-comment">//   'defaults', 'rest', 'async' ]</span>

<span class="hljs-comment">// For fields that have default values, types.getFieldValue will return</span>
<span class="hljs-comment">// the default if the field is not actually defined.</span>
<span class="hljs-built_in">console</span>.log(types.getFieldValue(partialFunExpr, <span class="hljs-string">"generator"</span>));
<span class="hljs-comment">// false</span>
</code></pre>
<p>Two more low-level helper functions, <code>eachField</code> and <code>someField</code>, are
defined in terms of <code>getFieldNames</code> and <code>getFieldValue</code>:</p>
<pre><code class="js"><span class="hljs-comment">// Iterate over all defined fields of an object, including those missing</span>
<span class="hljs-comment">// or undefined, passing each field name and effective value (as returned</span>
<span class="hljs-comment">// by getFieldValue) to the callback. If the object has no corresponding</span>
<span class="hljs-comment">// Def, the callback will never be called.</span>
exports.eachField = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">object, callback, context</span>) </span>{
    getFieldNames(object).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        callback.call(<span class="hljs-keyword">this</span>, name, getFieldValue(object, name));
    }, context);
};

<span class="hljs-comment">// Similar to eachField, except that iteration stops as soon as the</span>
<span class="hljs-comment">// callback returns a truthy value. Like Array.prototype.some, the final</span>
<span class="hljs-comment">// result is either true or false to indicates whether the callback</span>
<span class="hljs-comment">// returned true for any element or not.</span>
exports.someField = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">object, callback, context</span>) </span>{
    <span class="hljs-keyword">return</span> getFieldNames(object).some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> callback.call(<span class="hljs-keyword">this</span>, name, getFieldValue(object, name));
    }, context);
};
</code></pre>
<p>So here's how you might make a copy of an AST node:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> copy = {};
<span class="hljs-built_in">require</span>(<span class="hljs-string">"ast-types"</span>).eachField(node, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, value</span>) </span>{
    <span class="hljs-comment">// Note that undefined fields will be visited too, according to</span>
    <span class="hljs-comment">// the rules associated with node.type, and default field values</span>
    <span class="hljs-comment">// will be substituted if appropriate.</span>
    copy[name] = value;
})
</code></pre>
<p>But that's not all! You can also easily visit entire syntax trees using
the powerful <code>types.visit</code> abstraction.</p>
<p>Here's a trivial example of how you might assert that <code>arguments.callee</code>
is never used in <code>ast</code>:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">"assert"</span>);
<span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"ast-types"</span>);
<span class="hljs-keyword">var</span> n = types.namedTypes;

types.visit(ast, {
    <span class="hljs-comment">// This method will be called for any node with .type "MemberExpression":</span>
    visitMemberExpression: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
        <span class="hljs-comment">// Visitor methods receive a single argument, a NodePath object</span>
        <span class="hljs-comment">// wrapping the node of interest.</span>
        <span class="hljs-keyword">var</span> node = path.node;

        <span class="hljs-keyword">if</span> (n.Identifier.check(node.object) &amp;&amp;
            node.object.name === <span class="hljs-string">"arguments"</span> &amp;&amp;
            n.Identifier.check(node.property)) {
            assert.notStrictEqual(node.property.name, <span class="hljs-string">"callee"</span>);
        }

        <span class="hljs-comment">// It's your responsibility to call this.traverse with some</span>
        <span class="hljs-comment">// NodePath object (usually the one passed into the visitor</span>
        <span class="hljs-comment">// method) before the visitor method returns, or return false to</span>
        <span class="hljs-comment">// indicate that the traversal need not continue any further down</span>
        <span class="hljs-comment">// this subtree.</span>
        <span class="hljs-keyword">this</span>.traverse(path);
    }
});
</code></pre>
<p>Here's a slightly more involved example of transforming <code>...rest</code>
parameters into browser-runnable ES5 JavaScript:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> b = types.builders;

<span class="hljs-comment">// Reuse the same AST structure for Array.prototype.slice.call.</span>
<span class="hljs-keyword">var</span> sliceExpr = b.memberExpression(
    b.memberExpression(
        b.memberExpression(
            b.identifier(<span class="hljs-string">"Array"</span>),
            b.identifier(<span class="hljs-string">"prototype"</span>),
            <span class="hljs-literal">false</span>
        ),
        b.identifier(<span class="hljs-string">"slice"</span>),
        <span class="hljs-literal">false</span>
    ),
    b.identifier(<span class="hljs-string">"call"</span>),
    <span class="hljs-literal">false</span>
);

types.visit(ast, {
    <span class="hljs-comment">// This method will be called for any node whose type is a subtype of</span>
    <span class="hljs-comment">// Function (e.g., FunctionDeclaration, FunctionExpression, and</span>
    <span class="hljs-comment">// ArrowFunctionExpression). Note that types.visit precomputes a</span>
    <span class="hljs-comment">// lookup table from every known type to the appropriate visitor</span>
    <span class="hljs-comment">// method to call for nodes of that type, so the dispatch takes</span>
    <span class="hljs-comment">// constant time.</span>
    visitFunction: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
        <span class="hljs-comment">// Visitor methods receive a single argument, a NodePath object</span>
        <span class="hljs-comment">// wrapping the node of interest.</span>
        <span class="hljs-keyword">var</span> node = path.node;

        <span class="hljs-comment">// It's your responsibility to call this.traverse with some</span>
        <span class="hljs-comment">// NodePath object (usually the one passed into the visitor</span>
        <span class="hljs-comment">// method) before the visitor method returns, or return false to</span>
        <span class="hljs-comment">// indicate that the traversal need not continue any further down</span>
        <span class="hljs-comment">// this subtree. An assertion will fail if you forget, which is</span>
        <span class="hljs-comment">// awesome, because it means you will never again make the</span>
        <span class="hljs-comment">// disastrous mistake of forgetting to traverse a subtree. Also</span>
        <span class="hljs-comment">// cool: because you can call this method at any point in the</span>
        <span class="hljs-comment">// visitor method, it's up to you whether your traversal is</span>
        <span class="hljs-comment">// pre-order, post-order, or both!</span>
        <span class="hljs-keyword">this</span>.traverse(path);

        <span class="hljs-comment">// This traversal is only concerned with Function nodes that have</span>
        <span class="hljs-comment">// rest parameters.</span>
        <span class="hljs-keyword">if</span> (!node.rest) {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// For the purposes of this example, we won't worry about functions</span>
        <span class="hljs-comment">// with Expression bodies.</span>
        n.BlockStatement.assert(node.body);

        <span class="hljs-comment">// Use types.builders to build a variable declaration of the form</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">//   var rest = Array.prototype.slice.call(arguments, n);</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// where `rest` is the name of the rest parameter, and `n` is a</span>
        <span class="hljs-comment">// numeric literal specifying the number of named parameters the</span>
        <span class="hljs-comment">// function takes.</span>
        <span class="hljs-keyword">var</span> restVarDecl = b.variableDeclaration(<span class="hljs-string">"var"</span>, [
            b.variableDeclarator(
                node.rest,
                b.callExpression(sliceExpr, [
                    b.identifier(<span class="hljs-string">"arguments"</span>),
                    b.literal(node.params.length)
                ])
            )
        ]);

        <span class="hljs-comment">// Similar to doing node.body.body.unshift(restVarDecl), except</span>
        <span class="hljs-comment">// that the other NodePath objects wrapping body statements will</span>
        <span class="hljs-comment">// have their indexes updated to accommodate the new statement.</span>
        path.get(<span class="hljs-string">"body"</span>, <span class="hljs-string">"body"</span>).unshift(restVarDecl);

        <span class="hljs-comment">// Nullify node.rest now that we have simulated the behavior of</span>
        <span class="hljs-comment">// the rest parameter using ordinary JavaScript.</span>
        path.get(<span class="hljs-string">"rest"</span>).replace(<span class="hljs-literal">null</span>);

        <span class="hljs-comment">// There's nothing wrong with doing node.rest = null, but I wanted</span>
        <span class="hljs-comment">// to point out that the above statement has the same effect.</span>
        assert.strictEqual(node.rest, <span class="hljs-literal">null</span>);
    }
});
</code></pre>
<p>Here's how you might use <code>types.visit</code> to implement a function that
determines if a given function node refers to <code>this</code>:</p>
<pre><code class="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">usesThis</span>(<span class="hljs-params">funcNode</span>) </span>{
    n.Function.assert(funcNode);
    <span class="hljs-keyword">var</span> result = <span class="hljs-literal">false</span>;

    types.visit(funcNode, {
        <span class="hljs-attr">visitThisExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
            result = <span class="hljs-literal">true</span>;

            <span class="hljs-comment">// The quickest way to terminate the traversal is to call</span>
            <span class="hljs-comment">// this.abort(), which throws a special exception (instanceof</span>
            <span class="hljs-comment">// this.AbortRequest) that will be caught in the top-level</span>
            <span class="hljs-comment">// types.visit method, so you don't have to worry about</span>
            <span class="hljs-comment">// catching the exception yourself.</span>
            <span class="hljs-keyword">this</span>.abort();
        },

        <span class="hljs-attr">visitFunction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
            <span class="hljs-comment">// ThisExpression nodes in nested scopes don't count as `this`</span>
            <span class="hljs-comment">// references for the original function node, so we can safely</span>
            <span class="hljs-comment">// avoid traversing this subtree.</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        },

        <span class="hljs-attr">visitCallExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
            <span class="hljs-keyword">var</span> node = path.node;

            <span class="hljs-comment">// If the function contains CallExpression nodes involving</span>
            <span class="hljs-comment">// super, those expressions will implicitly depend on the</span>
            <span class="hljs-comment">// value of `this`, even though they do not explicitly contain</span>
            <span class="hljs-comment">// any ThisExpression nodes.</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isSuperCallExpression(node)) {
                result = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">this</span>.abort(); <span class="hljs-comment">// Throws AbortRequest exception.</span>
            }

            <span class="hljs-keyword">this</span>.traverse(path);
        },

        <span class="hljs-comment">// Yes, you can define arbitrary helper methods.</span>
        isSuperCallExpression: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callExpr</span>) </span>{
            n.CallExpression.assert(callExpr);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isSuperIdentifier(callExpr.callee)
                || <span class="hljs-keyword">this</span>.isSuperMemberExpression(callExpr.callee);
        },

        <span class="hljs-comment">// And even helper helper methods!</span>
        isSuperIdentifier: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">return</span> n.Identifier.check(node.callee)
                &amp;&amp; node.callee.name === <span class="hljs-string">"super"</span>;
        },

        <span class="hljs-attr">isSuperMemberExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">return</span> n.MemberExpression.check(node.callee)
                &amp;&amp; n.Identifier.check(node.callee.object)
                &amp;&amp; node.callee.object.name === <span class="hljs-string">"super"</span>;
        }
    });

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>As you might guess, when an <code>AbortRequest</code> is thrown from a subtree, the
exception will propagate from the corresponding calls to <code>this.traverse</code>
in the ancestor visitor methods. If you decide you want to cancel the
request, simply catch the exception and call its <code>.cancel()</code> method. The
rest of the subtree beneath the <code>try</code>-<code>catch</code> block will be abandoned, but
the remaining siblings of the ancestor node will still be visited.</p>
<div class="pilwrap" id="nodepath">
  <h2>
    <a href="#nodepath" name="nodepath" class="pilcrow"></a>
NodePath
  </h2>
</div>
<p>The <code>NodePath</code> object passed to visitor methods is a wrapper around an AST
node, and it serves to provide access to the chain of ancestor objects
(all the way back to the root of the AST) and scope information.</p>
<p>In general, <code>path.node</code> refers to the wrapped node, <code>path.parent.node</code>
refers to the nearest <code>Node</code> ancestor, <code>path.parent.parent.node</code> to the
grandparent, and so on.</p>
<p>Note that <code>path.node</code> may not be a direct property value of
<code>path.parent.node</code>; for instance, it might be the case that <code>path.node</code> is
an element of an array that is a direct child of the parent node:</p>
<pre><code class="js">path.node === path.parent.node.elements[<span class="hljs-number">3</span>]
</code></pre>
<p>in which case you should know that <code>path.parentPath</code> provides
finer-grained access to the complete path of objects (not just the <code>Node</code>
ones) from the root of the AST:</p>
<pre><code class="js"><span class="hljs-comment">// In reality, path.parent is the grandparent of path:</span>
path.parentPath.parentPath === path.parent

<span class="hljs-comment">// The path.parentPath object wraps the elements array (note that we use</span>
<span class="hljs-comment">// .value because the elements array is not a Node):</span>
path.parentPath.value === path.parent.node.elements

<span class="hljs-comment">// The path.node object is the fourth element in that array:</span>
path.parentPath.value[<span class="hljs-number">3</span>] === path.node

<span class="hljs-comment">// Unlike path.node and path.value, which are synonyms because path.node</span>
<span class="hljs-comment">// is a Node object, path.parentPath.node is distinct from</span>
<span class="hljs-comment">// path.parentPath.value, because the elements array is not a</span>
<span class="hljs-comment">// Node. Instead, path.parentPath.node refers to the closest ancestor</span>
<span class="hljs-comment">// Node, which happens to be the same as path.parent.node:</span>
path.parentPath.node === path.parent.node

<span class="hljs-comment">// The path is named for its index in the elements array:</span>
path.name === <span class="hljs-number">3</span>

<span class="hljs-comment">// Likewise, path.parentPath is named for the property by which</span>
<span class="hljs-comment">// path.parent.node refers to it:</span>
path.parentPath.name === <span class="hljs-string">"elements"</span>

<span class="hljs-comment">// Putting it all together, we can follow the chain of object references</span>
<span class="hljs-comment">// from path.parent.node all the way to path.node by accessing each</span>
<span class="hljs-comment">// property by name:</span>
path.parent.node[path.parentPath.name][path.name] === path.node
</code></pre>
<p>These <code>NodePath</code> objects are created during the traversal without
modifying the AST nodes themselves, so it's not a problem if the same node
appears more than once in the AST (like <code>Array.prototype.slice.call</code> in
the example above), because it will be visited with a distict <code>NodePath</code>
each time it appears.</p>
<p>Child <code>NodePath</code> objects are created lazily, by calling the <code>.get</code> method
of a parent <code>NodePath</code> object:</p>
<pre><code class="js"><span class="hljs-comment">// If a NodePath object for the elements array has never been created</span>
<span class="hljs-comment">// before, it will be created here and cached in the future:</span>
path.get(<span class="hljs-string">"elements"</span>).get(<span class="hljs-number">3</span>).value === path.value.elements[<span class="hljs-number">3</span>]

<span class="hljs-comment">// Alternatively, you can pass multiple property names to .get instead of</span>
<span class="hljs-comment">// chaining multiple .get calls:</span>
path.get(<span class="hljs-string">"elements"</span>, <span class="hljs-number">0</span>).value === path.value.elements[<span class="hljs-number">0</span>]
</code></pre>
<p><code>NodePath</code> objects support a number of useful methods:</p>
<pre><code class="js"><span class="hljs-comment">// Replace one node with another node:</span>
<span class="hljs-keyword">var</span> fifth = path.get(<span class="hljs-string">"elements"</span>, <span class="hljs-number">4</span>);
fifth.replace(newNode);

<span class="hljs-comment">// Now do some stuff that might rearrange the list, and this replacement</span>
<span class="hljs-comment">// remains safe:</span>
fifth.replace(newerNode);

<span class="hljs-comment">// Replace the third element in an array with two new nodes:</span>
path.get(<span class="hljs-string">"elements"</span>, <span class="hljs-number">2</span>).replace(
    b.identifier(<span class="hljs-string">"foo"</span>),
    b.thisExpression()
);

<span class="hljs-comment">// Remove a node and its parent if it would leave a redundant AST node:</span>
<span class="hljs-comment">//e.g. var t = 1, y =2; removing the `t` and `y` declarators results in `var undefined`.</span>
path.prune(); <span class="hljs-comment">//returns the closest parent `NodePath`.</span>

<span class="hljs-comment">// Remove a node from a list of nodes:</span>
path.get(<span class="hljs-string">"elements"</span>, <span class="hljs-number">3</span>).replace();

<span class="hljs-comment">// Add three new nodes to the beginning of a list of nodes:</span>
path.get(<span class="hljs-string">"elements"</span>).unshift(a, b, c);

<span class="hljs-comment">// Remove and return the first node in a list of nodes:</span>
path.get(<span class="hljs-string">"elements"</span>).shift();

<span class="hljs-comment">// Push two new nodes onto the end of a list of nodes:</span>
path.get(<span class="hljs-string">"elements"</span>).push(d, e);

<span class="hljs-comment">// Remove and return the last node in a list of nodes:</span>
path.get(<span class="hljs-string">"elements"</span>).pop();

<span class="hljs-comment">// Insert a new node before/after the seventh node in a list of nodes:</span>
<span class="hljs-keyword">var</span> seventh = path.get(<span class="hljs-string">"elements"</span>, <span class="hljs-number">6</span>);
seventh.insertBefore(newNode);
seventh.insertAfter(newNode);

<span class="hljs-comment">// Insert a new element at index 5 in a list of nodes:</span>
path.get(<span class="hljs-string">"elements"</span>).insertAt(<span class="hljs-number">5</span>, newNode);
</code></pre>
<div class="pilwrap" id="scope">
  <h2>
    <a href="#scope" name="scope" class="pilcrow"></a>
Scope
  </h2>
</div>
<p>The object exposed as <code>path.scope</code> during AST traversals provides
information about variable and function declarations in the scope that
contains <code>path.node</code>. See <a href="lib/scope.js.html">scope.js</a> for its public
interface, which currently includes <code>.isGlobal</code>, <code>.getGlobalScope()</code>,
<code>.depth</code>, <code>.declares(name)</code>, <code>.lookup(name)</code>, and <code>.getBindings()</code>.</p>
<div class="pilwrap" id="custom-ast-node-types">
  <h2>
    <a href="#custom-ast-node-types" name="custom-ast-node-types" class="pilcrow"></a>
Custom AST Node Types
  </h2>
</div>
<p>The <code>ast-types</code> module was designed to be extended. To that end, it
provides a readable, declarative syntax for specifying new AST node types,
based primarily upon the <code>require(&quot;ast-types&quot;).Type.def</code> function:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"ast-types"</span>);
<span class="hljs-keyword">var</span> def = types.Type.def;
<span class="hljs-keyword">var</span> string = types.builtInTypes.string;
<span class="hljs-keyword">var</span> b = types.builders;

<span class="hljs-comment">// Suppose you need a named File type to wrap your Programs.</span>
def(<span class="hljs-string">"File"</span>)
    .bases(<span class="hljs-string">"Node"</span>)
    .build(<span class="hljs-string">"name"</span>, <span class="hljs-string">"program"</span>)
    .field(<span class="hljs-string">"name"</span>, string)
    .field(<span class="hljs-string">"program"</span>, def(<span class="hljs-string">"Program"</span>));

<span class="hljs-comment">// Prevent further modifications to the File type (and any other</span>
<span class="hljs-comment">// types newly introduced by def(...)).</span>
types.finalize();

<span class="hljs-comment">// The b.file builder function is now available. It expects two</span>
<span class="hljs-comment">// arguments, as named by .build("name", "program") above.</span>
<span class="hljs-keyword">var</span> main = b.file(<span class="hljs-string">"main.js"</span>, b.program([
    <span class="hljs-comment">// Pointless program contents included for extra color.</span>
    b.functionDeclaration(b.identifier(<span class="hljs-string">"succ"</span>), [
        b.identifier(<span class="hljs-string">"x"</span>)
    ], b.blockStatement([
        b.returnStatement(
            b.binaryExpression(
                <span class="hljs-string">"+"</span>, b.identifier(<span class="hljs-string">"x"</span>), b.literal(<span class="hljs-number">1</span>)
            )
        )
    ]))
]));

assert.strictEqual(main.name, <span class="hljs-string">"main.js"</span>);
assert.strictEqual(main.program.body[<span class="hljs-number">0</span>].params[<span class="hljs-number">0</span>].name, <span class="hljs-string">"x"</span>);
<span class="hljs-comment">// etc.</span>

<span class="hljs-comment">// If you pass the wrong type of arguments, or fail to pass enough</span>
<span class="hljs-comment">// arguments, an AssertionError will be thrown.</span>

b.file(b.blockStatement([]));
<span class="hljs-comment">// ==&gt; AssertionError: {"body":[],"type":"BlockStatement","loc":null} does not match type string</span>

b.file(<span class="hljs-string">"lib/types.js"</span>, b.thisExpression());
<span class="hljs-comment">// ==&gt; AssertionError: {"type":"ThisExpression","loc":null} does not match type Program</span>
</code></pre>
<p>The <code>def</code> syntax is used to define all the default AST node types found in
<a href="def/core.js.html">core.js</a>,
<a href="def/e4x.js.html">e4x.js</a>,
<a href="def/es6.js.html">es6.js</a>,
<a href="def/es7.js.html">es7.js</a>,
<a href="def/flow.js.html">flow.js</a>, and
<a href="def/jsx.js.html">jsx.js</a>, so you have
no shortage of examples to learn from.</p>
</div>
  </div>
</body>
</html>
