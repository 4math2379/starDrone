<!DOCTYPE html>
<html>
<head>
  <title>path-visitor.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/ast-types/lib/path-visitor.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>path-visitor.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>);
<span class="hljs-keyword">var</span> NodePath = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./node-path"</span>);
<span class="hljs-keyword">var</span> Printable = types.namedTypes.Printable;
<span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
<span class="hljs-keyword">var</span> isObject = types.builtInTypes.object;
<span class="hljs-keyword">var</span> isFunction = types.builtInTypes.function;
<span class="hljs-keyword">var</span> hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
<span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PathVisitor</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> PathVisitor)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
            <span class="hljs-string">"PathVisitor constructor cannot be invoked without 'new'"</span>
        );
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Permanent state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>._reusableContextStack = [];

    <span class="hljs-keyword">this</span>._methodNameTable = computeMethodNameTable(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>._shouldVisitComments =
        hasOwn.call(<span class="hljs-keyword">this</span>._methodNameTable, <span class="hljs-string">"Block"</span>) ||
        hasOwn.call(<span class="hljs-keyword">this</span>._methodNameTable, <span class="hljs-string">"Line"</span>);

    <span class="hljs-keyword">this</span>.Context = makeContextConstructor(<span class="hljs-keyword">this</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>State reset every time PathVisitor.prototype.visit is called.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>._visiting = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>._changeReported = <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeMethodNameTable</span>(<span class="hljs-params">visitor</span>) </span>{
    <span class="hljs-keyword">var</span> typeNames = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> methodName <span class="hljs-keyword">in</span> visitor) {
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^visit[A-Z]/</span>.test(methodName)) {
            typeNames[methodName.slice(<span class="hljs-string">"visit"</span>.length)] = <span class="hljs-literal">true</span>;
        }
    }

    <span class="hljs-keyword">var</span> supertypeTable = types.computeSupertypeLookupTable(typeNames);
    <span class="hljs-keyword">var</span> methodNameTable = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);

    <span class="hljs-keyword">var</span> typeNames = <span class="hljs-built_in">Object</span>.keys(supertypeTable);
    <span class="hljs-keyword">var</span> typeNameCount = typeNames.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; typeNameCount; ++i) {
        <span class="hljs-keyword">var</span> typeName = typeNames[i];
        methodName = <span class="hljs-string">"visit"</span> + supertypeTable[typeName];
        <span class="hljs-keyword">if</span> (isFunction.check(visitor[methodName])) {
            methodNameTable[typeName] = methodName;
        }
    }

    <span class="hljs-keyword">return</span> methodNameTable;
}

PathVisitor.fromMethodsObject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromMethodsObject</span>(<span class="hljs-params">methods</span>) </span>{
    <span class="hljs-keyword">if</span> (methods <span class="hljs-keyword">instanceof</span> PathVisitor) {
        <span class="hljs-keyword">return</span> methods;
    }

    <span class="hljs-keyword">if</span> (!isObject.check(methods)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>An empty visitor?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PathVisitor;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Visitor</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Visitor)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                <span class="hljs-string">"Visitor constructor cannot be invoked without 'new'"</span>
            );
        }
        PathVisitor.call(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-keyword">var</span> Vp = Visitor.prototype = <span class="hljs-built_in">Object</span>.create(PVp);
    Vp.constructor = Visitor;

    extend(Vp, methods);
    extend(Visitor, PathVisitor);

    isFunction.assert(Visitor.fromMethodsObject);
    isFunction.assert(Visitor.visit);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Visitor;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">target, source</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> source) {
        <span class="hljs-keyword">if</span> (hasOwn.call(source, property)) {
            target[property] = source[property];
        }
    }

    <span class="hljs-keyword">return</span> target;
}

PathVisitor.visit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">node, methods</span>) </span>{
    <span class="hljs-keyword">return</span> PathVisitor.fromMethodsObject(methods).visit(node);
};

<span class="hljs-keyword">var</span> PVp = PathVisitor.prototype;

PVp.visit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._visiting) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
            <span class="hljs-string">"Recursively calling visitor.visit(path) resets visitor state. "</span> +
                <span class="hljs-string">"Try this.visit(path) or this.traverse(path) instead."</span>
        );
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Private state that needs to be reset before every traversal.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>._visiting = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>._changeReported = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>._abortRequested = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">var</span> argc = <span class="hljs-built_in">arguments</span>.length;
    <span class="hljs-keyword">var</span> args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(argc)
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; argc; ++i) {
        args[i] = <span class="hljs-built_in">arguments</span>[i];
    }

    <span class="hljs-keyword">if</span> (!(args[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> NodePath)) {
        args[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> NodePath({ <span class="hljs-attr">root</span>: args[<span class="hljs-number">0</span>] }).get(<span class="hljs-string">"root"</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Called with the same arguments as .visit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.reset.apply(<span class="hljs-keyword">this</span>, args);

    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> root = <span class="hljs-keyword">this</span>.visitWithoutReset(args[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">var</span> didNotThrow = <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">this</span>._visiting = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (!didNotThrow &amp;&amp; <span class="hljs-keyword">this</span>._abortRequested) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>If this.visitWithoutReset threw an exception and
this._abortRequested was set to true, return the root of
the AST instead of letting the exception propagate, so that
client code does not have to provide a try-catch block to
intercept the AbortRequest exception.  Other kinds of
exceptions will propagate without being intercepted and
rethrown by a catch block, so their stacks will accurately
reflect the original throwing context.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> args[<span class="hljs-number">0</span>].value;
        }
    }

    <span class="hljs-keyword">return</span> root;
};

PVp.AbortRequest = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AbortRequest</span>(<span class="hljs-params"></span>) </span>{};
PVp.abort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> visitor = <span class="hljs-keyword">this</span>;
    visitor._abortRequested = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> visitor.AbortRequest();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>If you decide to catch this exception and stop it from propagating,
make sure to call its cancel method to avoid silencing other
exceptions that might be thrown later in the traversal.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    request.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        visitor._abortRequested = <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">throw</span> request;
};

PVp.reset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path<span class="hljs-regexp">/*, additional arguments */</span></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Empty stub; may be reassigned or overridden by subclasses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">};

PVp.visitWithoutReset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Since this.Context.prototype === this, there's a chance we
might accidentally call context.visitWithoutReset. If that
happens, re-invoke the method against context.visitor.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.visitor.visitWithoutReset(path);
    }

    <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }

    <span class="hljs-keyword">var</span> value = path.value;

    <span class="hljs-keyword">var</span> methodName = value &amp;&amp;
        <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span> &amp;&amp;
        <span class="hljs-keyword">typeof</span> value.type === <span class="hljs-string">"string"</span> &amp;&amp;
        <span class="hljs-keyword">this</span>._methodNameTable[value.type];

    <span class="hljs-keyword">if</span> (methodName) {
        <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.acquireContext(path);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> context.invokeVisitorMethod(methodName);
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">this</span>.releaseContext(context);
        }

    } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>If there was no visitor method to call, visit the children of
this node generically.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> visitChildren(path, <span class="hljs-keyword">this</span>);
    }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitChildren</span>(<span class="hljs-params">path, visitor</span>) </span>{
    <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">if</span> (!(visitor <span class="hljs-keyword">instanceof</span> PathVisitor)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }

    <span class="hljs-keyword">var</span> value = path.value;

    <span class="hljs-keyword">if</span> (isArray.check(value)) {
        path.each(visitor.visitWithoutReset, visitor);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isObject.check(value)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>No children to visit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> childNames = types.getFieldNames(value);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>The .comments field of the Node type is hidden, so we only
visit it if the visitor defines visitBlock or visitLine, and
value.comments is defined.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (visitor._shouldVisitComments &amp;&amp;
            value.comments &amp;&amp;
            childNames.indexOf(<span class="hljs-string">"comments"</span>) &lt; <span class="hljs-number">0</span>) {
            childNames.push(<span class="hljs-string">"comments"</span>);
        }

        <span class="hljs-keyword">var</span> childCount = childNames.length;
        <span class="hljs-keyword">var</span> childPaths = [];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; childCount; ++i) {
            <span class="hljs-keyword">var</span> childName = childNames[i];
            <span class="hljs-keyword">if</span> (!hasOwn.call(value, childName)) {
                value[childName] = types.getFieldValue(value, childName);
            }
            childPaths.push(path.get(childName));
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; childCount; ++i) {
            visitor.visitWithoutReset(childPaths[i]);
        }
    }

    <span class="hljs-keyword">return</span> path.value;
}

PVp.acquireContext = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._reusableContextStack.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.Context(path);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._reusableContextStack.pop().reset(path);
};

PVp.releaseContext = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>{
    <span class="hljs-keyword">if</span> (!(context <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">this</span>._reusableContextStack.push(context);
    context.currentPath = <span class="hljs-literal">null</span>;
};

PVp.reportChanged = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._changeReported = <span class="hljs-literal">true</span>;
};

PVp.wasChangeReported = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._changeReported;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeContextConstructor</span>(<span class="hljs-params">visitor</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Context</span>(<span class="hljs-params">path</span>) </span>{
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Context)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> PathVisitor)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }
        <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }

        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"visitor"</span>, {
            <span class="hljs-attr">value</span>: visitor,
            <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>
        });

        <span class="hljs-keyword">this</span>.currentPath = path;
        <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">true</span>;

        <span class="hljs-built_in">Object</span>.seal(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-keyword">if</span> (!(visitor <span class="hljs-keyword">instanceof</span> PathVisitor)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Note that the visitor object is the prototype of Context.prototype,
so all visitor methods are inherited by context objects.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> Cp = Context.prototype = <span class="hljs-built_in">Object</span>.create(visitor);

    Cp.constructor = Context;
    extend(Cp, sharedContextProtoMethods);

    <span class="hljs-keyword">return</span> Context;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>Every PathVisitor has a different this.Context constructor and
this.Context.prototype object, but those prototypes can all use the
same reset, invokeVisitorMethod, and traverse function objects.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> sharedContextProtoMethods = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);

sharedContextProtoMethods.reset =
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }

    <span class="hljs-keyword">this</span>.currentPath = path;
    <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

sharedContextProtoMethods.invokeVisitorMethod =
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeVisitorMethod</span>(<span class="hljs-params">methodName</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>.currentPath <span class="hljs-keyword">instanceof</span> NodePath)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }

    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.visitor[methodName].call(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.currentPath);

    <span class="hljs-keyword">if</span> (result === <span class="hljs-literal">false</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Visitor methods return false to indicate that they have handled
their own traversal needs, and we should not complain if
this.needToCallTraverse is still true.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">false</span>;

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">undefined</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>Any other non-undefined value returned from the visitor method
is interpreted as a replacement value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">this</span>.currentPath = <span class="hljs-keyword">this</span>.currentPath.replace(result)[<span class="hljs-number">0</span>];

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needToCallTraverse) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>If this.traverse still hasn't been called, visit the
children of the replacement node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">this</span>.traverse(<span class="hljs-keyword">this</span>.currentPath);
        }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needToCallTraverse !== <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
            <span class="hljs-string">"Must either call this.traverse or return false in "</span> + methodName
        );
    }

    <span class="hljs-keyword">var</span> path = <span class="hljs-keyword">this</span>.currentPath;
    <span class="hljs-keyword">return</span> path &amp;&amp; path.value;
};

sharedContextProtoMethods.traverse =
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">path, newVisitor</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>.currentPath <span class="hljs-keyword">instanceof</span> NodePath)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }

    <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">return</span> visitChildren(path, PathVisitor.fromMethodsObject(
        newVisitor || <span class="hljs-keyword">this</span>.visitor
    ));
};

sharedContextProtoMethods.visit =
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">path, newVisitor</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>.currentPath <span class="hljs-keyword">instanceof</span> NodePath)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }

    <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">return</span> PathVisitor.fromMethodsObject(
        newVisitor || <span class="hljs-keyword">this</span>.visitor
    ).visitWithoutReset(path);
};

sharedContextProtoMethods.reportChanged = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reportChanged</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.visitor.reportChanged();
};

sharedContextProtoMethods.abort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abort</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.visitor.abort();
};

<span class="hljs-built_in">module</span>.exports = PathVisitor;

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
