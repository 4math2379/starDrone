<!DOCTYPE html>
<html>
<head>
  <title>scope.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/ast-types/lib/scope.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>scope.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>);
<span class="hljs-keyword">var</span> Type = types.Type;
<span class="hljs-keyword">var</span> namedTypes = types.namedTypes;
<span class="hljs-keyword">var</span> Node = namedTypes.Node;
<span class="hljs-keyword">var</span> Expression = namedTypes.Expression;
<span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
<span class="hljs-keyword">var</span> hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
<span class="hljs-keyword">var</span> b = types.builders;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Scope</span>(<span class="hljs-params">path, parentScope</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Scope)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Scope constructor cannot be invoked without 'new'"</span>);
    }
    <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">"./node-path"</span>))) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    ScopeType.assert(path.value);

    <span class="hljs-keyword">var</span> depth;

    <span class="hljs-keyword">if</span> (parentScope) {
        <span class="hljs-keyword">if</span> (!(parentScope <span class="hljs-keyword">instanceof</span> Scope)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }
        depth = parentScope.depth + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
        parentScope = <span class="hljs-literal">null</span>;
        depth = <span class="hljs-number">0</span>;
    }

    <span class="hljs-built_in">Object</span>.defineProperties(<span class="hljs-keyword">this</span>, {
        <span class="hljs-attr">path</span>: { <span class="hljs-attr">value</span>: path },
        <span class="hljs-attr">node</span>: { <span class="hljs-attr">value</span>: path.value },
        <span class="hljs-attr">isGlobal</span>: { <span class="hljs-attr">value</span>: !parentScope, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> },
        <span class="hljs-attr">depth</span>: { <span class="hljs-attr">value</span>: depth },
        <span class="hljs-attr">parent</span>: { <span class="hljs-attr">value</span>: parentScope },
        <span class="hljs-attr">bindings</span>: { <span class="hljs-attr">value</span>: {} },
        <span class="hljs-attr">types</span>: { <span class="hljs-attr">value</span>: {} },
    });
}

<span class="hljs-keyword">var</span> scopeTypes = [
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Program nodes introduce global scopes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    namedTypes.Program,

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Function is the supertype of FunctionExpression,
FunctionDeclaration, ArrowExpression, etc.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    namedTypes.Function,

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>In case you didn't know, the caught parameter shadows any variable
of the same name in an outer scope.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    namedTypes.CatchClause
];

<span class="hljs-keyword">var</span> ScopeType = Type.or.apply(Type, scopeTypes);

Scope.isEstablishedBy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> ScopeType.check(node);
};

<span class="hljs-keyword">var</span> Sp = Scope.prototype;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Will be overridden after an instance lazily calls scanScope.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Sp.didScan = <span class="hljs-literal">false</span>;

Sp.declares = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">this</span>.scan();
    <span class="hljs-keyword">return</span> hasOwn.call(<span class="hljs-keyword">this</span>.bindings, name);
};

Sp.declaresType = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">this</span>.scan();
    <span class="hljs-keyword">return</span> hasOwn.call(<span class="hljs-keyword">this</span>.types, name);
};

Sp.declareTemporary = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prefix</span>) </span>{
    <span class="hljs-keyword">if</span> (prefix) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[a-z$_]/i</span>.test(prefix)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }
    } <span class="hljs-keyword">else</span> {
        prefix = <span class="hljs-string">"t$"</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Include this.depth in the name to make sure the name does not
collide with any variables in nested/enclosing scopes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    prefix += <span class="hljs-keyword">this</span>.depth.toString(<span class="hljs-number">36</span>) + <span class="hljs-string">"$"</span>;

    <span class="hljs-keyword">this</span>.scan();

    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.declares(prefix + index)) {
        ++index;
    }

    <span class="hljs-keyword">var</span> name = prefix + index;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bindings[name] = types.builders.identifier(name);
};

Sp.injectTemporary = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">identifier, init</span>) </span>{
    identifier || (identifier = <span class="hljs-keyword">this</span>.declareTemporary());

    <span class="hljs-keyword">var</span> bodyPath = <span class="hljs-keyword">this</span>.path.get(<span class="hljs-string">"body"</span>);
    <span class="hljs-keyword">if</span> (namedTypes.BlockStatement.check(bodyPath.value)) {
        bodyPath = bodyPath.get(<span class="hljs-string">"body"</span>);
    }

    bodyPath.unshift(
        b.variableDeclaration(
            <span class="hljs-string">"var"</span>,
            [b.variableDeclarator(identifier, init || <span class="hljs-literal">null</span>)]
        )
    );

    <span class="hljs-keyword">return</span> identifier;
};

Sp.scan = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">force</span>) </span>{
    <span class="hljs-keyword">if</span> (force || !<span class="hljs-keyword">this</span>.didScan) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.bindings) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Empty out this.bindings, just in cases.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.bindings[name];
        }
        scanScope(<span class="hljs-keyword">this</span>.path, <span class="hljs-keyword">this</span>.bindings, <span class="hljs-keyword">this</span>.types);
        <span class="hljs-keyword">this</span>.didScan = <span class="hljs-literal">true</span>;
    }
};

Sp.getBindings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.scan();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bindings;
};

Sp.getTypes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.scan();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.types;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanScope</span>(<span class="hljs-params">path, bindings, scopeTypes</span>) </span>{
    <span class="hljs-keyword">var</span> node = path.value;
    ScopeType.assert(node);

    <span class="hljs-keyword">if</span> (namedTypes.CatchClause.check(node)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>A catch clause establishes a new scope but the only variable
bound in that scope is the catch parameter. Any other
declarations create bindings in the outer scope.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        addPattern(path.get(<span class="hljs-string">"param"</span>), bindings);

    } <span class="hljs-keyword">else</span> {
        recursiveScanScope(path, bindings, scopeTypes);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursiveScanScope</span>(<span class="hljs-params">path, bindings, scopeTypes</span>) </span>{
    <span class="hljs-keyword">var</span> node = path.value;

    <span class="hljs-keyword">if</span> (path.parent &amp;&amp;
        namedTypes.FunctionExpression.check(path.parent.node) &amp;&amp;
        path.parent.node.id) {
        addPattern(path.parent.get(<span class="hljs-string">"id"</span>), bindings);
    }

    <span class="hljs-keyword">if</span> (!node) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>None of the remaining cases matter if node is falsy.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isArray.check(node)) {
        path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">childPath</span>) </span>{
            recursiveScanChild(childPath, bindings, scopeTypes);
        });

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.Function.check(node)) {
        path.get(<span class="hljs-string">"params"</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">paramPath</span>) </span>{
            addPattern(paramPath, bindings);
        });

        recursiveScanChild(path.get(<span class="hljs-string">"body"</span>), bindings, scopeTypes);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.TypeAlias &amp;&amp; namedTypes.TypeAlias.check(node)) {
        addTypePattern(path.get(<span class="hljs-string">"id"</span>), scopeTypes);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.VariableDeclarator.check(node)) {
        addPattern(path.get(<span class="hljs-string">"id"</span>), bindings);
        recursiveScanChild(path.get(<span class="hljs-string">"init"</span>), bindings, scopeTypes);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">"ImportSpecifier"</span> ||
               node.type === <span class="hljs-string">"ImportNamespaceSpecifier"</span> ||
               node.type === <span class="hljs-string">"ImportDefaultSpecifier"</span>) {
        addPattern(
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Esprima used to use the .name field to refer to the local
binding identifier for ImportSpecifier nodes, but .id for
ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
ESTree/Acorn/ESpree use .local for all three node types.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            path.get(node.local ? <span class="hljs-string">"local"</span> :
                     node.name ? <span class="hljs-string">"name"</span> : <span class="hljs-string">"id"</span>),
            bindings
        );

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Node.check(node) &amp;&amp; !Expression.check(node)) {
        types.eachField(node, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, child</span>) </span>{
            <span class="hljs-keyword">var</span> childPath = path.get(name);
            <span class="hljs-keyword">if</span> (childPath.value !== child) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }
            recursiveScanChild(childPath, bindings, scopeTypes);
        });
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursiveScanChild</span>(<span class="hljs-params">path, bindings, scopeTypes</span>) </span>{
    <span class="hljs-keyword">var</span> node = path.value;

    <span class="hljs-keyword">if</span> (!node || Expression.check(node)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Ignore falsy values and Expressions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.FunctionDeclaration.check(node)) {
        addPattern(path.get(<span class="hljs-string">"id"</span>), bindings);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.ClassDeclaration &amp;&amp;
               namedTypes.ClassDeclaration.check(node)) {
        addPattern(path.get(<span class="hljs-string">"id"</span>), bindings);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScopeType.check(node)) {
        <span class="hljs-keyword">if</span> (namedTypes.CatchClause.check(node)) {
            <span class="hljs-keyword">var</span> catchParamName = node.param.name;
            <span class="hljs-keyword">var</span> hadBinding = hasOwn.call(bindings, catchParamName);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Any declarations that occur inside the catch body that do
not have the same name as the catch parameter should count
as bindings in the outer scope.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            recursiveScanScope(path.get(<span class="hljs-string">"body"</span>), bindings, scopeTypes);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>If a new binding matching the catch parameter name was
created while scanning the catch body, ignore it because it
actually refers to the catch parameter and not the outer
scope that we're currently scanning.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (!hadBinding) {
                <span class="hljs-keyword">delete</span> bindings[catchParamName];
            }
        }

    } <span class="hljs-keyword">else</span> {
        recursiveScanScope(path, bindings, scopeTypes);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addPattern</span>(<span class="hljs-params">patternPath, bindings</span>) </span>{
    <span class="hljs-keyword">var</span> pattern = patternPath.value;
    namedTypes.Pattern.assert(pattern);

    <span class="hljs-keyword">if</span> (namedTypes.Identifier.check(pattern)) {
        <span class="hljs-keyword">if</span> (hasOwn.call(bindings, pattern.name)) {
            bindings[pattern.name].push(patternPath);
        } <span class="hljs-keyword">else</span> {
            bindings[pattern.name] = [patternPath];
        }

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.ObjectPattern &amp;&amp;
               namedTypes.ObjectPattern.check(pattern)) {
        patternPath.get(<span class="hljs-string">'properties'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">propertyPath</span>) </span>{
            <span class="hljs-keyword">var</span> property = propertyPath.value;
            <span class="hljs-keyword">if</span> (namedTypes.Pattern.check(property)) {
                addPattern(propertyPath, bindings);
            } <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (namedTypes.Property.check(property)) {
                addPattern(propertyPath.get(<span class="hljs-string">'value'</span>), bindings);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.SpreadProperty &amp;&amp;
                       namedTypes.SpreadProperty.check(property)) {
                addPattern(propertyPath.get(<span class="hljs-string">'argument'</span>), bindings);
            }
        });

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.ArrayPattern &amp;&amp;
               namedTypes.ArrayPattern.check(pattern)) {
        patternPath.get(<span class="hljs-string">'elements'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elementPath</span>) </span>{
            <span class="hljs-keyword">var</span> element = elementPath.value;
            <span class="hljs-keyword">if</span> (namedTypes.Pattern.check(element)) {
                addPattern(elementPath, bindings);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.SpreadElement &amp;&amp;
                       namedTypes.SpreadElement.check(element)) {
                addPattern(elementPath.get(<span class="hljs-string">"argument"</span>), bindings);
            }
        });

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.PropertyPattern &amp;&amp;
               namedTypes.PropertyPattern.check(pattern)) {
        addPattern(patternPath.get(<span class="hljs-string">'pattern'</span>), bindings);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((namedTypes.SpreadElementPattern &amp;&amp;
                namedTypes.SpreadElementPattern.check(pattern)) ||
               (namedTypes.SpreadPropertyPattern &amp;&amp;
                namedTypes.SpreadPropertyPattern.check(pattern))) {
        addPattern(patternPath.get(<span class="hljs-string">'argument'</span>), bindings);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTypePattern</span>(<span class="hljs-params">patternPath, types</span>) </span>{
    <span class="hljs-keyword">var</span> pattern = patternPath.value;
    namedTypes.Pattern.assert(pattern);

    <span class="hljs-keyword">if</span> (namedTypes.Identifier.check(pattern)) {
        <span class="hljs-keyword">if</span> (hasOwn.call(types, pattern.name)) {
            types[pattern.name].push(patternPath);
        } <span class="hljs-keyword">else</span> {
            types[pattern.name] = [patternPath];
        }

    }
}

Sp.lookup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> scope = <span class="hljs-keyword">this</span>; scope; scope = scope.parent)
        <span class="hljs-keyword">if</span> (scope.declares(name))
            <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">return</span> scope;
};

Sp.lookupType = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> scope = <span class="hljs-keyword">this</span>; scope; scope = scope.parent)
        <span class="hljs-keyword">if</span> (scope.declaresType(name))
            <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">return</span> scope;
};

Sp.getGlobalScope = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> scope = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">while</span> (!scope.isGlobal)
        scope = scope.parent;
    <span class="hljs-keyword">return</span> scope;
};

<span class="hljs-built_in">module</span>.exports = Scope;

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
