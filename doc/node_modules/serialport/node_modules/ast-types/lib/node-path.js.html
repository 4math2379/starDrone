<!DOCTYPE html>
<html>
<head>
  <title>node-path.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/ast-types/lib/node-path.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>node-path.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>);
<span class="hljs-keyword">var</span> n = types.namedTypes;
<span class="hljs-keyword">var</span> b = types.builders;
<span class="hljs-keyword">var</span> isNumber = types.builtInTypes.number;
<span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
<span class="hljs-keyword">var</span> Path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./path"</span>);
<span class="hljs-keyword">var</span> Scope = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./scope"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NodePath</span>(<span class="hljs-params">value, parentPath, name</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> NodePath)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"NodePath constructor cannot be invoked without 'new'"</span>);
    }
    Path.call(<span class="hljs-keyword">this</span>, value, parentPath, name);
}

<span class="hljs-keyword">var</span> NPp = NodePath.prototype = <span class="hljs-built_in">Object</span>.create(Path.prototype, {
    <span class="hljs-attr">constructor</span>: {
        <span class="hljs-attr">value</span>: NodePath,
        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>
    }
});

<span class="hljs-built_in">Object</span>.defineProperties(NPp, {
    <span class="hljs-attr">node</span>: {
        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"node"</span>, {
                <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Enable deletion.</span>
                value: <span class="hljs-keyword">this</span>._computeNode()
            });

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.node;
        }
    },

    <span class="hljs-attr">parent</span>: {
        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"parent"</span>, {
                <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Enable deletion.</span>
                value: <span class="hljs-keyword">this</span>._computeParent()
            });

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parent;
        }
    },

    <span class="hljs-attr">scope</span>: {
        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"scope"</span>, {
                <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Enable deletion.</span>
                value: <span class="hljs-keyword">this</span>._computeScope()
            });

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.scope;
        }
    }
});

NPp.replace = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.node;
    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.parent;
    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.scope;
    <span class="hljs-keyword">return</span> Path.prototype.replace.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
};

NPp.prune = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> remainingNodePath = <span class="hljs-keyword">this</span>.parent;

    <span class="hljs-keyword">this</span>.replace();

    <span class="hljs-keyword">return</span> cleanUpNodesAfterPrune(remainingNodePath);
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>The value of the first ancestor Path whose value is a Node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">NPp._computeNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.value;
    <span class="hljs-keyword">if</span> (n.Node.check(value)) {
        <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-keyword">var</span> pp = <span class="hljs-keyword">this</span>.parentPath;
    <span class="hljs-keyword">return</span> pp &amp;&amp; pp.node || <span class="hljs-literal">null</span>;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>The first ancestor Path whose value is a Node distinct from this.node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">NPp._computeParent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.value;
    <span class="hljs-keyword">var</span> pp = <span class="hljs-keyword">this</span>.parentPath;

    <span class="hljs-keyword">if</span> (!n.Node.check(value)) {
        <span class="hljs-keyword">while</span> (pp &amp;&amp; !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        <span class="hljs-keyword">if</span> (pp) {
            pp = pp.parentPath;
        }
    }

    <span class="hljs-keyword">while</span> (pp &amp;&amp; !n.Node.check(pp.value)) {
        pp = pp.parentPath;
    }

    <span class="hljs-keyword">return</span> pp || <span class="hljs-literal">null</span>;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>The closest enclosing scope that governs this node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">NPp._computeScope = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.value;
    <span class="hljs-keyword">var</span> pp = <span class="hljs-keyword">this</span>.parentPath;
    <span class="hljs-keyword">var</span> scope = pp &amp;&amp; pp.scope;

    <span class="hljs-keyword">if</span> (n.Node.check(value) &amp;&amp;
        Scope.isEstablishedBy(value)) {
        scope = <span class="hljs-keyword">new</span> Scope(<span class="hljs-keyword">this</span>, scope);
    }

    <span class="hljs-keyword">return</span> scope || <span class="hljs-literal">null</span>;
};

NPp.getValueProperty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> types.getFieldValue(<span class="hljs-keyword">this</span>.value, name);
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<div class="dox">
<div class="summary">
<p>Determine whether this.node needs to be wrapped in parentheses in order
for a parser to reproduce the same local AST structure.</p>
</div>
<div class="body">
<p>For instance, in the expression <code>(1 + 2) * 3</code>, the BinaryExpression
whose operator is &quot;+&quot; needs parentheses, because <code>1 + 2 * 3</code> would
parse differently.</p>
<p>If assumeExpressionContext === true, we don't worry about edge cases
like an anonymous FunctionExpression appearing lexically first in its
enclosing statement and thus needing parentheses to avoid being parsed
as a FunctionDeclaration with a missing name.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">NPp.needsParens = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">assumeExpressionContext</span>) </span>{
    <span class="hljs-keyword">var</span> pp = <span class="hljs-keyword">this</span>.parentPath;
    <span class="hljs-keyword">if</span> (!pp) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.value;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Only expressions need parentheses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!n.Expression.check(node)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Identifiers never need parentheses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">"Identifier"</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">while</span> (!n.Node.check(pp.value)) {
        pp = pp.parentPath;
        <span class="hljs-keyword">if</span> (!pp) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-keyword">var</span> parent = pp.value;

    <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
        <span class="hljs-keyword">return</span> parent.type === <span class="hljs-string">"MemberExpression"</span>
            &amp;&amp; <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"object"</span>
            &amp;&amp; parent.object === node;

    <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
        <span class="hljs-keyword">switch</span> (parent.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"CallExpression"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"callee"</span>
                &amp;&amp; parent.callee === node;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"object"</span>
                &amp;&amp; parent.object === node;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
            <span class="hljs-keyword">var</span> po = parent.operator;
            <span class="hljs-keyword">var</span> pp = PRECEDENCE[po];
            <span class="hljs-keyword">var</span> no = node.operator;
            <span class="hljs-keyword">var</span> np = PRECEDENCE[no];

            <span class="hljs-keyword">if</span> (pp &gt; np) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">if</span> (pp === np &amp;&amp; <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"right"</span>) {
                <span class="hljs-keyword">if</span> (parent.right !== node) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

    <span class="hljs-keyword">case</span> <span class="hljs-string">"SequenceExpression"</span>:
        <span class="hljs-keyword">switch</span> (parent.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"ForStatement"</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Although parentheses wouldn't hurt around sequence
expressions in the head of for loops, traditional style
dictates that e.g. i++, j++ should not be wrapped with
parentheses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"ExpressionStatement"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name !== <span class="hljs-string">"expression"</span>;

        <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Otherwise err on the side of overparenthesization, adding
explicit exceptions above if this proves overzealous.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

    <span class="hljs-keyword">case</span> <span class="hljs-string">"YieldExpression"</span>:
        <span class="hljs-keyword">switch</span> (parent.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"CallExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"NewExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"ConditionalExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"YieldExpression"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

    <span class="hljs-keyword">case</span> <span class="hljs-string">"Literal"</span>:
        <span class="hljs-keyword">return</span> parent.type === <span class="hljs-string">"MemberExpression"</span>
            &amp;&amp; isNumber.check(node.value)
            &amp;&amp; <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"object"</span>
            &amp;&amp; parent.object === node;

    <span class="hljs-keyword">case</span> <span class="hljs-string">"AssignmentExpression"</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">"ConditionalExpression"</span>:
        <span class="hljs-keyword">switch</span> (parent.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"CallExpression"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"callee"</span>
                &amp;&amp; parent.callee === node;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"ConditionalExpression"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"test"</span>
                &amp;&amp; parent.test === node;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"object"</span>
                &amp;&amp; parent.object === node;

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">if</span> (parent.type === <span class="hljs-string">"NewExpression"</span> &amp;&amp;
            <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"callee"</span> &amp;&amp;
            parent.callee === node) {
            <span class="hljs-keyword">return</span> containsCallExpression(node);
        }
    }

    <span class="hljs-keyword">if</span> (assumeExpressionContext !== <span class="hljs-literal">true</span> &amp;&amp;
        !<span class="hljs-keyword">this</span>.canBeFirstInStatement() &amp;&amp;
        <span class="hljs-keyword">this</span>.firstInStatement())
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBinary</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> n.BinaryExpression.check(node)
        || n.LogicalExpression.check(node);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnaryLike</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> n.UnaryExpression.check(node)
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>I considered making SpreadElement and SpreadProperty subtypes
of UnaryExpression, but they're not really Expression nodes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        || (n.SpreadElement &amp;&amp; n.SpreadElement.check(node))
        || (n.SpreadProperty &amp;&amp; n.SpreadProperty.check(node));
}

<span class="hljs-keyword">var</span> PRECEDENCE = {};
[[<span class="hljs-string">"||"</span>],
 [<span class="hljs-string">"&amp;&amp;"</span>],
 [<span class="hljs-string">"|"</span>],
 [<span class="hljs-string">"^"</span>],
 [<span class="hljs-string">"&amp;"</span>],
 [<span class="hljs-string">"=="</span>, <span class="hljs-string">"==="</span>, <span class="hljs-string">"!="</span>, <span class="hljs-string">"!=="</span>],
 [<span class="hljs-string">"&lt;"</span>, <span class="hljs-string">"&gt;"</span>, <span class="hljs-string">"&lt;="</span>, <span class="hljs-string">"&gt;="</span>, <span class="hljs-string">"in"</span>, <span class="hljs-string">"instanceof"</span>],
 [<span class="hljs-string">"&gt;&gt;"</span>, <span class="hljs-string">"&lt;&lt;"</span>, <span class="hljs-string">"&gt;&gt;&gt;"</span>],
 [<span class="hljs-string">"+"</span>, <span class="hljs-string">"-"</span>],
 [<span class="hljs-string">"*"</span>, <span class="hljs-string">"/"</span>, <span class="hljs-string">"%"</span>]
].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tier, i</span>) </span>{
    tier.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">op</span>) </span>{
        PRECEDENCE[op] = i;
    });
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">containsCallExpression</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (n.CallExpression.check(node)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (isArray.check(node)) {
        <span class="hljs-keyword">return</span> node.some(containsCallExpression);
    }

    <span class="hljs-keyword">if</span> (n.Node.check(node)) {
        <span class="hljs-keyword">return</span> types.someField(node, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, child</span>) </span>{
            <span class="hljs-keyword">return</span> containsCallExpression(child);
        });
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

NPp.canBeFirstInStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.node;
    <span class="hljs-keyword">return</span> !n.FunctionExpression.check(node)
        &amp;&amp; !n.ObjectExpression.check(node);
};

NPp.firstInStatement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> firstInStatement(<span class="hljs-keyword">this</span>);
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">firstInStatement</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> node, parent; path.parent; path = path.parent) {
        node = path.node;
        parent = path.parent.node;

        <span class="hljs-keyword">if</span> (n.BlockStatement.check(parent) &amp;&amp;
            path.parent.name === <span class="hljs-string">"body"</span> &amp;&amp;
            path.name === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (parent.body[<span class="hljs-number">0</span>] !== node) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (n.ExpressionStatement.check(parent) &amp;&amp;
            path.name === <span class="hljs-string">"expression"</span>) {
            <span class="hljs-keyword">if</span> (parent.expression !== node) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (n.SequenceExpression.check(parent) &amp;&amp;
            path.parent.name === <span class="hljs-string">"expressions"</span> &amp;&amp;
            path.name === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (parent.expressions[<span class="hljs-number">0</span>] !== node) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
            }
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (n.CallExpression.check(parent) &amp;&amp;
            path.name === <span class="hljs-string">"callee"</span>) {
            <span class="hljs-keyword">if</span> (parent.callee !== node) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
            }
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (n.MemberExpression.check(parent) &amp;&amp;
            path.name === <span class="hljs-string">"object"</span>) {
            <span class="hljs-keyword">if</span> (parent.object !== node) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
            }
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (n.ConditionalExpression.check(parent) &amp;&amp;
            path.name === <span class="hljs-string">"test"</span>) {
            <span class="hljs-keyword">if</span> (parent.test !== node) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
            }
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (isBinary(parent) &amp;&amp;
            path.name === <span class="hljs-string">"left"</span>) {
            <span class="hljs-keyword">if</span> (parent.left !== node) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
            }
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (n.UnaryExpression.check(parent) &amp;&amp;
            !parent.prefix &amp;&amp;
            path.name === <span class="hljs-string">"argument"</span>) {
            <span class="hljs-keyword">if</span> (parent.argument !== node) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
            }
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<div class="dox">
<div class="summary">
<p>Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpNodesAfterPrune</span>(<span class="hljs-params">remainingNodePath</span>) </span>{
    <span class="hljs-keyword">if</span> (n.VariableDeclaration.check(remainingNodePath.node)) {
        <span class="hljs-keyword">var</span> declarations = remainingNodePath.get(<span class="hljs-string">'declarations'</span>).value;
        <span class="hljs-keyword">if</span> (!declarations || declarations.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> remainingNodePath.prune();
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.ExpressionStatement.check(remainingNodePath.node)) {
        <span class="hljs-keyword">if</span> (!remainingNodePath.get(<span class="hljs-string">'expression'</span>).value) {
            <span class="hljs-keyword">return</span> remainingNodePath.prune();
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.IfStatement.check(remainingNodePath.node)) {
        cleanUpIfStatementAfterPrune(remainingNodePath);
    }

    <span class="hljs-keyword">return</span> remainingNodePath;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpIfStatementAfterPrune</span>(<span class="hljs-params">ifStatement</span>) </span>{
    <span class="hljs-keyword">var</span> testExpression = ifStatement.get(<span class="hljs-string">'test'</span>).value;
    <span class="hljs-keyword">var</span> alternate = ifStatement.get(<span class="hljs-string">'alternate'</span>).value;
    <span class="hljs-keyword">var</span> consequent = ifStatement.get(<span class="hljs-string">'consequent'</span>).value;

    <span class="hljs-keyword">if</span> (!consequent &amp;&amp; !alternate) {
        <span class="hljs-keyword">var</span> testExpressionStatement = b.expressionStatement(testExpression);

        ifStatement.replace(testExpressionStatement);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!consequent &amp;&amp; alternate) {
        <span class="hljs-keyword">var</span> negatedTestExpression = b.unaryExpression(<span class="hljs-string">'!'</span>, testExpression, <span class="hljs-literal">true</span>);

        <span class="hljs-keyword">if</span> (n.UnaryExpression.check(testExpression) &amp;&amp; testExpression.operator === <span class="hljs-string">'!'</span>) {
            negatedTestExpression = testExpression.argument;
        }

        ifStatement.get(<span class="hljs-string">"test"</span>).replace(negatedTestExpression);
        ifStatement.get(<span class="hljs-string">"consequent"</span>).replace(alternate);
        ifStatement.get(<span class="hljs-string">"alternate"</span>).replace();
    }
}

<span class="hljs-built_in">module</span>.exports = NodePath;

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
