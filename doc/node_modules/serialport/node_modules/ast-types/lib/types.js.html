<!DOCTYPE html>
<html>
<head>
  <title>types.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../doc-style.css" />
  <script src="../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../";
    var thisFile = "node_modules/serialport/node_modules/ast-types/lib/types.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>types.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> Ap = <span class="hljs-built_in">Array</span>.prototype;
<span class="hljs-keyword">var</span> slice = Ap.slice;
<span class="hljs-keyword">var</span> map = Ap.map;
<span class="hljs-keyword">var</span> each = Ap.forEach;
<span class="hljs-keyword">var</span> Op = <span class="hljs-built_in">Object</span>.prototype;
<span class="hljs-keyword">var</span> objToStr = Op.toString;
<span class="hljs-keyword">var</span> funObjStr = objToStr.call(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{});
<span class="hljs-keyword">var</span> strObjStr = objToStr.call(<span class="hljs-string">""</span>);
<span class="hljs-keyword">var</span> hasOwn = Op.hasOwnProperty;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>A type is an object with a .check method that takes a value and returns
true or false according to whether the value matches the type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Type</span>(<span class="hljs-params">check, name</span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">if</span> (!(self <span class="hljs-keyword">instanceof</span> Type)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Type constructor cannot be invoked without 'new'"</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Unfortunately we can't elegantly reuse isFunction and isString,
here, because this code is executed while defining those types.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (objToStr.call(check) !== funObjStr) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(check + <span class="hljs-string">" is not a function"</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>The <code>name</code> parameter can be either a function or a string.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> nameObjStr = objToStr.call(name);
    <span class="hljs-keyword">if</span> (!(nameObjStr === funObjStr ||
          nameObjStr === strObjStr)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(name + <span class="hljs-string">" is neither a function nor a string"</span>);
    }

    <span class="hljs-built_in">Object</span>.defineProperties(self, {
        <span class="hljs-attr">name</span>: { <span class="hljs-attr">value</span>: name },
        <span class="hljs-attr">check</span>: {
            <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, deep</span>) </span>{
                <span class="hljs-keyword">var</span> result = check.call(self, value, deep);
                <span class="hljs-keyword">if</span> (!result &amp;&amp; deep &amp;&amp; objToStr.call(deep) === funObjStr)
                    deep(self, value);
                <span class="hljs-keyword">return</span> result;
            }
        }
    });
}

<span class="hljs-keyword">var</span> Tp = Type.prototype;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Throughout this file we use Object.defineProperty to prevent
redefinition of exported properties.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.Type = Type;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Like .check, except that failure triggers an AssertionError.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Tp.assert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, deep</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.check(value, deep)) {
        <span class="hljs-keyword">var</span> str = shallowStringify(value);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(str + <span class="hljs-string">" does not match type "</span> + <span class="hljs-keyword">this</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowStringify</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">if</span> (isObject.check(value))
        <span class="hljs-keyword">return</span> <span class="hljs-string">"{"</span> + <span class="hljs-built_in">Object</span>.keys(value).map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
            <span class="hljs-keyword">return</span> key + <span class="hljs-string">": "</span> + value[key];
        }).join(<span class="hljs-string">", "</span>) + <span class="hljs-string">"}"</span>;

    <span class="hljs-keyword">if</span> (isArray.check(value))
        <span class="hljs-keyword">return</span> <span class="hljs-string">"["</span> + value.map(shallowStringify).join(<span class="hljs-string">", "</span>) + <span class="hljs-string">"]"</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(value);
}

Tp.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-keyword">this</span>.name;

    <span class="hljs-keyword">if</span> (isString.check(name))
        <span class="hljs-keyword">return</span> name;

    <span class="hljs-keyword">if</span> (isFunction.check(name))
        <span class="hljs-keyword">return</span> name.call(<span class="hljs-keyword">this</span>) + <span class="hljs-string">""</span>;

    <span class="hljs-keyword">return</span> name + <span class="hljs-string">" type"</span>;
};

<span class="hljs-keyword">var</span> builtInCtorFns = [];
<span class="hljs-keyword">var</span> builtInCtorTypes = [];
<span class="hljs-keyword">var</span> builtInTypes = {};
exports.builtInTypes = builtInTypes;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defBuiltInType</span>(<span class="hljs-params">example, name</span>) </span>{
    <span class="hljs-keyword">var</span> objStr = objToStr.call(example);

    <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">new</span> Type(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> objToStr.call(value) === objStr;
    }, name);

    builtInTypes[name] = type;

    <span class="hljs-keyword">if</span> (example &amp;&amp; <span class="hljs-keyword">typeof</span> example.constructor === <span class="hljs-string">"function"</span>) {
        builtInCtorFns.push(example.constructor);
        builtInCtorTypes.push(type);
    }

    <span class="hljs-keyword">return</span> type;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>These types check the underlying [[Class]] attribute of the given
value, rather than using the problematic typeof operator. Note however
that no subtyping is considered; so, for instance, isObject.check
returns false for [], /./, new Date, and null.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> isString = defBuiltInType(<span class="hljs-string">"truthy"</span>, <span class="hljs-string">"string"</span>);
<span class="hljs-keyword">var</span> isFunction = defBuiltInType(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}, <span class="hljs-string">"function"</span>);
<span class="hljs-keyword">var</span> isArray = defBuiltInType([], <span class="hljs-string">"array"</span>);
<span class="hljs-keyword">var</span> isObject = defBuiltInType({}, <span class="hljs-string">"object"</span>);
<span class="hljs-keyword">var</span> isRegExp = defBuiltInType(<span class="hljs-regexp">/./</span>, <span class="hljs-string">"RegExp"</span>);
<span class="hljs-keyword">var</span> isDate = defBuiltInType(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>, <span class="hljs-string">"Date"</span>);
<span class="hljs-keyword">var</span> isNumber = defBuiltInType(<span class="hljs-number">3</span>, <span class="hljs-string">"number"</span>);
<span class="hljs-keyword">var</span> isBoolean = defBuiltInType(<span class="hljs-literal">true</span>, <span class="hljs-string">"boolean"</span>);
<span class="hljs-keyword">var</span> isNull = defBuiltInType(<span class="hljs-literal">null</span>, <span class="hljs-string">"null"</span>);
<span class="hljs-keyword">var</span> isUndefined = defBuiltInType(<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>, <span class="hljs-string">"undefined"</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>There are a number of idiomatic ways of expressing types, so this
function serves to coerce them all to actual Type objects. Note that
providing the name argument is not necessary in most cases.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toType</span>(<span class="hljs-params">from, name</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>The toType function should of course be idempotent.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> <span class="hljs-keyword">instanceof</span> Type)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">from</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>The Def type is used as a helper for constructing compound
interface types for AST nodes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> <span class="hljs-keyword">instanceof</span> Def)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">from</span>.type;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Support [ElemType] syntax.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (isArray.check(<span class="hljs-keyword">from</span>))
        <span class="hljs-keyword">return</span> Type.fromArray(<span class="hljs-keyword">from</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Support { someField: FieldType, ... } syntax.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (isObject.check(<span class="hljs-keyword">from</span>))
        <span class="hljs-keyword">return</span> Type.fromObject(<span class="hljs-keyword">from</span>);

    <span class="hljs-keyword">if</span> (isFunction.check(<span class="hljs-keyword">from</span>)) {
        <span class="hljs-keyword">var</span> bicfIndex = builtInCtorFns.indexOf(<span class="hljs-keyword">from</span>);
        <span class="hljs-keyword">if</span> (bicfIndex &gt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> builtInCtorTypes[bicfIndex];
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>If isFunction.check(from), and from is not a built-in
constructor, assume from is a binary predicate function we can
use to define the type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(<span class="hljs-keyword">from</span>, name);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>As a last resort, toType returns a type that matches any value that
is === from. This is primarily useful for literal values like
toType(null), but it has the additional advantage of allowing
toType to be a total function.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> value === <span class="hljs-keyword">from</span>;
    }, isUndefined.check(name) ? <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">from</span> + <span class="hljs-string">""</span>;
    } : name);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>Returns a type that matches the given value iff any of type1, type2,
etc. match the value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Type.or = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-regexp">/* type1, type2, ... */</span></span>) </span>{
    <span class="hljs-keyword">var</span> types = [];
    <span class="hljs-keyword">var</span> len = <span class="hljs-built_in">arguments</span>.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)
        types.push(toType(<span class="hljs-built_in">arguments</span>[i]));

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, deep</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)
            <span class="hljs-keyword">if</span> (types[i].check(value, deep))
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> types.join(<span class="hljs-string">" | "</span>);
    });
};

Type.fromArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">if</span> (!isArray.check(arr)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">if</span> (arr.length !== <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"only one element type is permitted for typed arrays"</span>);
    }
    <span class="hljs-keyword">return</span> toType(arr[<span class="hljs-number">0</span>]).arrayOf();
};

Tp.arrayOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> elemType = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, deep</span>) </span>{
        <span class="hljs-keyword">return</span> isArray.check(value) &amp;&amp; value.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>) </span>{
            <span class="hljs-keyword">return</span> elemType.check(elem, deep);
        });
    }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"["</span> + elemType + <span class="hljs-string">"]"</span>;
    });
};

Type.fromObject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">var</span> fields = <span class="hljs-built_in">Object</span>.keys(obj).map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Field(name, obj[name]);
    });

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, deep</span>) </span>{
        <span class="hljs-keyword">return</span> isObject.check(value) &amp;&amp; fields.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">field</span>) </span>{
            <span class="hljs-keyword">return</span> field.type.check(value[field.name], deep);
        });
    }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"{ "</span> + fields.join(<span class="hljs-string">", "</span>) + <span class="hljs-string">" }"</span>;
    });
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Field</span>(<span class="hljs-params">name, type, defaultFn, hidden</span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">if</span> (!(self <span class="hljs-keyword">instanceof</span> Field)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Field constructor cannot be invoked without 'new'"</span>);
    }
    isString.assert(name);

    type = toType(type);

    <span class="hljs-keyword">var</span> properties = {
        <span class="hljs-attr">name</span>: { <span class="hljs-attr">value</span>: name },
        <span class="hljs-attr">type</span>: { <span class="hljs-attr">value</span>: type },
        <span class="hljs-attr">hidden</span>: { <span class="hljs-attr">value</span>: !!hidden }
    };

    <span class="hljs-keyword">if</span> (isFunction.check(defaultFn)) {
        properties.defaultFn = { <span class="hljs-attr">value</span>: defaultFn };
    }

    <span class="hljs-built_in">Object</span>.defineProperties(self, properties);
}

<span class="hljs-keyword">var</span> Fp = Field.prototype;

Fp.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.name) + <span class="hljs-string">": "</span> + <span class="hljs-keyword">this</span>.type;
};

Fp.getValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">var</span> value = obj[<span class="hljs-keyword">this</span>.name];

    <span class="hljs-keyword">if</span> (!isUndefined.check(value))
        <span class="hljs-keyword">return</span> value;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaultFn)
        value = <span class="hljs-keyword">this</span>.defaultFn.call(obj);

    <span class="hljs-keyword">return</span> value;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Define a type whose name is registered in a namespace (the defCache) so
that future definitions will return the same type given the same name.
In particular, this system allows for circular and forward definitions.
The Def object d returned from Type.def may be used to configure the
type d.type by calling methods such as d.bases, d.build, and d.field.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Type.def = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">typeName</span>) </span>{
    isString.assert(typeName);
    <span class="hljs-keyword">return</span> hasOwn.call(defCache, typeName)
        ? defCache[typeName]
        : defCache[typeName] = <span class="hljs-keyword">new</span> Def(typeName);
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>In order to return the same Def instance every time Type.def is called
with a particular name, those instances need to be stored in a cache.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> defCache = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Def</span>(<span class="hljs-params">typeName</span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">if</span> (!(self <span class="hljs-keyword">instanceof</span> Def)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Def constructor cannot be invoked without 'new'"</span>);
    }

    <span class="hljs-built_in">Object</span>.defineProperties(self, {
        <span class="hljs-attr">typeName</span>: { <span class="hljs-attr">value</span>: typeName },
        <span class="hljs-attr">baseNames</span>: { <span class="hljs-attr">value</span>: [] },
        <span class="hljs-attr">ownFields</span>: { <span class="hljs-attr">value</span>: <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>) },

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>These two are populated during finalization.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        allSupertypes: { <span class="hljs-attr">value</span>: <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>) }, <span class="hljs-comment">// Includes own typeName.</span>
        supertypeList: { <span class="hljs-attr">value</span>: [] }, <span class="hljs-comment">// Linear inheritance hierarchy.</span>
        allFields: { <span class="hljs-attr">value</span>: <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>) }, <span class="hljs-comment">// Includes inherited fields.</span>
        fieldNames: { <span class="hljs-attr">value</span>: [] }, <span class="hljs-comment">// Non-hidden keys of allFields.</span>

        type: {
            <span class="hljs-attr">value</span>: <span class="hljs-keyword">new</span> Type(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, deep</span>) </span>{
                <span class="hljs-keyword">return</span> self.check(value, deep);
            }, typeName)
        }
    });
}

Def.fromValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span>) {
        <span class="hljs-keyword">var</span> type = value.type;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">"string"</span> &amp;&amp;
            hasOwn.call(defCache, type)) {
            <span class="hljs-keyword">var</span> d = defCache[type];
            <span class="hljs-keyword">if</span> (d.finalized) {
                <span class="hljs-keyword">return</span> d;
            }
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};

<span class="hljs-keyword">var</span> Dp = Def.prototype;

Dp.isSupertypeOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">that</span>) </span>{
    <span class="hljs-keyword">if</span> (that <span class="hljs-keyword">instanceof</span> Def) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.finalized !== <span class="hljs-literal">true</span> ||
            that.finalized !== <span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }
        <span class="hljs-keyword">return</span> hasOwn.call(that.allSupertypes, <span class="hljs-keyword">this</span>.typeName);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(that + <span class="hljs-string">" is not a Def"</span>);
    }
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>Note that the list returned by this function is a copy of the internal
supertypeList, <em>without</em> the typeName itself as the first element.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.getSupertypeNames = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">typeName</span>) </span>{
    <span class="hljs-keyword">if</span> (!hasOwn.call(defCache, typeName)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">var</span> d = defCache[typeName];
    <span class="hljs-keyword">if</span> (d.finalized !== <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">return</span> d.supertypeList.slice(<span class="hljs-number">1</span>);
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Returns an object mapping from every known type in the defCache to the
most specific supertype whose name is an own property of the candidates
object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.computeSupertypeLookupTable = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">candidates</span>) </span>{
    <span class="hljs-keyword">var</span> table = {};
    <span class="hljs-keyword">var</span> typeNames = <span class="hljs-built_in">Object</span>.keys(defCache);
    <span class="hljs-keyword">var</span> typeNameCount = typeNames.length;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; typeNameCount; ++i) {
        <span class="hljs-keyword">var</span> typeName = typeNames[i];
        <span class="hljs-keyword">var</span> d = defCache[typeName];
        <span class="hljs-keyword">if</span> (d.finalized !== <span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span> + typeName);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; d.supertypeList.length; ++j) {
            <span class="hljs-keyword">var</span> superTypeName = d.supertypeList[j];
            <span class="hljs-keyword">if</span> (hasOwn.call(candidates, superTypeName)) {
                table[typeName] = superTypeName;
                <span class="hljs-keyword">break</span>;
            }
        }
    }

    <span class="hljs-keyword">return</span> table;
};

Dp.checkAllFields = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, deep</span>) </span>{
    <span class="hljs-keyword">var</span> allFields = <span class="hljs-keyword">this</span>.allFields;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.finalized !== <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span> + <span class="hljs-keyword">this</span>.typeName);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFieldByName</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">var</span> field = allFields[name];
        <span class="hljs-keyword">var</span> type = field.type;
        <span class="hljs-keyword">var</span> child = field.getValue(value);
        <span class="hljs-keyword">return</span> type.check(child, deep);
    }

    <span class="hljs-keyword">return</span> isObject.check(value)
        &amp;&amp; <span class="hljs-built_in">Object</span>.keys(allFields).every(checkFieldByName);
};

Dp.check = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, deep</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.finalized !== <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
            <span class="hljs-string">"prematurely checking unfinalized type "</span> + <span class="hljs-keyword">this</span>.typeName
        );
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>A Def type can only match an object value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!isObject.check(value))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">var</span> vDef = Def.fromValue(value);
    <span class="hljs-keyword">if</span> (!vDef) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>If we couldn't infer the Def associated with the given value,
and we expected it to be a SourceLocation or a Position, it was
probably just missing a &quot;type&quot; field (because Esprima does not
assign a type property to such nodes). Be optimistic and let
this.checkAllFields make the final decision.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.typeName === <span class="hljs-string">"SourceLocation"</span> ||
            <span class="hljs-keyword">this</span>.typeName === <span class="hljs-string">"Position"</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.checkAllFields(value, deep);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>Calling this.checkAllFields for any other type of node is both
bad for performance and way too forgiving.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>If checking deeply and vDef === this, then we only need to call
checkAllFields once. Calling checkAllFields is too strict when deep
is false, because then we only care about this.isSupertypeOf(vDef).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (deep &amp;&amp; vDef === <span class="hljs-keyword">this</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.checkAllFields(value, deep);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>In most cases we rely exclusively on isSupertypeOf to make O(1)
subtyping determinations. This suffices in most situations outside
of unit tests, since interface conformance is checked whenever new
instances are created using builder functions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isSupertypeOf(vDef))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>The exception is when deep is true; then, we recursively check all
fields.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!deep)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>Use the more specific Def (vDef) to perform the deep check, but
shallow-check fields defined by the less specific Def (this).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> vDef.checkAllFields(value, deep)
        &amp;&amp; <span class="hljs-keyword">this</span>.checkAllFields(value, <span class="hljs-literal">false</span>);
};

Dp.bases = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> args = slice.call(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">var</span> bases = <span class="hljs-keyword">this</span>.baseNames;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.finalized) {
        <span class="hljs-keyword">if</span> (args.length !== bases.length) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) {
            <span class="hljs-keyword">if</span> (args[i] !== bases[i]) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    args.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">baseName</span>) </span>{
        isString.assert(baseName);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>This indexOf lookup may be O(n), but the typical number of base
names is very small, and indexOf is a native Array method.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (bases.indexOf(baseName) &lt; <span class="hljs-number">0</span>)
            bases.push(baseName);
    });

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// For chaining.</span>
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>False by default until .build(...) is called on an instance.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-built_in">Object</span>.defineProperty(Dp, <span class="hljs-string">"buildable"</span>, { <span class="hljs-attr">value</span>: <span class="hljs-literal">false</span> });

<span class="hljs-keyword">var</span> builders = {};
exports.builders = builders;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>This object is used as prototype for any node created by a builder.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> nodePrototype = {};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>Call this function to define a new method to be shared by all AST
nodes. The replaced method (if any) is returned for easy wrapping.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.defineMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, func</span>) </span>{
    <span class="hljs-keyword">var</span> old = nodePrototype[name];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>Pass undefined as func to delete nodePrototype[name].</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (isUndefined.check(func)) {
        <span class="hljs-keyword">delete</span> nodePrototype[name];

    } <span class="hljs-keyword">else</span> {
        isFunction.assert(func);

        <span class="hljs-built_in">Object</span>.defineProperty(nodePrototype, name, {
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// For discoverability.</span>
            configurable: <span class="hljs-literal">true</span>, <span class="hljs-comment">// For delete proto[name].</span>
            value: func
        });
    }

    <span class="hljs-keyword">return</span> old;
};

<span class="hljs-keyword">var</span> isArrayOfString = isString.arrayOf();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>Calling the .build method of a Def simultaneously marks the type as
buildable (by defining builders[getBuilderName(typeName)]) and
specifies the order of arguments that should be passed to the builder
function to create an instance of the type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Dp.build = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-regexp">/* param1, param2, ... */</span></span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> newBuildParams = slice.call(<span class="hljs-built_in">arguments</span>);
    isArrayOfString.assert(newBuildParams);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>Calling Def.prototype.build multiple times has the effect of merely
redefining this property.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-built_in">Object</span>.defineProperty(self, <span class="hljs-string">"buildParams"</span>, {
        <span class="hljs-attr">value</span>: newBuildParams,
        <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>
    });

    <span class="hljs-keyword">if</span> (self.buildable) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<p>If this Def is already buildable, update self.buildParams and
continue using the old builder function.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> self;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<p>Every buildable type will have its &quot;type&quot; field filled in
automatically. This includes types that are not subtypes of Node,
like SourceLocation, but that seems harmless (TODO?).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    self.field(<span class="hljs-string">"type"</span>, <span class="hljs-built_in">String</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> self.typeName });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<p>Override Dp.buildable for this Def instance.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-built_in">Object</span>.defineProperty(self, <span class="hljs-string">"buildable"</span>, { <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> });

    <span class="hljs-built_in">Object</span>.defineProperty(builders, getBuilderName(self.typeName), {
        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,

        <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
            <span class="hljs-keyword">var</span> argc = args.length;
            <span class="hljs-keyword">var</span> built = <span class="hljs-built_in">Object</span>.create(nodePrototype);

            <span class="hljs-keyword">if</span> (!self.finalized) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                    <span class="hljs-string">"attempting to instantiate unfinalized type "</span> +
                        self.typeName
                );
            }

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">param, i</span>) </span>{
                <span class="hljs-keyword">if</span> (hasOwn.call(built, param))
                    <span class="hljs-keyword">return</span>;

                <span class="hljs-keyword">var</span> all = self.allFields;
                <span class="hljs-keyword">if</span> (!hasOwn.call(all, param)) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span> + param);
                }

                <span class="hljs-keyword">var</span> field = all[param];
                <span class="hljs-keyword">var</span> type = field.type;
                <span class="hljs-keyword">var</span> value;

                <span class="hljs-keyword">if</span> (isNumber.check(i) &amp;&amp; i &lt; argc) {
                    value = args[i];
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field.defaultFn) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<p>Expose the partially-built object to the default
function as its <code>this</code> object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    value = field.defaultFn.call(built);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">var</span> message = <span class="hljs-string">"no value or default function given for field "</span> +
                        <span class="hljs-built_in">JSON</span>.stringify(param) + <span class="hljs-string">" of "</span> + self.typeName + <span class="hljs-string">"("</span> +
                            self.buildParams.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
                                <span class="hljs-keyword">return</span> all[name];
                            }).join(<span class="hljs-string">", "</span>) + <span class="hljs-string">")"</span>;
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message);
                }

                <span class="hljs-keyword">if</span> (!type.check(value)) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                        shallowStringify(value) +
                            <span class="hljs-string">" does not match field "</span> + field +
                            <span class="hljs-string">" of type "</span> + self.typeName
                    );
                }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>TODO Could attach getters and setters here to enforce
dynamic type safety.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                built[param] = value;
            }

            self.buildParams.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param, i</span>) </span>{
                add(param, i);
            });

            <span class="hljs-built_in">Object</span>.keys(self.allFields).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>) </span>{
                add(param); <span class="hljs-comment">// Use the default value.</span>
            });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<p>Make sure that the &quot;type&quot; field was filled automatically.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (built.type !== self.typeName) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }

            <span class="hljs-keyword">return</span> built;
        }
    });

    <span class="hljs-keyword">return</span> self; <span class="hljs-comment">// For chaining.</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBuilderName</span>(<span class="hljs-params">typeName</span>) </span>{
    <span class="hljs-keyword">return</span> typeName.replace(<span class="hljs-regexp">/^[A-Z]+/</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">upperCasePrefix</span>) </span>{
        <span class="hljs-keyword">var</span> len = upperCasePrefix.length;
        <span class="hljs-keyword">switch</span> (len) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<p>If there's only one initial capital letter, just lower-case it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> upperCasePrefix.toLowerCase();
        <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<p>If there's more than one initial capital letter, lower-case
all but the last one, so that XMLDefaultDeclaration (for
example) becomes xmlDefaultDeclaration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> upperCasePrefix.slice(
                <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>).toLowerCase() +
                upperCasePrefix.charAt(len - <span class="hljs-number">1</span>);
        }
    });
}
exports.getBuilderName = getBuilderName;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStatementBuilderName</span>(<span class="hljs-params">typeName</span>) </span>{
    typeName = getBuilderName(typeName);
    <span class="hljs-keyword">return</span> typeName.replace(<span class="hljs-regexp">/(Expression)?$/</span>, <span class="hljs-string">"Statement"</span>);
}
exports.getStatementBuilderName = getStatementBuilderName;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<p>The reason fields are specified using .field(...) instead of an object
literal syntax is somewhat subtle: the object literal syntax would
support only one key and one value, but with .field(...) we can pass
any number of arguments to specify the field.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Dp.field = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, type, defaultFn, hidden</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.finalized) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"Ignoring attempt to redefine field "</span> +
                      <span class="hljs-built_in">JSON</span>.stringify(name) + <span class="hljs-string">" of finalized type "</span> +
                      <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.typeName));
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    <span class="hljs-keyword">this</span>.ownFields[name] = <span class="hljs-keyword">new</span> Field(name, type, defaultFn, hidden);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// For chaining.</span>
};

<span class="hljs-keyword">var</span> namedTypes = {};
exports.namedTypes = namedTypes;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<p>Like Object.keys, but aware of what fields each AST type should have.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldNames</span>(<span class="hljs-params">object</span>) </span>{
    <span class="hljs-keyword">var</span> d = Def.fromValue(object);
    <span class="hljs-keyword">if</span> (d) {
        <span class="hljs-keyword">return</span> d.fieldNames.slice(<span class="hljs-number">0</span>);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-string">"type"</span> <span class="hljs-keyword">in</span> object) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
            <span class="hljs-string">"did not recognize object of type "</span> +
                <span class="hljs-built_in">JSON</span>.stringify(object.type)
        );
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(object);
}
exports.getFieldNames = getFieldNames;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<p>Get the value of an object property, taking object.type and default
functions into account.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldValue</span>(<span class="hljs-params">object, fieldName</span>) </span>{
    <span class="hljs-keyword">var</span> d = Def.fromValue(object);
    <span class="hljs-keyword">if</span> (d) {
        <span class="hljs-keyword">var</span> field = d.allFields[fieldName];
        <span class="hljs-keyword">if</span> (field) {
            <span class="hljs-keyword">return</span> field.getValue(object);
        }
    }

    <span class="hljs-keyword">return</span> object[fieldName];
}
exports.getFieldValue = getFieldValue;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<p>Iterate over all defined fields of an object, including those missing
or undefined, passing each field name and effective value (as returned
by getFieldValue) to the callback. If the object has no corresponding
Def, the callback will never be called.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.eachField = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">object, callback, context</span>) </span>{
    getFieldNames(object).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        callback.call(<span class="hljs-keyword">this</span>, name, getFieldValue(object, name));
    }, context);
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<p>Similar to eachField, except that iteration stops as soon as the
callback returns a truthy value. Like Array.prototype.some, the final
result is either true or false to indicates whether the callback
returned true for any element or not.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.someField = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">object, callback, context</span>) </span>{
    <span class="hljs-keyword">return</span> getFieldNames(object).some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> callback.call(<span class="hljs-keyword">this</span>, name, getFieldValue(object, name));
    }, context);
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<p>This property will be overridden as true by individual Def instances
when they are finalized.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-built_in">Object</span>.defineProperty(Dp, <span class="hljs-string">"finalized"</span>, { <span class="hljs-attr">value</span>: <span class="hljs-literal">false</span> });

Dp.finalize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-49" id="section-49"></a>
</div>
<p>It's not an error to finalize a type more than once, but only the
first call to .finalize does anything.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!self.finalized) {
        <span class="hljs-keyword">var</span> allFields = self.allFields;
        <span class="hljs-keyword">var</span> allSupertypes = self.allSupertypes;

        self.baseNames.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
            <span class="hljs-keyword">var</span> def = defCache[name];
            <span class="hljs-keyword">if</span> (def <span class="hljs-keyword">instanceof</span> Def) {
                def.finalize();
                extend(allFields, def.allFields);
                extend(allSupertypes, def.allSupertypes);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> message = <span class="hljs-string">"unknown supertype name "</span> +
                    <span class="hljs-built_in">JSON</span>.stringify(name) +
                    <span class="hljs-string">" for subtype "</span> +
                    <span class="hljs-built_in">JSON</span>.stringify(self.typeName);
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message);
            }
        });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-50" id="section-50"></a>
</div>
<p>TODO Warn if fields are overridden with incompatible types.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        extend(allFields, self.ownFields);
        allSupertypes[self.typeName] = self;

        self.fieldNames.length = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> fieldName <span class="hljs-keyword">in</span> allFields) {
            <span class="hljs-keyword">if</span> (hasOwn.call(allFields, fieldName) &amp;&amp;
                !allFields[fieldName].hidden) {
                self.fieldNames.push(fieldName);
            }
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-51" id="section-51"></a>
</div>
<p>Types are exported only once they have been finalized.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-built_in">Object</span>.defineProperty(namedTypes, self.typeName, {
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">value</span>: self.type
        });

        <span class="hljs-built_in">Object</span>.defineProperty(self, <span class="hljs-string">"finalized"</span>, { <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-52" id="section-52"></a>
</div>
<p>A linearization of the inheritance hierarchy.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        populateSupertypeList(self.typeName, self.supertypeList);

        <span class="hljs-keyword">if</span> (self.buildable &amp;&amp; self.supertypeList.lastIndexOf(<span class="hljs-string">"Expression"</span>) &gt;= <span class="hljs-number">0</span>) {
            wrapExpressionBuilderWithStatement(self.typeName);
        }
    }
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-53" id="section-53"></a>
</div>
<p>Adds an additional builder for Expression subtypes
that wraps the built Expression in an ExpressionStatements.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapExpressionBuilderWithStatement</span>(<span class="hljs-params">typeName</span>) </span>{
    <span class="hljs-keyword">var</span> wrapperName = getStatementBuilderName(typeName);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-54" id="section-54"></a>
</div>
<p>skip if the builder already exists</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (builders[wrapperName]) <span class="hljs-keyword">return</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-55" id="section-55"></a>
</div>
<p>the builder function to wrap with builders.ExpressionStatement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> wrapped = builders[getBuilderName(typeName)];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-56" id="section-56"></a>
</div>
<p>skip if there is nothing to wrap</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!wrapped) <span class="hljs-keyword">return</span>;

    builders[wrapperName] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> builders.expressionStatement(wrapped.apply(builders, <span class="hljs-built_in">arguments</span>));
    };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">populateSupertypeList</span>(<span class="hljs-params">typeName, list</span>) </span>{
    list.length = <span class="hljs-number">0</span>;
    list.push(typeName);

    <span class="hljs-keyword">var</span> lastSeen = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pos = <span class="hljs-number">0</span>; pos &lt; list.length; ++pos) {
        typeName = list[pos];
        <span class="hljs-keyword">var</span> d = defCache[typeName];
        <span class="hljs-keyword">if</span> (d.finalized !== <span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-57" id="section-57"></a>
</div>
<p>If we saw typeName earlier in the breadth-first traversal,
delete the last-seen occurrence.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (hasOwn.call(lastSeen, typeName)) {
            <span class="hljs-keyword">delete</span> list[lastSeen[typeName]];
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-58" id="section-58"></a>
</div>
<p>Record the new index of the last-seen occurrence of typeName.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        lastSeen[typeName] = pos;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-59" id="section-59"></a>
</div>
<p>Enqueue the base names of this type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        list.push.apply(list, d.baseNames);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-60" id="section-60"></a>
</div>
<p>Compaction loop to remove array holes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> to = <span class="hljs-number">0</span>, <span class="hljs-keyword">from</span> = to, len = list.length; <span class="hljs-keyword">from</span> &lt; len; ++<span class="hljs-keyword">from</span>) {
        <span class="hljs-keyword">if</span> (hasOwn.call(list, <span class="hljs-keyword">from</span>)) {
            list[to++] = list[<span class="hljs-keyword">from</span>];
        }
    }

    list.length = to;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">into, from</span>) </span>{
    <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">from</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        into[name] = <span class="hljs-keyword">from</span>[name];
    });

    <span class="hljs-keyword">return</span> into;
};

exports.finalize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">Object</span>.keys(defCache).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        defCache[name].finalize();
    });
};

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
