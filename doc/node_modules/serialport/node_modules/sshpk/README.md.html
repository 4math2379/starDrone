<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../doc-style.css" />
  <script src="../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../";
    var thisFile = "node_modules/serialport/node_modules/sshpk/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#sshpk">sshpk</a>
      </div>

      <div class="heading h2">
        <a href="#install">Install</a>
      </div>

      <div class="heading h2">
        <a href="#examples">Examples</a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h2">
        <a href="#public-keys">Public keys</a>
      </div>

      <div class="heading h3">
        <a href="#parsekey-data-format-auto-options">parseKey(data[, format = &#39;auto&#39;[, options]])</a>
      </div>

      <div class="heading h3">
        <a href="#key.iskey-obj">Key.isKey(obj)</a>
      </div>

      <div class="heading h3">
        <a href="#keytype">Key#type</a>
      </div>

      <div class="heading h3">
        <a href="#keysize">Key#size</a>
      </div>

      <div class="heading h3">
        <a href="#keycomment">Key#comment</a>
      </div>

      <div class="heading h3">
        <a href="#keycurve">Key#curve</a>
      </div>

      <div class="heading h3">
        <a href="#keytobuffer-format-ssh">Key#toBuffer([format = &#39;ssh&#39;])</a>
      </div>

      <div class="heading h3">
        <a href="#keytostring-format-ssh">Key#toString([format = &#39;ssh])</a>
      </div>

      <div class="heading h3">
        <a href="#keyfingerprint-algorithm-sha256">Key#fingerprint([algorithm = &#39;sha256&#39;])</a>
      </div>

      <div class="heading h3">
        <a href="#keycreateverify-hashalgorithm">Key#createVerify([hashAlgorithm])</a>
      </div>

      <div class="heading h3">
        <a href="#keycreatediffiehellman">Key#createDiffieHellman()</a>
      </div>

      <div class="heading h3">
        <a href="#keycreatedh">Key#createDH()</a>
      </div>

      <div class="heading h2">
        <a href="#private-keys">Private keys</a>
      </div>

      <div class="heading h3">
        <a href="#parseprivatekey-data-format-auto-options">parsePrivateKey(data[, format = &#39;auto&#39;[, options]])</a>
      </div>

      <div class="heading h3">
        <a href="#privatekey.isprivatekey-obj">PrivateKey.isPrivateKey(obj)</a>
      </div>

      <div class="heading h3">
        <a href="#privatekeytype">PrivateKey#type</a>
      </div>

      <div class="heading h3">
        <a href="#privatekeysize">PrivateKey#size</a>
      </div>

      <div class="heading h3">
        <a href="#privatekeycurve">PrivateKey#curve</a>
      </div>

      <div class="heading h3">
        <a href="#privatekeytobuffer-format-pkcs1">PrivateKey#toBuffer([format = &#39;pkcs1&#39;])</a>
      </div>

      <div class="heading h3">
        <a href="#privatekeytostring-format-pkcs1">PrivateKey#toString([format = &#39;pkcs1&#39;])</a>
      </div>

      <div class="heading h3">
        <a href="#privatekeytopublic">PrivateKey#toPublic()</a>
      </div>

      <div class="heading h3">
        <a href="#privatekeyfingerprint-algorithm-sha256">PrivateKey#fingerprint([algorithm = &#39;sha256&#39;])</a>
      </div>

      <div class="heading h3">
        <a href="#privatekeycreateverify-hashalgorithm">PrivateKey#createVerify([hashAlgorithm])</a>
      </div>

      <div class="heading h3">
        <a href="#privatekeycreatesign-hashalgorithm">PrivateKey#createSign([hashAlgorithm])</a>
      </div>

      <div class="heading h3">
        <a href="#privatekeyderive-newtype">PrivateKey#derive(newType)</a>
      </div>

      <div class="heading h2">
        <a href="#fingerprints">Fingerprints</a>
      </div>

      <div class="heading h3">
        <a href="#parsefingerprint-fingerprint-algorithms">parseFingerprint(fingerprint[, algorithms])</a>
      </div>

      <div class="heading h3">
        <a href="#fingerprint.isfingerprint-obj">Fingerprint.isFingerprint(obj)</a>
      </div>

      <div class="heading h3">
        <a href="#fingerprinttostring-format">Fingerprint#toString([format])</a>
      </div>

      <div class="heading h3">
        <a href="#fingerprintmatches-key">Fingerprint#matches(key)</a>
      </div>

      <div class="heading h2">
        <a href="#signatures">Signatures</a>
      </div>

      <div class="heading h3">
        <a href="#parsesignature-signature-algorithm-format">parseSignature(signature, algorithm, format)</a>
      </div>

      <div class="heading h3">
        <a href="#signature.issignature-obj">Signature.isSignature(obj)</a>
      </div>

      <div class="heading h3">
        <a href="#signaturetobuffer-format-asn1">Signature#toBuffer([format = &#39;asn1&#39;])</a>
      </div>

      <div class="heading h3">
        <a href="#signaturetostring-format-asn1">Signature#toString([format = &#39;asn1&#39;])</a>
      </div>

      <div class="heading h2">
        <a href="#errors">Errors</a>
      </div>

      <div class="heading h3">
        <a href="#invalidalgorithmerror">InvalidAlgorithmError</a>
      </div>

      <div class="heading h3">
        <a href="#fingerprintformaterror">FingerprintFormatError</a>
      </div>

      <div class="heading h3">
        <a href="#keyparseerror">KeyParseError</a>
      </div>

      <div class="heading h3">
        <a href="#keyencryptederror">KeyEncryptedError</a>
      </div>

      <div class="heading h2">
        <a href="#friends-of-sshpk">Friends of sshpk</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="sshpk">
  <h1>
    <a href="#sshpk" name="sshpk" class="pilcrow"></a>
sshpk
  </h1>
</div>
<p>Parse, convert, fingerprint and use SSH keys (both public and private) in pure
node -- no <code>ssh-keygen</code> or other external dependencies.</p>
<p>Supports RSA, DSA, ECDSA (nistp-*) and ED25519 key types, in PEM (PKCS#1,
PKCS#8) and OpenSSH formats.</p>
<p>This library has been extracted from
<a href="https://github.com/joyent/node-http-signature"><code>node-http-signature</code></a>
(work by <a href="https://github.com/mcavage">Mark Cavage</a> and
<a href="https://github.com/bahamas10">Dave Eddy</a>) and
<a href="https://github.com/bahamas10/node-ssh-fingerprint"><code>node-ssh-fingerprint</code></a>
(work by Dave Eddy), with additions (including ECDSA support) by
<a href="https://github.com/arekinath">Alex Wilson</a>.</p>
<div class="pilwrap" id="install">
  <h2>
    <a href="#install" name="install" class="pilcrow"></a>
Install
  </h2>
</div>
<pre><code>npm install sshpk
</code></pre>
<div class="pilwrap" id="examples">
  <h2>
    <a href="#examples" name="examples" class="pilcrow"></a>
Examples
  </h2>
</div>
<pre><code class="js"><span class="hljs-keyword">var</span> sshpk = <span class="hljs-built_in">require</span>(<span class="hljs-string">'sshpk'</span>);

<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">/* Read in an OpenSSH-format public key */</span>
<span class="hljs-keyword">var</span> keyPub = fs.readFileSync(<span class="hljs-string">'id_rsa.pub'</span>);
<span class="hljs-keyword">var</span> key = sshpk.parseKey(keyPub, <span class="hljs-string">'ssh'</span>);

<span class="hljs-comment">/* Get metadata about the key */</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'type =&gt; %s'</span>, key.type);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'size =&gt; %d bits'</span>, key.size);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'comment =&gt; %s'</span>, key.comment);

<span class="hljs-comment">/* Compute key fingerprints, in new OpenSSH (&gt;6.7) format, and old MD5 */</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fingerprint =&gt; %s'</span>, key.fingerprint().toString());
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'old-style fingerprint =&gt; %s'</span>, key.fingerprint(<span class="hljs-string">'md5'</span>).toString());
</code></pre>
<p>Example output:</p>
<pre><code>type =&gt; rsa
size =&gt; 2048 bits
comment =&gt; foo@foo.com
fingerprint =&gt; SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w
old-style fingerprint =&gt; a0:c8:ad:6c:32:9a:32:fa:59:cc:a9:8c:0a:0d:6e:bd
</code></pre>
<p>More examples: converting between formats:</p>
<pre><code class="js"><span class="hljs-comment">/* Read in a PEM public key */</span>
<span class="hljs-keyword">var</span> keyPem = fs.readFileSync(<span class="hljs-string">'id_rsa.pem'</span>);
<span class="hljs-keyword">var</span> key = sshpk.parseKey(keyPem, <span class="hljs-string">'pem'</span>);

<span class="hljs-comment">/* Convert to PEM PKCS#8 public key format */</span>
<span class="hljs-keyword">var</span> pemBuf = key.toBuffer(<span class="hljs-string">'pkcs8'</span>);

<span class="hljs-comment">/* Convert to SSH public key format (and return as a string) */</span>
<span class="hljs-keyword">var</span> sshKey = key.toString(<span class="hljs-string">'ssh'</span>);
</code></pre>
<p>Signing and verifying:</p>
<pre><code class="js"><span class="hljs-comment">/* Read in an OpenSSH/PEM *private* key */</span>
<span class="hljs-keyword">var</span> keyPriv = fs.readFileSync(<span class="hljs-string">'id_ecdsa'</span>);
<span class="hljs-keyword">var</span> key = sshpk.parsePrivateKey(keyPriv, <span class="hljs-string">'pem'</span>);

<span class="hljs-keyword">var</span> data = <span class="hljs-string">'some data'</span>;

<span class="hljs-comment">/* Sign some data with the key */</span>
<span class="hljs-keyword">var</span> s = key.createSign(<span class="hljs-string">'sha1'</span>);
s.update(data);
<span class="hljs-keyword">var</span> signature = s.sign();

<span class="hljs-comment">/* Now load the public key (could also use just key.toPublic()) */</span>
<span class="hljs-keyword">var</span> keyPub = fs.readFileSync(<span class="hljs-string">'id_ecdsa.pub'</span>);
key = sshpk.parseKey(keyPub, <span class="hljs-string">'ssh'</span>);

<span class="hljs-comment">/* Make a crypto.Verifier with this key */</span>
<span class="hljs-keyword">var</span> v = key.createVerify(<span class="hljs-string">'sha1'</span>);
v.update(data);
<span class="hljs-keyword">var</span> valid = v.verify(signature);
<span class="hljs-comment">/* =&gt; true! */</span>
</code></pre>
<p>Matching fingerprints with keys:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> fp = sshpk.parseFingerprint(<span class="hljs-string">'SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w'</span>);

<span class="hljs-keyword">var</span> keys = [sshpk.parseKey(...), sshpk.parseKey(...), ...];

keys.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
	<span class="hljs-keyword">if</span> (fp.matches(key))
		<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'found it!'</span>);
});
</code></pre>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<div class="pilwrap" id="public-keys">
  <h2>
    <a href="#public-keys" name="public-keys" class="pilcrow"></a>
Public keys
  </h2>
</div>
<div class="pilwrap" id="parsekey-data-format-auto-options">
  <h3>
    <a href="#parsekey-data-format-auto-options" name="parsekey-data-format-auto-options" class="pilcrow"></a>
<code>parseKey(data[, format = 'auto'[, options]])</code>
  </h3>
</div>
<p>Parses a key from a given data format and returns a new <code>Key</code> object.</p>
<p>Parameters</p>
<ul>
<li><code>data</code> -- Either a Buffer or String, containing the key</li>
<li><code>format</code> -- String name of format to use, valid options are:
<ul>
<li><code>auto</code>: choose automatically from all below</li>
<li><code>pem</code>: supports both PKCS#1 and PKCS#8</li>
<li><code>ssh</code>: standard OpenSSH format,</li>
<li><code>pkcs1</code>, <code>pkcs8</code>: variants of <code>pem</code></li>
<li><code>rfc4253</code>: raw OpenSSH wire format</li>
<li><code>openssh</code>: new post-OpenSSH 6.5 internal format, produced by
<code>ssh-keygen -o</code></li>
</ul>
</li>
<li><code>options</code> -- Optional Object, extra options, with keys:
<ul>
<li><code>filename</code> -- Optional String, name for the key being parsed
(eg. the filename that was opened). Used to generate
Error messages</li>
<li><code>passphrase</code> -- Optional String, encryption passphrase used to decrypt an
encrypted PEM file</li>
</ul>
</li>
</ul>
<div class="pilwrap" id="key.iskey-obj">
  <h3>
    <a href="#key.iskey-obj" name="key.iskey-obj" class="pilcrow"></a>
<code>Key.isKey(obj)</code>
  </h3>
</div>
<p>Returns <code>true</code> if the given object is a valid <code>Key</code> object created by a version
of <code>sshpk</code> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><code>obj</code> -- Object to identify</li>
</ul>
<div class="pilwrap" id="keytype">
  <h3>
    <a href="#keytype" name="keytype" class="pilcrow"></a>
<code>Key#type</code>
  </h3>
</div>
<p>String, the type of key. Valid options are <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code>.</p>
<div class="pilwrap" id="keysize">
  <h3>
    <a href="#keysize" name="keysize" class="pilcrow"></a>
<code>Key#size</code>
  </h3>
</div>
<p>Integer, &quot;size&quot; of the key in bits. For RSA/DSA this is the size of the modulus;
for ECDSA this is the bit size of the curve in use.</p>
<div class="pilwrap" id="keycomment">
  <h3>
    <a href="#keycomment" name="keycomment" class="pilcrow"></a>
<code>Key#comment</code>
  </h3>
</div>
<p>Optional string, a key comment used by some formats (eg the <code>ssh</code> format).</p>
<div class="pilwrap" id="keycurve">
  <h3>
    <a href="#keycurve" name="keycurve" class="pilcrow"></a>
<code>Key#curve</code>
  </h3>
</div>
<p>Only present if <code>this.type === 'ecdsa'</code>, string containing the name of the
named curve used with this key. Possible values include <code>nistp256</code>, <code>nistp384</code>
and <code>nistp521</code>.</p>
<div class="pilwrap" id="keytobuffer-format-ssh">
  <h3>
    <a href="#keytobuffer-format-ssh" name="keytobuffer-format-ssh" class="pilcrow"></a>
<code>Key#toBuffer([format = 'ssh'])</code>
  </h3>
</div>
<p>Convert the key into a given data format and return the serialized key as
a Buffer.</p>
<p>Parameters</p>
<ul>
<li><code>format</code> -- String name of format to use, for valid options see <code>parseKey()</code></li>
</ul>
<div class="pilwrap" id="keytostring-format-ssh">
  <h3>
    <a href="#keytostring-format-ssh" name="keytostring-format-ssh" class="pilcrow"></a>
<code>Key#toString([format = 'ssh])</code>
  </h3>
</div>
<p>Same as <code>this.toBuffer(format).toString()</code>.</p>
<div class="pilwrap" id="keyfingerprint-algorithm-sha256">
  <h3>
    <a href="#keyfingerprint-algorithm-sha256" name="keyfingerprint-algorithm-sha256" class="pilcrow"></a>
<code>Key#fingerprint([algorithm = 'sha256'])</code>
  </h3>
</div>
<p>Creates a new <code>Fingerprint</code> object representing this Key's fingerprint.</p>
<p>Parameters</p>
<ul>
<li><code>algorithm</code> -- String name of hash algorithm to use, valid options are <code>md5</code>,
<code>sha1</code>, <code>sha256</code>, <code>sha384</code>, <code>sha512</code></li>
</ul>
<div class="pilwrap" id="keycreateverify-hashalgorithm">
  <h3>
    <a href="#keycreateverify-hashalgorithm" name="keycreateverify-hashalgorithm" class="pilcrow"></a>
<code>Key#createVerify([hashAlgorithm])</code>
  </h3>
</div>
<p>Creates a <code>crypto.Verifier</code> specialized to use this Key (and the correct public
key algorithm to match it). The returned Verifier has the same API as a regular
one, except that the <code>verify()</code> function takes only the target signature as an
argument.</p>
<p>Parameters</p>
<ul>
<li><code>hashAlgorithm</code> -- optional String name of hash algorithm to use, any
supported by OpenSSL are valid, usually including
<code>sha1</code>, <code>sha256</code>.</li>
</ul>
<p><code>v.verify(signature[, format])</code> Parameters</p>
<ul>
<li><code>signature</code> -- either a Signature object, or a Buffer or String</li>
<li><code>format</code> -- optional String, name of format to interpret given String with.
Not valid if <code>signature</code> is a Signature or Buffer.</li>
</ul>
<div class="pilwrap" id="keycreatediffiehellman">
  <h3>
    <a href="#keycreatediffiehellman" name="keycreatediffiehellman" class="pilcrow"></a>
<code>Key#createDiffieHellman()</code>
  </h3>
</div>
<div class="pilwrap" id="keycreatedh">
  <h3>
    <a href="#keycreatedh" name="keycreatedh" class="pilcrow"></a>
<code>Key#createDH()</code>
  </h3>
</div>
<p>Creates a Diffie-Hellman key exchange object initialized with this key and all
necessary parameters. This has the same API as a <code>crypto.DiffieHellman</code>
instance, except that functions take <code>Key</code> and <code>PrivateKey</code> objects as
arguments, and return them where indicated for.</p>
<p>This is only valid for keys belonging to a cryptosystem that supports DHE
or a close analogue (i.e. <code>dsa</code>, <code>ecdsa</code> and <code>curve25519</code> keys). An attempt
to call this function on other keys will yield an <code>Error</code>.</p>
<div class="pilwrap" id="private-keys">
  <h2>
    <a href="#private-keys" name="private-keys" class="pilcrow"></a>
Private keys
  </h2>
</div>
<div class="pilwrap" id="parseprivatekey-data-format-auto-options">
  <h3>
    <a href="#parseprivatekey-data-format-auto-options" name="parseprivatekey-data-format-auto-options" class="pilcrow"></a>
<code>parsePrivateKey(data[, format = 'auto'[, options]])</code>
  </h3>
</div>
<p>Parses a private key from a given data format and returns a new
<code>PrivateKey</code> object.</p>
<p>Parameters</p>
<ul>
<li><code>data</code> -- Either a Buffer or String, containing the key</li>
<li><code>format</code> -- String name of format to use, valid options are:
<ul>
<li><code>auto</code>: choose automatically from all below</li>
<li><code>pem</code>: supports both PKCS#1 and PKCS#8</li>
<li><code>ssh</code>, <code>openssh</code>: new post-OpenSSH 6.5 internal format, produced by
<code>ssh-keygen -o</code></li>
<li><code>pkcs1</code>, <code>pkcs8</code>: variants of <code>pem</code></li>
<li><code>rfc4253</code>: raw OpenSSH wire format</li>
</ul>
</li>
<li><code>options</code> -- Optional Object, extra options, with keys:
<ul>
<li><code>filename</code> -- Optional String, name for the key being parsed
(eg. the filename that was opened). Used to generate
Error messages</li>
<li><code>passphrase</code> -- Optional String, encryption passphrase used to decrypt an
encrypted PEM file</li>
</ul>
</li>
</ul>
<div class="pilwrap" id="privatekey.isprivatekey-obj">
  <h3>
    <a href="#privatekey.isprivatekey-obj" name="privatekey.isprivatekey-obj" class="pilcrow"></a>
<code>PrivateKey.isPrivateKey(obj)</code>
  </h3>
</div>
<p>Returns <code>true</code> if the given object is a valid <code>PrivateKey</code> object created by a
version of <code>sshpk</code> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><code>obj</code> -- Object to identify</li>
</ul>
<div class="pilwrap" id="privatekeytype">
  <h3>
    <a href="#privatekeytype" name="privatekeytype" class="pilcrow"></a>
<code>PrivateKey#type</code>
  </h3>
</div>
<p>String, the type of key. Valid options are <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code>.</p>
<div class="pilwrap" id="privatekeysize">
  <h3>
    <a href="#privatekeysize" name="privatekeysize" class="pilcrow"></a>
<code>PrivateKey#size</code>
  </h3>
</div>
<p>Integer, &quot;size&quot; of the key in bits. For RSA/DSA this is the size of the modulus;
for ECDSA this is the bit size of the curve in use.</p>
<div class="pilwrap" id="privatekeycurve">
  <h3>
    <a href="#privatekeycurve" name="privatekeycurve" class="pilcrow"></a>
<code>PrivateKey#curve</code>
  </h3>
</div>
<p>Only present if <code>this.type === 'ecdsa'</code>, string containing the name of the
named curve used with this key. Possible values include <code>nistp256</code>, <code>nistp384</code>
and <code>nistp521</code>.</p>
<div class="pilwrap" id="privatekeytobuffer-format-pkcs1">
  <h3>
    <a href="#privatekeytobuffer-format-pkcs1" name="privatekeytobuffer-format-pkcs1" class="pilcrow"></a>
<code>PrivateKey#toBuffer([format = 'pkcs1'])</code>
  </h3>
</div>
<p>Convert the key into a given data format and return the serialized key as
a Buffer.</p>
<p>Parameters</p>
<ul>
<li><code>format</code> -- String name of format to use, valid options are listed under
<code>parsePrivateKey</code>. Note that ED25519 keys default to <code>openssh</code>
format instead (as they have no <code>pkcs1</code> representation).</li>
</ul>
<div class="pilwrap" id="privatekeytostring-format-pkcs1">
  <h3>
    <a href="#privatekeytostring-format-pkcs1" name="privatekeytostring-format-pkcs1" class="pilcrow"></a>
<code>PrivateKey#toString([format = 'pkcs1'])</code>
  </h3>
</div>
<p>Same as <code>this.toBuffer(format).toString()</code>.</p>
<div class="pilwrap" id="privatekeytopublic">
  <h3>
    <a href="#privatekeytopublic" name="privatekeytopublic" class="pilcrow"></a>
<code>PrivateKey#toPublic()</code>
  </h3>
</div>
<p>Extract just the public part of this private key, and return it as a <code>Key</code>
object.</p>
<div class="pilwrap" id="privatekeyfingerprint-algorithm-sha256">
  <h3>
    <a href="#privatekeyfingerprint-algorithm-sha256" name="privatekeyfingerprint-algorithm-sha256" class="pilcrow"></a>
<code>PrivateKey#fingerprint([algorithm = 'sha256'])</code>
  </h3>
</div>
<p>Same as <code>this.toPublic().fingerprint()</code>.</p>
<div class="pilwrap" id="privatekeycreateverify-hashalgorithm">
  <h3>
    <a href="#privatekeycreateverify-hashalgorithm" name="privatekeycreateverify-hashalgorithm" class="pilcrow"></a>
<code>PrivateKey#createVerify([hashAlgorithm])</code>
  </h3>
</div>
<p>Same as <code>this.toPublic().createVerify()</code>.</p>
<div class="pilwrap" id="privatekeycreatesign-hashalgorithm">
  <h3>
    <a href="#privatekeycreatesign-hashalgorithm" name="privatekeycreatesign-hashalgorithm" class="pilcrow"></a>
<code>PrivateKey#createSign([hashAlgorithm])</code>
  </h3>
</div>
<p>Creates a <code>crypto.Sign</code> specialized to use this PrivateKey (and the correct
key algorithm to match it). The returned Signer has the same API as a regular
one, except that the <code>sign()</code> function takes no arguments, and returns a
<code>Signature</code> object.</p>
<p>Parameters</p>
<ul>
<li><code>hashAlgorithm</code> -- optional String name of hash algorithm to use, any
supported by OpenSSL are valid, usually including
<code>sha1</code>, <code>sha256</code>.</li>
</ul>
<p><code>v.sign()</code> Parameters</p>
<ul>
<li>none</li>
</ul>
<div class="pilwrap" id="privatekeyderive-newtype">
  <h3>
    <a href="#privatekeyderive-newtype" name="privatekeyderive-newtype" class="pilcrow"></a>
<code>PrivateKey#derive(newType)</code>
  </h3>
</div>
<p>Derives a related key of type <code>newType</code> from this key. Currently this is
only supported to change between <code>ed25519</code> and <code>curve25519</code> keys which are
stored with the same private key (but usually distinct public keys in order
to avoid degenerate keys that lead to a weak Diffie-Hellman exchange).</p>
<p>Parameters</p>
<ul>
<li><code>newType</code> -- String, type of key to derive, either <code>ed25519</code> or <code>curve25519</code></li>
</ul>
<div class="pilwrap" id="fingerprints">
  <h2>
    <a href="#fingerprints" name="fingerprints" class="pilcrow"></a>
Fingerprints
  </h2>
</div>
<div class="pilwrap" id="parsefingerprint-fingerprint-algorithms">
  <h3>
    <a href="#parsefingerprint-fingerprint-algorithms" name="parsefingerprint-fingerprint-algorithms" class="pilcrow"></a>
<code>parseFingerprint(fingerprint[, algorithms])</code>
  </h3>
</div>
<p>Pre-parses a fingerprint, creating a <code>Fingerprint</code> object that can be used to
quickly locate a key by using the <code>Fingerprint#matches</code> function.</p>
<p>Parameters</p>
<ul>
<li><code>fingerprint</code> -- String, the fingerprint value, in any supported format</li>
<li><code>algorithms</code> -- Optional list of strings, names of hash algorithms to limit
support to. If <code>fingerprint</code> uses a hash algorithm not on
this list, throws <code>InvalidAlgorithmError</code>.</li>
</ul>
<div class="pilwrap" id="fingerprint.isfingerprint-obj">
  <h3>
    <a href="#fingerprint.isfingerprint-obj" name="fingerprint.isfingerprint-obj" class="pilcrow"></a>
<code>Fingerprint.isFingerprint(obj)</code>
  </h3>
</div>
<p>Returns <code>true</code> if the given object is a valid <code>Fingerprint</code> object created by a
version of <code>sshpk</code> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><code>obj</code> -- Object to identify</li>
</ul>
<div class="pilwrap" id="fingerprinttostring-format">
  <h3>
    <a href="#fingerprinttostring-format" name="fingerprinttostring-format" class="pilcrow"></a>
<code>Fingerprint#toString([format])</code>
  </h3>
</div>
<p>Returns a fingerprint as a string, in the given format.</p>
<p>Parameters</p>
<ul>
<li><code>format</code> -- Optional String, format to use, valid options are <code>hex</code> and
<code>base64</code>. If this <code>Fingerprint</code> uses the <code>md5</code> algorithm, the
default format is <code>hex</code>. Otherwise, the default is <code>base64</code>.</li>
</ul>
<div class="pilwrap" id="fingerprintmatches-key">
  <h3>
    <a href="#fingerprintmatches-key" name="fingerprintmatches-key" class="pilcrow"></a>
<code>Fingerprint#matches(key)</code>
  </h3>
</div>
<p>Verifies whether or not this <code>Fingerprint</code> matches a given <code>Key</code>. This function
uses double-hashing to avoid leaking timing information. Returns a boolean.</p>
<p>Parameters</p>
<ul>
<li><code>key</code> -- a <code>Key</code> object, the key to match this fingerprint against</li>
</ul>
<div class="pilwrap" id="signatures">
  <h2>
    <a href="#signatures" name="signatures" class="pilcrow"></a>
Signatures
  </h2>
</div>
<div class="pilwrap" id="parsesignature-signature-algorithm-format">
  <h3>
    <a href="#parsesignature-signature-algorithm-format" name="parsesignature-signature-algorithm-format" class="pilcrow"></a>
<code>parseSignature(signature, algorithm, format)</code>
  </h3>
</div>
<p>Parses a signature in a given format, creating a <code>Signature</code> object. Useful
for converting between the SSH and ASN.1 (PKCS/OpenSSL) signature formats, and
also returned as output from <code>PrivateKey#createSign().sign()</code>.</p>
<p>A Signature object can also be passed to a verifier produced by
<code>Key#createVerify()</code> and it will automatically be converted internally into the
correct format for verification.</p>
<p>Parameters</p>
<ul>
<li><code>signature</code> -- a Buffer (binary) or String (base64), data of the actual
signature in the given format</li>
<li><code>algorithm</code> -- a String, name of the algorithm to be used, possible values
are <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code></li>
<li><code>format</code> -- a String, either <code>asn1</code> or <code>ssh</code></li>
</ul>
<div class="pilwrap" id="signature.issignature-obj">
  <h3>
    <a href="#signature.issignature-obj" name="signature.issignature-obj" class="pilcrow"></a>
<code>Signature.isSignature(obj)</code>
  </h3>
</div>
<p>Returns <code>true</code> if the given object is a valid <code>Signature</code> object created by a
version of <code>sshpk</code> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><code>obj</code> -- Object to identify</li>
</ul>
<div class="pilwrap" id="signaturetobuffer-format-asn1">
  <h3>
    <a href="#signaturetobuffer-format-asn1" name="signaturetobuffer-format-asn1" class="pilcrow"></a>
<code>Signature#toBuffer([format = 'asn1'])</code>
  </h3>
</div>
<p>Converts a Signature to the given format and returns it as a Buffer.</p>
<p>Parameters</p>
<ul>
<li><code>format</code> -- a String, either <code>asn1</code> or <code>ssh</code></li>
</ul>
<div class="pilwrap" id="signaturetostring-format-asn1">
  <h3>
    <a href="#signaturetostring-format-asn1" name="signaturetostring-format-asn1" class="pilcrow"></a>
<code>Signature#toString([format = 'asn1'])</code>
  </h3>
</div>
<p>Same as <code>this.toBuffer(format).toString('base64')</code>.</p>
<div class="pilwrap" id="errors">
  <h2>
    <a href="#errors" name="errors" class="pilcrow"></a>
Errors
  </h2>
</div>
<div class="pilwrap" id="invalidalgorithmerror">
  <h3>
    <a href="#invalidalgorithmerror" name="invalidalgorithmerror" class="pilcrow"></a>
<code>InvalidAlgorithmError</code>
  </h3>
</div>
<p>The specified algorithm is not valid, either because it is not supported, or
because it was not included on a list of allowed algorithms.</p>
<p>Thrown by <code>Fingerprint.parse</code>, <code>Key#fingerprint</code>.</p>
<p>Properties</p>
<ul>
<li><code>algorithm</code> -- the algorithm that could not be validated</li>
</ul>
<div class="pilwrap" id="fingerprintformaterror">
  <h3>
    <a href="#fingerprintformaterror" name="fingerprintformaterror" class="pilcrow"></a>
<code>FingerprintFormatError</code>
  </h3>
</div>
<p>The fingerprint string given could not be parsed as a supported fingerprint
format, or the specified fingerprint format is invalid.</p>
<p>Thrown by <code>Fingerprint.parse</code>, <code>Fingerprint#toString</code>.</p>
<p>Properties</p>
<ul>
<li><code>fingerprint</code> -- if caused by a fingerprint, the string value given</li>
<li><code>format</code> -- if caused by an invalid format specification, the string value given</li>
</ul>
<div class="pilwrap" id="keyparseerror">
  <h3>
    <a href="#keyparseerror" name="keyparseerror" class="pilcrow"></a>
<code>KeyParseError</code>
  </h3>
</div>
<p>The key data given could not be parsed as a valid key.</p>
<p>Properties</p>
<ul>
<li><code>keyName</code> -- <code>filename</code> that was given to <code>Key#parse</code></li>
<li><code>format</code> -- the <code>format</code> that was trying to parse the key</li>
<li><code>innerErr</code> -- the inner Error thrown by the format parser</li>
</ul>
<div class="pilwrap" id="keyencryptederror">
  <h3>
    <a href="#keyencryptederror" name="keyencryptederror" class="pilcrow"></a>
<code>KeyEncryptedError</code>
  </h3>
</div>
<p>The key is encrypted with a symmetric key (ie, it is password protected). The
parsing operation would succeed if it was given the <code>passphrase</code> option.</p>
<p>Properties</p>
<ul>
<li><code>keyName</code> -- <code>filename</code> that was given to <code>Key#parse</code></li>
<li><code>format</code> -- the <code>format</code> that was trying to parse the key (currently can only
be <code>&quot;pem&quot;</code>)</li>
</ul>
<div class="pilwrap" id="friends-of-sshpk">
  <h2>
    <a href="#friends-of-sshpk" name="friends-of-sshpk" class="pilcrow"></a>
Friends of sshpk
  </h2>
</div>
<ul>
<li><a href="https://github.com/arekinath/node-sshpk-agent"><code>sshpk-agent</code></a> is a library
for speaking the <code>ssh-agent</code> protocol from node.js, which uses <code>sshpk</code></li>
</ul>
</div>
  </div>
</body>
</html>
