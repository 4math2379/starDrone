<!DOCTYPE html>
<html>
<head>
  <title>pem.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../../../doc-style.css" />
  <script src="../../../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../../../";
    var thisFile = "node_modules/serialport/node_modules/sshpk/lib/formats/pem.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>pem.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<p>Copyright 2015 Joyent, Inc.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-built_in">module</span>.exports = {
	<span class="hljs-attr">read</span>: read,
	<span class="hljs-attr">write</span>: write
};

<span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert-plus'</span>);
<span class="hljs-keyword">var</span> asn1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'asn1'</span>);
<span class="hljs-keyword">var</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">var</span> algs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../algs'</span>);
<span class="hljs-keyword">var</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../utils'</span>);
<span class="hljs-keyword">var</span> Key = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../key'</span>);
<span class="hljs-keyword">var</span> PrivateKey = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../private-key'</span>);

<span class="hljs-keyword">var</span> pkcs1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./pkcs1'</span>);
<span class="hljs-keyword">var</span> pkcs8 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./pkcs8'</span>);
<span class="hljs-keyword">var</span> sshpriv = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./ssh-private'</span>);
<span class="hljs-keyword">var</span> rfc4253 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./rfc4253'</span>);

<span class="hljs-keyword">var</span> errors = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../errors'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<div class="dox">
<div class="summary">
<p>For reading we support both PKCS#1 and PKCS#8. If we find a private key,
we just take the public component of it and use that.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">function read(buf, options, forceType) {
	var input = buf;
	if (typeof (buf) !== 'string') {
		assert.buffer(buf, 'buf');
		buf = buf.toString('ascii');
	}

	var lines = buf.trim().split('\n');

	var m = lines[0].match(/*JSSTYLED*/
	    /[-]+[ ]*BEGIN ([A-Z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
	assert.ok(m, 'invalid PEM header');

	var m2 = lines[lines.length - 1].match(/*JSSTYLED*/
	    /[-]+[ ]*END ([A-Z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
	assert.ok(m2, 'invalid PEM footer');

	/* Begin and end banners must match key type */
	assert.equal(m[2], m2[2]);
	var type = m[2].toLowerCase();

	var alg;
	if (m[1]) {
		/* They also must match algorithms, if given */
		assert.equal(m[1], m2[1], 'PEM header and footer mismatch');
		alg = m[1].trim();
	}

	var headers = {};
	while (true) {
		lines = lines.slice(1);
		m = lines[0].match(/*JSSTYLED*/
		    /^([A-Za-z0-9-]+): (.+)$/);
		if (!m)
			break;
		headers[m[1].toLowerCase()] = m[2];
	}

	var cipher, key, iv;
	if (headers['proc-type']) {
		var parts = headers['proc-type'].split(',');
		if (parts[0] === '4' &amp;&amp; parts[1] === 'ENCRYPTED') {
			if (typeof (options.passphrase) === 'string') {
				options.passphrase = new Buffer(
				    options.passphrase, 'utf-8');
			}
			if (!Buffer.isBuffer(options.passphrase)) {
				throw (new errors.KeyEncryptedError(
				    options.filename, 'PEM'));
			} else {
				parts = headers['dek-info'].split(',');
				assert.ok(parts.length === 2);
				cipher = parts[0].toLowerCase();
				iv = new Buffer(parts[1], 'hex');
				key = utils.opensslKeyDeriv(cipher, iv,
				    options.passphrase, 1).key;
			}
		}
	}

	/* Chop off the first and last lines */
	lines = lines.slice(0, -1).join('');
	buf = new Buffer(lines, 'base64');

	if (cipher &amp;&amp; key &amp;&amp; iv) {
		var cipherStream = crypto.createDecipheriv(cipher, key, iv);
		var chunk, chunks = [];
		cipherStream.once('error', function (e) {
			if (e.toString().indexOf('bad decrypt') !== -1) {
				throw (new Error('Incorrect passphrase ' +
				    'supplied, could not decrypt key'));
			}
			throw (e);
		});
		cipherStream.write(buf);
		cipherStream.end();
		while ((chunk = cipherStream.read()) !== null)
			chunks.push(chunk);
		buf = Buffer.concat(chunks);
	}

	/* The new OpenSSH internal format abuses PEM headers */
	if (alg &amp;&amp; alg.toLowerCase() === 'openssh')
		return (sshpriv.readSSHPrivate(type, buf));
	if (alg &amp;&amp; alg.toLowerCase() === 'ssh2')
		return (rfc4253.readType(type, buf));

	var der = new asn1.BerReader(buf);
	der.originalInput = input;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<div class="dox">
<div class="summary">
<p>All of the PEM file types start with a sequence tag, so chop it
off here</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">	der.readSequence();

	<span class="hljs-comment">/* PKCS#1 type keys name an algorithm in the banner explicitly */</span>
	<span class="hljs-keyword">if</span> (alg) {
		<span class="hljs-keyword">if</span> (forceType)
			assert.strictEqual(forceType, <span class="hljs-string">'pkcs1'</span>);
		<span class="hljs-keyword">return</span> (pkcs1.readPkcs1(alg, type, der));
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">if</span> (forceType)
			assert.strictEqual(forceType, <span class="hljs-string">'pkcs8'</span>);
		<span class="hljs-keyword">return</span> (pkcs8.readPkcs8(alg, type, der));
	}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params">key, options, type</span>) </span>{
	assert.object(key);

	<span class="hljs-keyword">var</span> alg = {<span class="hljs-string">'ecdsa'</span>: <span class="hljs-string">'EC'</span>, <span class="hljs-string">'rsa'</span>: <span class="hljs-string">'RSA'</span>, <span class="hljs-string">'dsa'</span>: <span class="hljs-string">'DSA'</span>}[key.type];
	<span class="hljs-keyword">var</span> header;

	<span class="hljs-keyword">var</span> der = <span class="hljs-keyword">new</span> asn1.BerWriter();

	<span class="hljs-keyword">if</span> (PrivateKey.isPrivateKey(key)) {
		<span class="hljs-keyword">if</span> (type &amp;&amp; type === <span class="hljs-string">'pkcs8'</span>) {
			header = <span class="hljs-string">'PRIVATE KEY'</span>;
			pkcs8.writePkcs8(der, key);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">if</span> (type)
				assert.strictEqual(type, <span class="hljs-string">'pkcs1'</span>);
			header = alg + <span class="hljs-string">' PRIVATE KEY'</span>;
			pkcs1.writePkcs1(der, key);
		}

	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Key.isKey(key)) {
		<span class="hljs-keyword">if</span> (type &amp;&amp; type === <span class="hljs-string">'pkcs1'</span>) {
			header = alg + <span class="hljs-string">' PUBLIC KEY'</span>;
			pkcs1.writePkcs1(der, key);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">if</span> (type)
				assert.strictEqual(type, <span class="hljs-string">'pkcs8'</span>);
			header = <span class="hljs-string">'PUBLIC KEY'</span>;
			pkcs8.writePkcs8(der, key);
		}

	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">throw</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'key is not a Key or PrivateKey'</span>));
	}

	<span class="hljs-keyword">var</span> tmp = der.buffer.toString(<span class="hljs-string">'base64'</span>);
	<span class="hljs-keyword">var</span> len = tmp.length + (tmp.length / <span class="hljs-number">64</span>) +
	    <span class="hljs-number">18</span> + <span class="hljs-number">16</span> + header.length*<span class="hljs-number">2</span> + <span class="hljs-number">10</span>;
	<span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(len);
	<span class="hljs-keyword">var</span> o = <span class="hljs-number">0</span>;
	o += buf.write(<span class="hljs-string">'-----BEGIN '</span> + header + <span class="hljs-string">'-----\n'</span>, o);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tmp.length; ) {
		<span class="hljs-keyword">var</span> limit = i + <span class="hljs-number">64</span>;
		<span class="hljs-keyword">if</span> (limit &gt; tmp.length)
			limit = tmp.length;
		o += buf.write(tmp.slice(i, limit), o);
		buf[o++] = <span class="hljs-number">10</span>;
		i = limit;
	}
	o += buf.write(<span class="hljs-string">'-----END '</span> + header + <span class="hljs-string">'-----\n'</span>, o);

	<span class="hljs-keyword">return</span> (buf.slice(<span class="hljs-number">0</span>, o));
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
