<!DOCTYPE html>
<html>
<head>
  <title>serialport_win.cpp</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "node_modules/serialport/src/serialport_win.cpp";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>serialport_win.cpp</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;nan.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"./serialport.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"win/disphelper.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"win/stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"win/enumser.h"</span></span>


<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WIN32</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BUFFER_SIZE 1000</span>

<span class="hljs-keyword">struct</span> WindowsPlatformOptions : OpenBatonPlatformOptions {
};

<span class="hljs-function">OpenBatonPlatformOptions* <span class="hljs-title">ParsePlatformOptions</span><span class="hljs-params">(<span class="hljs-keyword">const</span> v8::Local&lt;v8::Object&gt;&amp; options)</span> </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>currently none</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WindowsPlatformOptions();
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Declare type of pointer to CancelIoEx function</p>

        </td>
        <td class="code highlight">
          <pre class="cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">BOOL</span> <span class="hljs-params">(WINAPI *CancelIoExType)</span><span class="hljs-params">(HANDLE hFile, LPOVERLAPPED lpOverlapped)</span></span>;

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; g_closingHandles;
<span class="hljs-keyword">int</span> bufferSize;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ErrorCodeToString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* prefix, <span class="hljs-keyword">int</span> errorCode, <span class="hljs-keyword">char</span> *errorStr)</span> </span>{
  <span class="hljs-keyword">switch</span> (errorCode) {
  <span class="hljs-keyword">case</span> ERROR_FILE_NOT_FOUND:
    _snprintf(errorStr, ERROR_STRING_SIZE, <span class="hljs-string">"%s: File not found"</span>, prefix);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> ERROR_INVALID_HANDLE:
    _snprintf(errorStr, ERROR_STRING_SIZE, <span class="hljs-string">"%s: Invalid handle"</span>, prefix);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> ERROR_ACCESS_DENIED:
    _snprintf(errorStr, ERROR_STRING_SIZE, <span class="hljs-string">"%s: Access denied"</span>, prefix);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> ERROR_OPERATION_ABORTED:
    _snprintf(errorStr, ERROR_STRING_SIZE, <span class="hljs-string">"%s: operation aborted"</span>, prefix);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    _snprintf(errorStr, ERROR_STRING_SIZE, <span class="hljs-string">"%s: Unknown error code %d"</span>, prefix, errorCode);
    <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_Open</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  OpenBaton* data = <span class="hljs-keyword">static_cast</span>&lt;OpenBaton*&gt;(req-&gt;data);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>data-&gt;path is char[1024] but on Windows it has the form &quot;COMx\0&quot; or &quot;COMxx\0&quot;
We want to prepend &quot;\\.\&quot; to it before we call CreateFile</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-built_in">strncpy</span>(data-&gt;path + <span class="hljs-number">20</span>, data-&gt;path, <span class="hljs-number">10</span>);
  <span class="hljs-built_in">strncpy</span>(data-&gt;path, <span class="hljs-string">"\\\\.\\"</span>, <span class="hljs-number">4</span>);
  <span class="hljs-built_in">strncpy</span>(data-&gt;path + <span class="hljs-number">4</span>, data-&gt;path + <span class="hljs-number">20</span>, <span class="hljs-number">10</span>);

  HANDLE file = CreateFile(
    data-&gt;path,
    GENERIC_READ | GENERIC_WRITE,
    <span class="hljs-number">0</span>,
    <span class="hljs-literal">NULL</span>,
    OPEN_EXISTING,
    FILE_FLAG_OVERLAPPED,
    <span class="hljs-literal">NULL</span>);
  <span class="hljs-keyword">if</span> (file == INVALID_HANDLE_VALUE) {
    DWORD errorCode = GetLastError();
    <span class="hljs-keyword">char</span> temp[<span class="hljs-number">100</span>];
    _snprintf(temp, <span class="hljs-keyword">sizeof</span>(temp), <span class="hljs-string">"Opening %s"</span>, data-&gt;path);
    ErrorCodeToString(temp, errorCode, data-&gt;errorString);
    <span class="hljs-keyword">return</span>;
  }

  bufferSize = data-&gt;bufferSize;
  <span class="hljs-keyword">if</span> (bufferSize &gt; MAX_BUFFER_SIZE) {
    bufferSize = MAX_BUFFER_SIZE;
  }

  DCB dcb = { <span class="hljs-number">0</span> };
  dcb.DCBlength = <span class="hljs-keyword">sizeof</span>(DCB);
  <span class="hljs-keyword">if</span> (data-&gt;hupcl == <span class="hljs-literal">false</span>) {
    dcb.fDtrControl = DTR_CONTROL_DISABLE;  <span class="hljs-comment">// disable DTR to avoid reset</span>
  } <span class="hljs-keyword">else</span> {
    dcb.fDtrControl = DTR_CONTROL_ENABLE;
  }

  dcb.BaudRate = CBR_9600;
  dcb.Parity = NOPARITY;
  dcb.ByteSize = <span class="hljs-number">8</span>;
  dcb.StopBits = ONESTOPBIT;
  dcb.fInX = FALSE;
  dcb.fOutX = FALSE;
  dcb.fOutxDsrFlow = FALSE;
  dcb.fOutxCtsFlow = FALSE;
  dcb.fRtsControl = RTS_CONTROL_ENABLE;

  dcb.fBinary = <span class="hljs-literal">true</span>;
  dcb.BaudRate = data-&gt;baudRate;
  dcb.ByteSize = data-&gt;dataBits;
  <span class="hljs-keyword">switch</span> (data-&gt;parity) {
  <span class="hljs-keyword">case</span> SERIALPORT_PARITY_NONE:
    dcb.Parity = NOPARITY;
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> SERIALPORT_PARITY_MARK:
    dcb.Parity = MARKPARITY;
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> SERIALPORT_PARITY_EVEN:
    dcb.Parity = EVENPARITY;
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> SERIALPORT_PARITY_ODD:
    dcb.Parity = ODDPARITY;
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> SERIALPORT_PARITY_SPACE:
    dcb.Parity = SPACEPARITY;
    <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">switch</span> (data-&gt;stopBits) {
  <span class="hljs-keyword">case</span> SERIALPORT_STOPBITS_ONE:
    dcb.StopBits = ONESTOPBIT;
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> SERIALPORT_STOPBITS_ONE_FIVE:
    dcb.StopBits = ONE5STOPBITS;
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> SERIALPORT_STOPBITS_TWO:
    dcb.StopBits = TWOSTOPBITS;
    <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-keyword">if</span> (!SetCommState(file, &amp;dcb)) {
    ErrorCodeToString(<span class="hljs-string">"SetCommState"</span>, GetLastError(), data-&gt;errorString);
    <span class="hljs-keyword">return</span>;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Set the com port read/write timeouts</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  DWORD serialBitsPerByte = <span class="hljs-number">8</span><span class="hljs-comment">/*std data bits*/</span> + <span class="hljs-number">1</span><span class="hljs-comment">/*start bit*/</span>;
  serialBitsPerByte += (data-&gt;parity == SERIALPORT_PARITY_NONE) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
  serialBitsPerByte += (data-&gt;stopBits == SERIALPORT_STOPBITS_ONE) ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;
  DWORD msPerByte = (data-&gt;baudRate &gt; <span class="hljs-number">0</span>) ?
                    ((<span class="hljs-number">1000</span> * serialBitsPerByte + data-&gt;baudRate - <span class="hljs-number">1</span>) / data-&gt;baudRate) :
                    <span class="hljs-number">1</span>;
  <span class="hljs-keyword">if</span> (msPerByte &lt; <span class="hljs-number">1</span>) {
    msPerByte = <span class="hljs-number">1</span>;
  }
  COMMTIMEOUTS commTimeouts = {<span class="hljs-number">0</span>};
  commTimeouts.ReadIntervalTimeout = msPerByte;  <span class="hljs-comment">// Minimize chance of concatenating of separate serial port packets on read</span>
  commTimeouts.ReadTotalTimeoutMultiplier = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Do not allow big read timeout when big read buffer used</span>
  commTimeouts.ReadTotalTimeoutConstant = <span class="hljs-number">1000</span>;  <span class="hljs-comment">// Total read timeout (period of read loop)</span>
  commTimeouts.WriteTotalTimeoutConstant = <span class="hljs-number">1000</span>;  <span class="hljs-comment">// Const part of write timeout</span>
  commTimeouts.WriteTotalTimeoutMultiplier = msPerByte;  <span class="hljs-comment">// Variable part of write timeout (per byte)</span>
  <span class="hljs-keyword">if</span> (!SetCommTimeouts(file, &amp;commTimeouts)) {
    ErrorCodeToString(<span class="hljs-string">"SetCommTimeouts"</span>, GetLastError(), data-&gt;errorString);
    <span class="hljs-keyword">return</span>;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Remove garbage data in RX/TX queues</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  PurgeComm(file, PURGE_RXCLEAR);
  PurgeComm(file, PURGE_TXCLEAR);

  data-&gt;result = (<span class="hljs-keyword">int</span>)file;
}

<span class="hljs-keyword">struct</span> WatchPortBaton {
  HANDLE fd;
  DWORD bytesRead;
  <span class="hljs-keyword">char</span> buffer[MAX_BUFFER_SIZE];
  <span class="hljs-keyword">char</span> errorString[ERROR_STRING_SIZE];
  DWORD errorCode;
  <span class="hljs-keyword">bool</span> disconnected;
  Nan::Callback* dataCallback;
  Nan::Callback* errorCallback;
  Nan::Callback* disconnectedCallback;
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_Update</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>TODO always error or do an update</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_Set</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  SetBaton* data = <span class="hljs-keyword">static_cast</span>&lt;SetBaton*&gt;(req-&gt;data);

  <span class="hljs-keyword">if</span> (data-&gt;rts) {
    EscapeCommFunction((HANDLE)data-&gt;fd, SETRTS);
  } <span class="hljs-keyword">else</span> {
    EscapeCommFunction((HANDLE)data-&gt;fd, CLRRTS);
  }

  <span class="hljs-keyword">if</span> (data-&gt;dtr) {
    EscapeCommFunction((HANDLE)data-&gt;fd, SETDTR);
  } <span class="hljs-keyword">else</span> {
    EscapeCommFunction((HANDLE)data-&gt;fd, CLRDTR);
  }

  <span class="hljs-keyword">if</span> (data-&gt;brk) {
    EscapeCommFunction((HANDLE)data-&gt;fd, SETBREAK);
  } <span class="hljs-keyword">else</span> {
    EscapeCommFunction((HANDLE)data-&gt;fd, CLRBREAK);
  }

  DWORD bits = <span class="hljs-number">0</span>;

  GetCommMask((HANDLE)data-&gt;fd, &amp;bits);

  bits &amp;= ~(EV_CTS | EV_DSR);

  <span class="hljs-keyword">if</span> (data-&gt;cts) {
    bits |= EV_CTS;
  }

  <span class="hljs-keyword">if</span> (data-&gt;dsr) {
    bits |= EV_DSR;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>TODO check for error</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  data-&gt;result = SetCommMask((HANDLE)data-&gt;fd, bits);
}


<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_WatchPort</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  WatchPortBaton* data = <span class="hljs-keyword">static_cast</span>&lt;WatchPortBaton*&gt;(req-&gt;data);
  data-&gt;bytesRead = <span class="hljs-number">0</span>;
  data-&gt;disconnected = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Event used by GetOverlappedResult(..., TRUE) to wait for incoming data or timeout
Event MUST be used if program has several simultaneous asynchronous operations
on the same handle (i.e. ReadFile and WriteFile)</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  HANDLE hEvent = CreateEvent(<span class="hljs-literal">NULL</span>, TRUE, FALSE, <span class="hljs-literal">NULL</span>);

  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    OVERLAPPED ov = {<span class="hljs-number">0</span>};
    ov.hEvent = hEvent;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Start read operation - synchrounous or asynchronous</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">    DWORD bytesReadSync = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (!ReadFile((HANDLE)data-&gt;fd, data-&gt;buffer, bufferSize, &amp;bytesReadSync, &amp;ov)) {
      data-&gt;errorCode = GetLastError();
      <span class="hljs-keyword">if</span> (data-&gt;errorCode != ERROR_IO_PENDING) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Read operation error</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">        <span class="hljs-keyword">if</span> (data-&gt;errorCode == ERROR_OPERATION_ABORTED) {
          data-&gt;disconnected = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          ErrorCodeToString(<span class="hljs-string">"Reading from COM port (ReadFile)"</span>, data-&gt;errorCode, data-&gt;errorString);
          CloseHandle(hEvent);
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">break</span>;
      }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Read operation is asynchronous and is pending
We MUST wait for operation completion before deallocation of OVERLAPPED struct
or read data buffer</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>Wait for async read operation completion or timeout</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">      DWORD bytesReadAsync = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (!GetOverlappedResult((HANDLE)data-&gt;fd, &amp;ov, &amp;bytesReadAsync, TRUE)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Read operation error</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">        data-&gt;errorCode = GetLastError();
        <span class="hljs-keyword">if</span> (data-&gt;errorCode == ERROR_OPERATION_ABORTED) {
          data-&gt;disconnected = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          ErrorCodeToString(<span class="hljs-string">"Reading from COM port (GetOverlappedResult)"</span>, data-&gt;errorCode, data-&gt;errorString);
          CloseHandle(hEvent);
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">break</span>;
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>Read operation completed asynchronously</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">        data-&gt;bytesRead = bytesReadAsync;
      }
    } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Read operation completed synchronously</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">      data-&gt;bytesRead = bytesReadSync;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>Return data received if any</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">    <span class="hljs-keyword">if</span> (data-&gt;bytesRead &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">break</span>;
    }
  }

  CloseHandle(hEvent);
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsClosingHandle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = g_closingHandles.begin(); it != g_closingHandles.end(); ++it) {
    <span class="hljs-keyword">if</span> (fd == *it) {
      g_closingHandles.remove(fd);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisposeWatchPortCallbacks</span><span class="hljs-params">(WatchPortBaton* data)</span> </span>{
  <span class="hljs-keyword">delete</span> data-&gt;dataCallback;
  <span class="hljs-keyword">delete</span> data-&gt;errorCallback;
  <span class="hljs-keyword">delete</span> data-&gt;disconnectedCallback;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>FinalizerCallback will prevent WatchPortBaton::buffer from getting
collected by gc while finalizing v8::ArrayBuffer. The buffer will
get cleaned up through this callback.</p>

        </td>
        <td class="code highlight">
          <pre class="cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FinalizerCallback</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* data, <span class="hljs-keyword">void</span>* hint)</span> </span>{
  <span class="hljs-keyword">uv_work_t</span>* req = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uv_work_t</span>*&gt;(hint);
  WatchPortBaton* wpb = <span class="hljs-keyword">static_cast</span>&lt;WatchPortBaton*&gt;(req-&gt;data);
  <span class="hljs-keyword">delete</span> wpb;
  <span class="hljs-keyword">delete</span> req;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_AfterWatchPort</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  Nan::HandleScope scope;

  WatchPortBaton* data = <span class="hljs-keyword">static_cast</span>&lt;WatchPortBaton*&gt;(req-&gt;data);
  <span class="hljs-keyword">if</span> (data-&gt;disconnected) {
    data-&gt;disconnectedCallback-&gt;Call(<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);
    DisposeWatchPortCallbacks(data);
    <span class="hljs-keyword">goto</span> cleanup;
  }

  <span class="hljs-keyword">bool</span> skipCleanup = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (data-&gt;bytesRead &gt; <span class="hljs-number">0</span>) {
    v8::Local&lt;v8::Value&gt; argv[<span class="hljs-number">1</span>];
    argv[<span class="hljs-number">0</span>] = Nan::NewBuffer(data-&gt;buffer, data-&gt;bytesRead, FinalizerCallback, req).ToLocalChecked();
    skipCleanup = <span class="hljs-literal">true</span>;
    data-&gt;dataCallback-&gt;Call(<span class="hljs-number">1</span>, argv);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data-&gt;errorCode &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span> (data-&gt;errorCode == ERROR_INVALID_HANDLE &amp;&amp; IsClosingHandle((<span class="hljs-keyword">int</span>)data-&gt;fd)) {
      DisposeWatchPortCallbacks(data);
      <span class="hljs-keyword">goto</span> cleanup;
    } <span class="hljs-keyword">else</span> {
      v8::Local&lt;v8::Value&gt; argv[<span class="hljs-number">1</span>];
      argv[<span class="hljs-number">0</span>] = Nan::Error(data-&gt;errorString);
      data-&gt;errorCallback-&gt;Call(<span class="hljs-number">1</span>, argv);
      Sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// prevent the errors from occurring too fast</span>
    }
  }
  AfterOpenSuccess((<span class="hljs-keyword">int</span>)data-&gt;fd, data-&gt;dataCallback, data-&gt;disconnectedCallback, data-&gt;errorCallback);

cleanup:
  <span class="hljs-keyword">if</span> (!skipCleanup) {
    <span class="hljs-keyword">delete</span> data;
    <span class="hljs-keyword">delete</span> req;
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AfterOpenSuccess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, Nan::Callback* dataCallback, Nan::Callback* disconnectedCallback, Nan::Callback* errorCallback)</span> </span>{
  WatchPortBaton* baton = <span class="hljs-keyword">new</span> WatchPortBaton();
  <span class="hljs-built_in">memset</span>(baton, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(WatchPortBaton));
  baton-&gt;fd = (HANDLE)fd;
  baton-&gt;dataCallback = dataCallback;
  baton-&gt;errorCallback = errorCallback;
  baton-&gt;disconnectedCallback = disconnectedCallback;

  <span class="hljs-keyword">uv_work_t</span>* req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uv_work_t</span>();
  req-&gt;data = baton;

  uv_queue_work(uv_default_loop(), req, EIO_WatchPort, (uv_after_work_cb)EIO_AfterWatchPort);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_Write</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  QueuedWrite* queuedWrite = <span class="hljs-keyword">static_cast</span>&lt;QueuedWrite*&gt;(req-&gt;data);
  WriteBaton* data = <span class="hljs-keyword">static_cast</span>&lt;WriteBaton*&gt;(queuedWrite-&gt;baton);
  data-&gt;result = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">do</span> {
    OVERLAPPED ov = {<span class="hljs-number">0</span>};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>Event used by GetOverlappedResult(..., TRUE) to wait for outgoing data or timeout
Event MUST be used if program has several simultaneous asynchronous operations
on the same handle (i.e. ReadFile and WriteFile)</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">    ov.hEvent = CreateEvent(<span class="hljs-literal">NULL</span>, TRUE, FALSE, <span class="hljs-literal">NULL</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Start write operation - synchrounous or asynchronous</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">    DWORD bytesWrittenSync = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (!WriteFile((HANDLE)data-&gt;fd, data-&gt;bufferData, <span class="hljs-keyword">static_cast</span>&lt;DWORD&gt;(data-&gt;bufferLength), &amp;bytesWrittenSync, &amp;ov)) {
      DWORD lastError = GetLastError();
      <span class="hljs-keyword">if</span> (lastError != ERROR_IO_PENDING) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>Write operation error</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">        ErrorCodeToString(<span class="hljs-string">"Writing to COM port (WriteFile)"</span>, lastError, data-&gt;errorString);
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>Write operation is asynchronous and is pending
We MUST wait for operation completion before deallocation of OVERLAPPED struct
or write data buffer</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>Wait for async write operation completion or timeout</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">        DWORD bytesWrittenAsync = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (!GetOverlappedResult((HANDLE)data-&gt;fd, &amp;ov, &amp;bytesWrittenAsync, TRUE)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>Write operation error</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">          DWORD lastError = GetLastError();
          ErrorCodeToString(<span class="hljs-string">"Writing to COM port (GetOverlappedResult)"</span>, lastError, data-&gt;errorString);
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>Write operation completed asynchronously</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">          data-&gt;result = bytesWrittenAsync;
        }
      }
    } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>Write operation completed synchronously</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">      data-&gt;result = bytesWrittenSync;
    }

    data-&gt;offset += data-&gt;result;
    CloseHandle(ov.hEvent);
  } <span class="hljs-keyword">while</span> (data-&gt;bufferLength &gt; data-&gt;offset);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_Close</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  CloseBaton* data = <span class="hljs-keyword">static_cast</span>&lt;CloseBaton*&gt;(req-&gt;data);

  g_closingHandles.push_back(data-&gt;fd);

  HMODULE hKernel32 = LoadLibrary(<span class="hljs-string">"kernel32.dll"</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>Look up function address</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  CancelIoExType pCancelIoEx = (CancelIoExType)GetProcAddress(hKernel32, <span class="hljs-string">"CancelIoEx"</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>Do something with it</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (pCancelIoEx) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>Function exists so call it
Cancel all pending IO Requests for the current device</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">    pCancelIoEx((HANDLE)data-&gt;fd, <span class="hljs-literal">NULL</span>);
  }
  <span class="hljs-keyword">if</span> (!CloseHandle((HANDLE)data-&gt;fd)) {
    ErrorCodeToString(<span class="hljs-string">"closing connection"</span>, GetLastError(), data-&gt;errorString);
    <span class="hljs-keyword">return</span>;
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<div class="dox">
<div class="summary">
<p>listComPorts.c -- list COM ports</p>
</div>
<div class="body">
<p>http://github.com/todbot/usbSearch/</p>
<p>2012, Tod E. Kurt, http://todbot.com/blog/</p>
<p>Uses DispHealper : http://disphelper.sourceforge.net/</p>
<p>Notable VIDs &amp; PIDs combos:
VID 0403 - FTDI</p>
<p>VID 0403 / PID 6001 - Arduino Diecimila</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_List</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  ListBaton* data = <span class="hljs-keyword">static_cast</span>&lt;ListBaton*&gt;(req-&gt;data);

  {
    DISPATCH_OBJ(wmiSvc);
    DISPATCH_OBJ(colDevices);

    dhInitialize(TRUE);
    dhToggleExceptions(FALSE);

    dhGetObject(<span class="hljs-string">L"winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2"</span>, <span class="hljs-literal">NULL</span>, &amp;wmiSvc);
    dhGetValue(<span class="hljs-string">L"%o"</span>, &amp;colDevices, wmiSvc, <span class="hljs-string">L".ExecQuery(%S)"</span>, <span class="hljs-string">L"Select * from Win32_PnPEntity"</span>);

    <span class="hljs-keyword">int</span> port_count = <span class="hljs-number">0</span>;
    FOR_EACH(objDevice, colDevices, <span class="hljs-literal">NULL</span>) {
      <span class="hljs-keyword">char</span>* name = <span class="hljs-literal">NULL</span>;
      <span class="hljs-keyword">char</span>* pnpid = <span class="hljs-literal">NULL</span>;
      <span class="hljs-keyword">char</span>* manu = <span class="hljs-literal">NULL</span>;
      <span class="hljs-keyword">char</span>* match;

      dhGetValue(<span class="hljs-string">L"%s"</span>, &amp;name,  objDevice, <span class="hljs-string">L".Name"</span>);
      dhGetValue(<span class="hljs-string">L"%s"</span>, &amp;pnpid, objDevice, <span class="hljs-string">L".PnPDeviceID"</span>);

      <span class="hljs-keyword">if</span> (name != <span class="hljs-literal">NULL</span> &amp;&amp; ((match = <span class="hljs-built_in">strstr</span>(name, <span class="hljs-string">"(COM"</span>)) != <span class="hljs-literal">NULL</span>)) {  <span class="hljs-comment">// look for "(COM23)"</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>'Manufacturuer' can be null, so only get it if we need it</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">        dhGetValue(<span class="hljs-string">L"%s"</span>, &amp;manu, objDevice,  <span class="hljs-string">L".Manufacturer"</span>);
        port_count++;
        <span class="hljs-keyword">char</span>* comname = strtok(match, <span class="hljs-string">"()"</span>);
        ListResultItem* resultItem = <span class="hljs-keyword">new</span> ListResultItem();
        resultItem-&gt;comName = comname;
        resultItem-&gt;manufacturer = manu;
        resultItem-&gt;pnpId = pnpid;
        data-&gt;results.push_back(resultItem);
        dhFreeString(manu);
      }

      dhFreeString(name);
      dhFreeString(pnpid);
    } NEXT(objDevice);

    SAFE_RELEASE(colDevices);
    SAFE_RELEASE(wmiSvc);

    dhUninitialize(TRUE);
  }

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;UINT&gt; ports;
  <span class="hljs-keyword">if</span> (CEnumerateSerial::UsingQueryDosDevice(ports)) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; ports.size(); i++) {
      <span class="hljs-keyword">char</span> comname[<span class="hljs-number">64</span>] = { <span class="hljs-number">0</span> };
      _snprintf(comname, <span class="hljs-keyword">sizeof</span>(comname), <span class="hljs-string">"COM%u"</span>, ports[i]);
      <span class="hljs-keyword">bool</span> bFound = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;ListResultItem*&gt;::iterator ri = data-&gt;results.begin(); ri != data-&gt;results.end(); ++ri) {
        <span class="hljs-keyword">if</span> (stricmp((*ri)-&gt;comName.c_str(), comname) == <span class="hljs-number">0</span>) {
          bFound = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">if</span> (!bFound) {
        ListResultItem* resultItem = <span class="hljs-keyword">new</span> ListResultItem();
        resultItem-&gt;comName = comname;
        resultItem-&gt;manufacturer = <span class="hljs-string">""</span>;
        resultItem-&gt;pnpId = <span class="hljs-string">""</span>;
        data-&gt;results.push_back(resultItem);
      }
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_Flush</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  FlushBaton* data = <span class="hljs-keyword">static_cast</span>&lt;FlushBaton*&gt;(req-&gt;data);

  <span class="hljs-keyword">if</span> (!FlushFileBuffers((HANDLE)data-&gt;fd)) {
    ErrorCodeToString(<span class="hljs-string">"flushing connection"</span>, GetLastError(), data-&gt;errorString);
    <span class="hljs-keyword">return</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_Drain</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  DrainBaton* data = <span class="hljs-keyword">static_cast</span>&lt;DrainBaton*&gt;(req-&gt;data);

  <span class="hljs-keyword">if</span> (!FlushFileBuffers((HANDLE)data-&gt;fd)) {
    ErrorCodeToString(<span class="hljs-string">"draining connection"</span>, GetLastError(), data-&gt;errorString);
    <span class="hljs-keyword">return</span>;
  }
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
