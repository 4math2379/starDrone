<!DOCTYPE html>
<html>
<head>
  <title>stdstring.h</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../doc-style.css" />
  <script src="../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../";
    var thisFile = "node_modules/serialport/src/win/stdstring.h";
    var defaultSidebar = true;
  </script>
  <script src="../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#copyright-2002-joseph-m.oleary.this-code-is-100-free.use-it-anywhere-you-want.rewrite-it-restructure-it-whatever.if-you-can-write-software-that-makes-money-off-of-it-good-for-you.i-kinda-like-capitalism.please-dont-blame-me-if-it-causes-your-dollar30-billion-dollar-satellite-explode-in-orbit.if-you-redistribute-it-in-any-form-id-appreciate-it-if-you-would-leave-this-notice-here">COPYRIGHT:
	2002 Joseph M. O&#39;Leary.  This code is 100% free.  Use it anywhere you
want.  Rewrite it, restructure it, whatever.  If you can write software
that makes money off of it, good for you.  I kinda like capitalism.
Please don&#39;t blame me if it causes your $30 billion dollar satellite
explode in orbit.  If you redistribute it in any form, I&#39;d appreciate it
if you would leave this notice here.</a>
      </div>

      <div class="heading h2">
        <a href="#ss_is_intresource">SS_IS_INTRESOURCE</a>
      </div>

      <div class="heading h2">
        <a href="#macro-ss_unsigned">MACRO: SS_UNSIGNED</a>
      </div>

      <div class="heading h2">
        <a href="#macro-ss_safe_format">MACRO: SS_SAFE_FORMAT</a>
      </div>

      <div class="heading h2">
        <a href="#macro-ss_no_implicit_cast">MACRO: SS_NO_IMPLICIT_CAST</a>
      </div>

      <div class="heading h2">
        <a href="#macro-ss_no_refcount">MACRO: SS_NO_REFCOUNT</a>
      </div>

      <div class="heading h2">
        <a href="#macro-ss_win32">MACRO: SS_WIN32</a>
      </div>

      <div class="heading h2">
        <a href="#macro-ss_ansi">MACRO: SS_ANSI</a>
      </div>

      <div class="heading h2">
        <a href="#macro-ss_alloca">MACRO: SS_ALLOCA</a>
      </div>

      <div class="heading h2">
        <a href="#macro-ss_mbcs">MACRO: SS_MBCS</a>
      </div>

      <div class="heading h2">
        <a href="#macro-ss_no_locale">MACRO SS_NO_LOCALE</a>
      </div>

      <div class="heading h2">
        <a href="#compiler-error-regarding-_unicode-and-unicode">Compiler Error regarding _UNICODE and UNICODE</a>
      </div>

      <div class="heading h2">
        <a href="#min-and-max.the-standard-c++-template-versions-go-by-so-many-names-at-at-least-in-the-ms-implementation-that-you-never-know-whats-available">MIN and MAX.  The Standard C++ template versions go by so many names (at
at least in the MS implementation) that you never know what&#39;s available</a>
      </div>

      <div class="heading h1">
        <a href="#unicodembcs-conversion-macros.made-to-work-just-like-the-mfcatl-ones">=============================================================================
UNICODE/MBCS conversion macros.  Made to work just like the MFC/ATL ones.</a>
      </div>

      <div class="heading h1">
        <a href="#without-these-functions-the-cstdstrlessgreater-template-would-probably-have-to-broken-out-into-two-almost-identical-classes.either-that-or-it-would-be-a-huge-convoluted-mess-with-tons-of-if-statements-all-over-the-place-checking-the-size-of-template-parameter-ct">Without these functions, the CStdStr&amp;lt;&amp;gt; template would probably have to broken
out into two, almost identical classes.  Either that or it would be a huge,
convoluted mess, with tons of &amp;quot;if&amp;quot; statements all over the place checking the
size of template parameter CT.</a>
      </div>

      <div class="heading h2">
        <a href="#win32-getstringtypeex-wrappers">Win32 GetStringTypeEx wrappers</a>
      </div>

      <div class="heading h2">
        <a href="#sslen-strlenwcslen-wrappers">sslen: strlen/wcslen wrappers</a>
      </div>

      <div class="heading h2">
        <a href="#sstolowersstoupper-convert-characters-to-upperlower-case">sstolower/sstoupper -- convert characters to upper/lower case</a>
      </div>

      <div class="heading h2">
        <a href="#ssasn-assignment-functions-assign-ssrc-to-sdst">ssasn: assignment functions -- assign &amp;quot;sSrc&amp;quot; to &amp;quot;sDst&amp;quot;</a>
      </div>

      <div class="heading h2">
        <a href="#ssadd-string-object-concatenation-add-second-argument-to-first">ssadd: string object concatenation -- add second argument to first</a>
      </div>

      <div class="heading h2">
        <a href="#sscmp-comparison-case-sensitive-not-affected-by-locale">sscmp: comparison (case sensitive, not affected by locale)</a>
      </div>

      <div class="heading h2">
        <a href="#ssicmp-comparison-case-insensitive-not-affected-by-locale">ssicmp: comparison (case INsensitive, not affected by locale)</a>
      </div>

      <div class="heading h2">
        <a href="#ssuprsslwr-uppercaselowercase-conversion-functions">ssupr/sslwr: Uppercase/Lowercase conversion functions</a>
      </div>

      <div class="heading h2">
        <a href="#got-compiler-problems-here">GOT COMPILER PROBLEMS HERE?</a>
      </div>

      <div class="heading h2">
        <a href="#ssload-type-safe-overloaded-loadstring-wrappers-there-is-no-equivalent-of-these-in-non-win32-specific-builds.however-im-thinking-that-with-the-message-facet-there-might-eventually-be-one">ssload: Type safe, overloaded ::LoadString wrappers
There is no equivalent of these in non-Win32-specific builds.  However, I&#39;m
thinking that with the message facet, there might eventually be one</a>
      </div>

      <div class="heading h2">
        <a href="#sscollssicoll-collation-wrappers-note-with-msvc-i-have-reversed-the-arguments-order-here-because-the-functions-appear-to-return-the-opposite-of-what-they-should">sscoll/ssicoll: Collation wrappers
	Note -- with MSVC I have reversed the arguments order here because the
	functions appear to return the opposite of what they should</a>
      </div>

      <div class="heading h2">
        <a href="#ssfmtmsg-formatmessage-equivalents.needed-because-i-added-a-cstring-facade-again-no-equivalent-of-these-on-non-win32-builds-but-their-might-one-day-be-one-if-the-message-facet-gets-implemented">ssfmtmsg: FormatMessage equivalents.  Needed because I added a CString facade
Again -- no equivalent of these on non-Win32 builds but their might one day
be one if the message facet gets implemented</a>
      </div>

      <div class="heading h2">
        <a href="#function-sscpy.copies-up-to-nmax-characters-from-psrc-to-pdst">FUNCTION: sscpy.  Copies up to &#39;nMax&#39; characters from pSrc to pDst.</a>
      </div>

      <div class="heading h2">
        <a href="#return-value-none">RETURN VALUE: none</a>
      </div>

      <div class="heading h2">
        <a href="#functional-objects-for-changing-case.they-also-let-you-pass-locales">Functional objects for changing case.  They also let you pass locales</a>
      </div>

      <div class="heading h2">
        <a href="#cstdstr-inline-concatenation">CStdStr inline concatenation.</a>
      </div>

      <div class="heading h2">
        <a href="#case-changing-functions">Case changing functions</a>
      </div>

      <div class="heading h2">
        <a href="#cstdstr-direct-access-to-character-buffer.in-the-ms-implementation-the-at-function-that-we-use-here-also-calls-_freeze-providing-us-some-protection-from-multithreading-problems-associated-with-ref-counting.in-vc-7-and-later-of-course-the-ref-counting-stuff-is-gone">CStdStr -- Direct access to character buffer.  In the MS&#39; implementation,
the at() function that we use here also calls _Freeze() providing us some
protection from multithreading problems associated with ref-counting.
In VC 7 and later, of course, the ref-counting stuff is gone.</a>
      </div>

      <div class="heading h2">
        <a href="#return-value-true-if-successful-false-otherwise">RETURN VALUE:
	true if successful, false otherwise</a>
      </div>

      <div class="heading h2">
        <a href="#return-value-none-1">RETURN VALUE:  None.</a>
      </div>

      <div class="heading h2">
        <a href="#return-value">RETURN VALUE:</a>
      </div>

      <div class="heading h2">
        <a href="#the-following-methods-are-intended-to-allow-you-to-use-this-class-as-a-near-drop-in-replacement-for-cstring">The following methods are intended to allow you to use this class as a
near drop-in replacement for CString.</a>
      </div>

      <div class="heading h2">
        <a href="#getxxxx-direct-access-to-character-buffer">GetXXXX -- Direct access to character buffer</a>
      </div>

      <div class="heading h2">
        <a href="#trim-and-its-variants">Trim and its variants</a>
      </div>

      <div class="heading h2">
        <a href="#function-streamsize-remarks-returns-how-many-bytes-it-will-take-to-streamsave-this-cstdstring-object-to-an-istream">FUNCTION: StreamSize
REMARKS:
	Returns how many bytes it will take to StreamSave() this CStdString
	object to an IStream.</a>
      </div>

      <div class="heading h2">
        <a href="#function-streamsave-remarks-saves-this-cstdstring-object-to-a-com-istream">FUNCTION: StreamSave
REMARKS:
	Saves this CStdString object to a COM IStream.</a>
      </div>

      <div class="heading h2">
        <a href="#function-streamload-remarks-this-method-loads-the-object-from-an-istream">FUNCTION: StreamLoad
REMARKS:
	This method loads the object from an IStream.</a>
      </div>

      <div class="heading h1">
        <a href="#end-of-cstdstr-inline-function-definitions">=============================================================================
					END OF CStdStr INLINE FUNCTION DEFINITIONS</a>
      </div>

      <div class="heading h2">
        <a href="#cstdstr-addition-functions-defined-as-inline">CStdStr addition functions defined as inline</a>
      </div>

      <div class="heading h2">
        <a href="#remarks-this-function-allows-the-caller-for-format-and-return-a-cstdstringa-object-with-a-single-line-of-code">REMARKS:
	This function allows the caller for format and return a CStdStringA
	object with a single line of code.</a>
      </div>

      <div class="heading h2">
        <a href="#return-value-a-cstdstringa-equivalent-of-the-error-code.currently-this-function-only-returns-either-english-of-the-system-default-language-strings">RETURN VALUE:
a CStdStringA equivalent of the error code.  Currently, this function
only returns either English of the system default language strings.</a>
      </div>

      <div class="heading h2">
        <a href="#functional-comparators-remarks-these-structs-are-derived-from-the-std-binary_function-template.they-give-us-functional-classes-which-may-be-used-in-standard-c++-library-collections-and-algorithms-that-perform-case-insensitive-comparisons-of-cstdstring-objects.this-is-useful-for-maps-in-which-the-key-may-be-the-proper-string-but-in-the-wrong-case">FUNCTIONAL COMPARATORS:
REMARKS:
	These structs are derived from the std::binary_function template.  They
	give us functional classes (which may be used in Standard C++ Library
	collections and algorithms) that perform case-insensitive comparisons of
	CStdString objects.  This is useful for maps in which the key may be the
	 proper string but in the wrong case.</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
    
      <tr>
        <td class="docs">
          <p>=============================================================================
FILE:  StdString.h
AUTHOR:	Joe O'Leary (with outside help noted in comments)</p>
<pre><code>If you find any bugs in this code, please let me know:

		jmoleary@earthlink.net
		http://www.joeo.net/stdstring.htm (a bit outdated)

 The latest version of this code should always be available at the
 following link:

         http://www.joeo.net/code/StdString.zip (Dec 6, 2003)
</code></pre>
<p>REMARKS:
	This header file declares the CStdStr template.  This template derives
	the Standard C++ Library basic_string&lt;&gt; template and add to it the
	the following conveniences:
		- The full MFC CString set of functions (including implicit cast)
		- writing to/reading from COM IStream interfaces
		- Functional objects for use in STL algorithms</p>
<pre><code>From this template, we intstantiate two classes:  CStdStringA and
CStdStringW.  The name &quot;CStdString&quot; is just a #define of one of these,
based upone the UNICODE macro setting

This header also declares our own version of the MFC/ATL UNICODE-MBCS
conversion macros.  Our version looks exactly like the Microsoft's to
facilitate portability.
</code></pre>
<p>NOTE:
	If you you use this in an MFC or ATL build, you should include either
	afx.h or atlbase.h first, as appropriate.</p>
<p>PEOPLE WHO HAVE CONTRIBUTED TO THIS CLASS:</p>
<pre><code>Several people have helped me iron out problems and othewise improve
this class.  OK, this is a long list but in my own defense, this code
has undergone two major rewrites.  Many of the improvements became
necessary after I rewrote the code as a template.  Others helped me
improve the CString facade.

Anyway, these people are (in chronological order):

	- Pete the Plumber (???)
	- Julian Selman
	- Chris (of Melbsys)
	- Dave Plummer
	- John C Sipos
	- Chris Sells
	- Nigel Nunn
	- Fan Xia
	- Matthew Williams
	- Carl Engman
	- Mark Zeren
	- Craig Watson
	- Rich Zuris
	- Karim Ratib
	- Chris Conti
	- Baptiste Lepilleur
	- Greg Pickles
	- Jim Cline
	- Jeff Kohn
	- Todd Heckel
	- Ullrich Pollähne
	- Joe Vitaterna
	- Joe Woodbury
	- Aaron (no last name)
	- Joldakowski (???)
	- Scott Hathaway
	- Eric Nitzche
	- Pablo Presedo
	- Farrokh Nejadlotfi
	- Jason Mills
	- Igor Kholodov
	- Mike Crusader
	- John James
	- Wang Haifeng
	- Tim Dowty
     - Arnt Witteveen
     - Glen Maynard
     - Paul DeMarco
     - Bagira (full name?)
     - Ronny Schulz
     - Jakko Van Hunen
	- Charles Godwin
	- Henk Demper
	- Greg Marr
	- Bill Carducci
	- Brian Groose
	- MKingman
	- Don Beusee
</code></pre>
<p>REVISION HISTORY</p>
<p>2005-JAN-10 - Thanks to Don Beusee for pointing out the danger in mapping
				length-checked formatting functions to non-length-checked
				CRT equivalents.  Also thanks to him for motivating me to
				optimize my implementation of Replace()</p>
<p>2004-APR-22 - A big, big thank you to &quot;MKingman&quot; (whoever you are) for
				finally spotting a silly little error in StdCodeCvt that
				has been causing me (and users of CStdString) problems for
				years in some relatively rare conversions.  I had reversed
				two length arguments.</p>
<p>2003-NOV-24 - Thanks to a bunch of people for helping me clean up many
				compiler warnings (and yes, even a couple of actual compiler
				errors).  These include Henk Demper for figuring out how
				to make the Intellisense work on with CStdString on VC6,
				something I was never able to do.  Greg Marr pointed out
				a compiler warning about an unreferenced symbol and a
				problem with my version of Load in MFC builds.  Bill
				Carducci took a lot of time with me to help me figure out
				why some implementations of the Standard C++ Library were
				returning error codes for apparently successful conversions
				between ASCII and UNICODE.  Finally thanks to Brian Groose
				for helping me fix compiler signed unsigned warnings in
				several functions.</p>
<p>2003-JUL-10 - Thanks to Charles Godwin for making me realize my 'FmtArg'
				fixes had inadvertently broken the DLL-export code (which is
normally commented out.  I had to move it up higher.  Also
				this helped me catch a bug in ssicoll that would prevent
compilation, otherwise.</p>
<p>2003-MAR-14 - Thanks to Jakko Van Hunen for pointing out a copy-and-paste
bug in one of the overloads of FmtArg.</p>
<p>2003-MAR-10 - Thanks to Ronny Schulz for (twice!) sending me some changes
to help CStdString build on SGI and for pointing out an
error in placement of my preprocessor macros for ssfmtmsg.</p>
<p>2002-NOV-26 - Thanks to Bagira for pointing out that my implementation of
SpanExcluding was not properly handling the case in which
the string did NOT contain any of the given characters</p>
<p>2002-OCT-21 - Many thanks to Paul DeMarco who was invaluable in helping me
get this code working with Borland's free compiler as well
as the Dev-C++ compiler (available free at SourceForge).</p>
<p>2002-SEP-13 - Thanks to Glen Maynard who helped me get rid of some loud
but harmless warnings that were showing up on g++.  Glen
also pointed out that some pre-declarations of FmtArg&lt;&gt;
specializations were unnecessary (and no good on G++)</p>
<p>2002-JUN-26 - Thanks to Arnt Witteveen for pointing out that I was using
static_cast&lt;&gt; in a place in which I should have been using
reinterpret_cast&lt;&gt; (the ctor for unsigned char strings).
That's what happens when I don't unit-test properly!
Arnt also noticed that CString was silently correcting the
'nCount' argument to Left() and Right() where CStdString was
not (and crashing if it was bad).  That is also now fixed!</p>
<p>2002-FEB-25 - Thanks to Tim Dowty for pointing out (and giving me the fix
				for) a conversion problem with non-ASCII MBCS characters.
				CStdString is now used in my favorite commercial MP3 player!</p>
<p>2001-DEC-06 - Thanks to Wang Haifeng for spotting a problem in one of the
				assignment operators (for _bstr_t) that would cause compiler
				errors when refcounting protection was turned off.</p>
<p>2001-NOV-27 - Remove calls to operator!= which involve reverse_iterators
				due to a conflict with the rel_ops operator!=.  Thanks to
				John James for pointing this out.</p>
<p>2001-OCT-29 - Added a minor range checking fix for the Mid function to
				make it as forgiving as CString's version is.  Thanks to
				Igor Kholodov for noticing this.<br>
			  - Added a specialization of std::swap for CStdString.  Thanks
				to Mike Crusader for suggesting this!  It's commented out
				because you're not supposed to inject your own code into the
				'std' namespace.  But if you don't care about that, it's
				there if you want it
			  - Thanks to Jason Mills for catching a case where CString was
				more forgiving in the Delete() function than I was.</p>
<p>2001-JUN-06 - I was violating the Standard name lookup rules stated
				in [14.6.2(3)].  None of the compilers I've tried so
				far apparently caught this but HP-UX aCC 3.30 did.  The
				fix was to add 'this-&gt;' prefixes in many places.
				Thanks to Farrokh Nejadlotfi for this!</p>
<p>2001-APR-27 - StreamLoad was calculating the number of BYTES in one
				case, not characters.  Thanks to Pablo Presedo for this.</p>
<p>2001-FEB-23 - Replace() had a bug which caused infinite loops if the
				source string was empty.  Fixed thanks to Eric Nitzsche.</p>
<p>2001-FEB-23 - Scott Hathaway was a huge help in providing me with the
				ability to build CStdString on Sun Unix systems.  He
				sent me detailed build reports about what works and what
				does not.  If CStdString compiles on your Unix box, you
				can thank Scott for it.</p>
<p>2000-DEC-29 - Joldakowski noticed one overload of Insert failed to do a
				range check as CString's does.  Now fixed -- thanks!</p>
<p>2000-NOV-07 - Aaron pointed out that I was calling static member
				functions of char_traits via a temporary.  This was not
				technically wrong, but it was unnecessary and caused
				problems for poor old buggy VC5.  Thanks Aaron!</p>
<p>2000-JUL-11 - Joe Woodbury noted that the CString::Find docs don't match
				what the CString::Find code really ends up doing.   I was
				trying to match the docs.  Now I match the CString code
			  - Joe also caught me truncating strings for GetBuffer() calls
				when the supplied length was less than the current length.</p>
<p>2000-MAY-25 - Better support for STLPORT's Standard library distribution
			  - Got rid of the NSP macro - it interfered with Koenig lookup
			  - Thanks to Joe Woodbury for catching a TrimLeft() bug that
				I introduced in January.  Empty strings were not getting
				trimmed</p>
<p>2000-APR-17 - Thanks to Joe Vitaterna for pointing out that ReverseFind
				is supposed to be a const function.</p>
<p>2000-MAR-07 - Thanks to Ullrich Pollähne for catching a range bug in one
				of the overloads of assign.</p>
<p>2000-FEB-01 - You can now use CStdString on the Mac with CodeWarrior!
				Thanks to Todd Heckel for helping out with this.</p>
<p>2000-JAN-23 - Thanks to Jim Cline for pointing out how I could make the
				Trim() function more efficient.
			  - Thanks to Jeff Kohn for prompting me to find and fix a typo
				in one of the addition operators that takes _bstr_t.
			  - Got rid of the .CPP file -  you only need StdString.h now!</p>
<p>1999-DEC-22 - Thanks to Greg Pickles for helping me identify a problem
				with my implementation of CStdString::FormatV in which
				resulting string might not be properly NULL terminated.</p>
<p>1999-DEC-06 - Chris Conti pointed yet another basic_string&lt;&gt; assignment
				bug that MS has not fixed.  CStdString did nothing to fix
				it either but it does now!  The bug was: create a string
				longer than 31 characters, get a pointer to it (via c_str())
				and then assign that pointer to the original string object.
				The resulting string would be empty.  Not with CStdString!</p>
<p>1999-OCT-06 - BufferSet was erasing the string even when it was merely
				supposed to shrink it.  Fixed.  Thanks to Chris Conti.
			  - Some of the Q172398 fixes were not checking for assignment-
				to-self.  Fixed.  Thanks to Baptiste Lepilleur.</p>
<p>1999-AUG-20 - Improved Load() function to be more efficient by using
				SizeOfResource().  Thanks to Rich Zuris for this.
			  - Corrected resource ID constructor, again thanks to Rich.
			  - Fixed a bug that occurred with UNICODE characters above
				the first 255 ANSI ones.  Thanks to Craig Watson.
			  - Added missing overloads of TrimLeft() and TrimRight().
				Thanks to Karim Ratib for pointing them out</p>
<p>1999-JUL-21 - Made all calls to GetBuf() with no info check length first.</p>
<p>1999-JUL-10 - Improved MFC/ATL independence of conversion macros
			  - Added SS_NO_REFCOUNT macro to allow you to disable any
				reference-counting your basic_string&lt;&gt; impl. may do.
			  - Improved ReleaseBuffer() to be as forgiving as CString.
				Thanks for Fan Xia for helping me find this and to
				Matthew Williams for pointing it out directly.</p>
<p>1999-JUL-06 - Thanks to Nigel Nunn for catching a very sneaky bug in
				ToLower/ToUpper.  They should call GetBuf() instead of
				data() in order to ensure the changed string buffer is not
				reference-counted (in those implementations that refcount).</p>
<p>1999-JUL-01 - Added a true CString facade.  Now you can use CStdString as
				a drop-in replacement for CString.  If you find this useful,
				you can thank Chris Sells for finally convincing me to give
				in and implement it.
			  - Changed operators &lt;&lt; and &gt;&gt; (for MFC CArchive) to serialize
				EXACTLY as CString's do.  So now you can send a CString out
				to a CArchive and later read it in as a CStdString.   I have
				no idea why you would want to do this but you can.</p>
<p>1999-JUN-21 - Changed the CStdString class into the CStdStr template.
			  - Fixed FormatV() to correctly decrement the loop counter.
				This was harmless bug but a bug nevertheless.  Thanks to
				Chris (of Melbsys) for pointing it out
			  - Changed Format() to try a normal stack-based array before
				using to _alloca().
			  - Updated the text conversion macros to properly use code
				pages and to fit in better in MFC/ATL builds.  In other
				words, I copied Microsoft's conversion stuff again.
			  - Added equivalents of CString::GetBuffer, GetBufferSetLength
			  - new sscpy() replacement of CStdString::CopyString()
			  - a Trim() function that combines TrimRight() and TrimLeft().</p>
<p>1999-MAR-13 - Corrected the &quot;NotSpace&quot; functional object to use _istpace()
				instead of _isspace()   Thanks to Dave Plummer for this.</p>
<p>1999-FEB-26 - Removed errant line (left over from testing) that #defined
				_MFC_VER.  Thanks to John C Sipos for noticing this.</p>
<p>1999-FEB-03 - Fixed a bug in a rarely-used overload of operator+() that
				caused infinite recursion and stack overflow
			  - Added member functions to simplify the process of
				persisting CStdStrings to/from DCOM IStream interfaces
			  - Added functional objects (e.g. StdStringLessNoCase) that
				allow CStdStrings to be used as keys STL map objects with
				case-insensitive comparison
			  - Added array indexing operators (i.e. operator[]).  I
				originally assumed that these were unnecessary and would be
				inherited from basic_string.  However, without them, Visual
				C++ complains about ambiguous overloads when you try to use
				them.  Thanks to Julian Selman to pointing this out.</p>
<p>1998-FEB-?? - Added overloads of assign() function to completely account
				for Q172398 bug.  Thanks to &quot;Pete the Plumber&quot; for this</p>
<p>1998-FEB-?? - Initial submission</p>
<div class="pilwrap" id="copyright-2002-joseph-m.oleary.this-code-is-100-free.use-it-anywhere-you-want.rewrite-it-restructure-it-whatever.if-you-can-write-software-that-makes-money-off-of-it-good-for-you.i-kinda-like-capitalism.please-dont-blame-me-if-it-causes-your-dollar30-billion-dollar-satellite-explode-in-orbit.if-you-redistribute-it-in-any-form-id-appreciate-it-if-you-would-leave-this-notice-here">
  <h1>
    <a href="#copyright-2002-joseph-m.oleary.this-code-is-100-free.use-it-anywhere-you-want.rewrite-it-restructure-it-whatever.if-you-can-write-software-that-makes-money-off-of-it-good-for-you.i-kinda-like-capitalism.please-dont-blame-me-if-it-causes-your-dollar30-billion-dollar-satellite-explode-in-orbit.if-you-redistribute-it-in-any-form-id-appreciate-it-if-you-would-leave-this-notice-here" name="copyright-2002-joseph-m.oleary.this-code-is-100-free.use-it-anywhere-you-want.rewrite-it-restructure-it-whatever.if-you-can-write-software-that-makes-money-off-of-it-good-for-you.i-kinda-like-capitalism.please-dont-blame-me-if-it-causes-your-dollar30-billion-dollar-satellite-explode-in-orbit.if-you-redistribute-it-in-any-form-id-appreciate-it-if-you-would-leave-this-notice-here" class="pilcrow"></a>
COPYRIGHT:
	2002 Joseph M. O'Leary.  This code is 100% free.  Use it anywhere you
want.  Rewrite it, restructure it, whatever.  If you can write software
that makes money off of it, good for you.  I kinda like capitalism.
Please don't blame me if it causes your $30 billion dollar satellite
explode in orbit.  If you redistribute it in any form, I'd appreciate it
if you would leave this notice here.
  </h1>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Avoid multiple inclusion</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> STDSTRING_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STDSTRING_H</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>When using VC, turn off browser references
Turn off unavoidable compiler warnings</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt; 1100)</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> component(browser, off, references, <span class="hljs-meta-string">"CStdString"</span>)</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span> (disable : 4290) <span class="hljs-comment">// C++ Exception Specification ignored</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span> (disable : 4127) <span class="hljs-comment">// Conditional expression is constant</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span> (disable : 4097) <span class="hljs-comment">// typedef name used as synonym for class name</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>Borland warnings to turn off</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __BORLANDC__</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> option push -w-inl</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>#pragma warn -inl   // Turn off inline function warnings</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="ss_is_intresource">
  <h2>
    <a href="#ss_is_intresource" name="ss_is_intresource" class="pilcrow"></a>
SS_IS_INTRESOURCE
  </h2>
</div>
<pre><code>A copy of IS_INTRESOURCE from VC7.  Because old VC6 version of winuser.h
doesn't have this.
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_IS_INTRESOURCE(_r) (false)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined (SS_ANSI) &amp;&amp; defined(_MSC_VER)</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> SS_IS_INTRESOURCE</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_WIN64)</span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_IS_INTRESOURCE(_r) (((unsigned __int64)(_r) &gt;&gt; 16) == 0)</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_IS_INTRESOURCE(_r) (((unsigned long)(_r) &gt;&gt; 16) == 0)</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="macro-ss_unsigned">
  <h2>
    <a href="#macro-ss_unsigned" name="macro-ss_unsigned" class="pilcrow"></a>
MACRO: SS_UNSIGNED
  </h2>
</div>
<pre><code> This macro causes the addition of a constructor and assignment operator
 which take unsigned characters.  CString has such functions and in order
 to provide maximum CString-compatability, this code needs them as well.
 In practice you will likely never need these functions...
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>#define SS_UNSIGNED</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_ALLOW_UNSIGNED_CHARS</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_UNSIGNED</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="macro-ss_safe_format">
  <h2>
    <a href="#macro-ss_safe_format" name="macro-ss_safe_format" class="pilcrow"></a>
MACRO: SS_SAFE_FORMAT
  </h2>
</div>
<pre><code> This macro provides limited compatability with a questionable CString
 &quot;feature&quot;.  You can define it in order to avoid a common problem that
 people encounter when switching from CString to CStdString.

 To illustrate the problem -- With CString, you can do this:

     CString sName(&quot;Joe&quot;);
     CString sTmp;
     sTmp.Format(&quot;My name is %s&quot;, sName);                    // WORKS!

 However if you were to try this with CStdString, your program would
 crash.

     CStdString sName(&quot;Joe&quot;);
     CStdString sTmp;
     sTmp.Format(&quot;My name is %s&quot;, sName);                    // CRASHES!

 You must explicitly call c_str() or cast the object to the proper type

     sTmp.Format(&quot;My name is %s&quot;, sName.c_str());            // WORKS!
     sTmp.Format(&quot;My name is %s&quot;, static_cast&lt;PCSTR&gt;(sName));// WORKS!
     sTmp.Format(&quot;My name is %s&quot;, (PCSTR)sName);				// WORKS!

 This is because it is illegal to pass anything but a POD type as a
 variadic argument to a variadic function (i.e. as one of the &quot;...&quot;
 arguments).  The type const char* is a POD type.  The type CStdString
 is not.  Of course, neither is the type CString, but CString lets you do
 it anyway due to the way they laid out the class in binary.  I have no
 control over this in CStdString since I derive from whatever
 implementation of basic_string is available.

 However if you have legacy code (which does this) that you want to take
 out of the MFC world and you don't want to rewrite all your calls to
 Format(), then you can define this flag and it will no longer crash.

 Note however that this ONLY works for Format(), not sprintf, fprintf, 
 etc.  If you pass a CStdString object to one of those functions, your
 program will crash.  Not much I can do to get around this, short of
 writing substitutes for those functions as well.
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_SAFE_FORMAT  <span class="hljs-comment">// use new template style Format() function</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="macro-ss_no_implicit_cast">
  <h2>
    <a href="#macro-ss_no_implicit_cast" name="macro-ss_no_implicit_cast" class="pilcrow"></a>
MACRO: SS_NO_IMPLICIT_CAST
  </h2>
</div>
<pre><code> Some people don't like the implicit cast to const char* (or rather to
 const CT*) that CStdString (and MFC's CString) provide.  That was the
 whole reason I created this class in the first place, but hey, whatever
 bakes your cake.  Just #define this macro to get rid of the the implicit
 cast.
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>#define SS_NO_IMPLICIT_CAST // gets rid of operator const CT*()</p>

        </td>
        <td class="code highlight">
          <pre class="c">

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="macro-ss_no_refcount">
  <h2>
    <a href="#macro-ss_no_refcount" name="macro-ss_no_refcount" class="pilcrow"></a>
MACRO: SS_NO_REFCOUNT
  </h2>
</div>
<pre><code>turns off reference counting at the assignment level.  Only needed
for the version of basic_string&lt;&gt; that comes with Visual C++ versions
6.0 or earlier, and only then in some heavily multithreaded scenarios.
Uncomment it if you feel you need it.
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>#define SS_NO_REFCOUNT</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="macro-ss_win32">
  <h2>
    <a href="#macro-ss_win32" name="macro-ss_win32" class="pilcrow"></a>
MACRO: SS_WIN32
  </h2>
</div>
<pre><code> When this flag is set, we are building code for the Win32 platform and
 may use Win32 specific functions (such as LoadString).  This gives us
 a couple of nice extras for the code.

 Obviously, Microsoft's is not the only compiler available for Win32 out
 there.  So I can't just check to see if _MSC_VER is defined to detect
 if I'm building on Win32.  So for now, if you use MS Visual C++ or
 Borland's compiler, I turn this on.  Otherwise you may turn it on
 yourself, if you prefer
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WIN32)</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_WIN32</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="macro-ss_ansi">
  <h2>
    <a href="#macro-ss_ansi" name="macro-ss_ansi" class="pilcrow"></a>
MACRO: SS_ANSI
  </h2>
</div>
<pre><code> When this macro is defined, the code attempts only to use ANSI/ISO
 standard library functions to do it's work.  It will NOT attempt to use
 any Win32 of Visual C++ specific functions -- even if they are
 available.  You may define this flag yourself to prevent any Win32
 of VC++ specific functions from being called. 
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>If we're not on Win32, we MUST use an ANSI build</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_WIN32</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(SS_NO_ANSI)</span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_ANSI</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="macro-ss_alloca">
  <h2>
    <a href="#macro-ss_alloca" name="macro-ss_alloca" class="pilcrow"></a>
MACRO: SS_ALLOCA
  </h2>
</div>
<pre><code> Some implementations of the Standard C Library have a non-standard
 function known as alloca().  This functions allows one to allocate a
 variable amount of memory on the stack.  It is needed to implement
 the ASCII/MBCS conversion macros.

 I wanted to find some way to determine automatically if alloca() is
available on this platform via compiler flags but that is asking for
trouble.  The crude test presented here will likely need fixing on
other platforms.  Therefore I'll leave it up to you to fiddle with
this test to determine if it exists.  Just make sure SS_ALLOCA is or
is not defined as appropriate and you control this feature.
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_MSC_VER) &amp;&amp; !defined(SS_ANSI)</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_ALLOCA</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="macro-ss_mbcs">
  <h2>
    <a href="#macro-ss_mbcs" name="macro-ss_mbcs" class="pilcrow"></a>
MACRO: SS_MBCS
  </h2>
</div>
<pre><code>Setting this macro means you are using MBCS characters.  In MSVC builds,
this macro gets set automatically by detection of the preprocessor flag
_MBCS.  For other platforms you may set it manually if you wish.  The
only effect it currently has is to cause the allocation of more space
for wchar_t --&gt; char conversions.
Note that MBCS does not mean UNICODE.
</code></pre>
<p>#define SS_MBCS</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MBCS</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_MBCS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="macro-ss_no_locale">
  <h2>
    <a href="#macro-ss_no_locale" name="macro-ss_no_locale" class="pilcrow"></a>
MACRO SS_NO_LOCALE
  </h2>
</div>
<p>If your implementation of the Standard C++ Library lacks the <locale> header,
you can #define this macro to make your code build properly.  Note that this
is some of my newest code and frankly I'm not very sure of it, though it does
pass my unit tests.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>#define SS_NO_LOCALE</p>

        </td>
        <td class="code highlight">
          <pre class="c">

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="compiler-error-regarding-_unicode-and-unicode">
  <h2>
    <a href="#compiler-error-regarding-_unicode-and-unicode" name="compiler-error-regarding-_unicode-and-unicode" class="pilcrow"></a>
Compiler Error regarding _UNICODE and UNICODE
  </h2>
</div>
<p>Microsoft header files are screwy.  Sometimes they depend on a preprocessor
flag named &quot;_UNICODE&quot;.  Other times they check &quot;UNICODE&quot; (note the lack of
leading underscore in the second version&quot;.  In several places, they silently
&quot;synchronize&quot; these two flags this by defining one of the other was defined.
In older version of this header, I used to try to do the same thing.</p>
<p>However experience has taught me that this is a bad idea.  You get weird
compiler errors that seem to indicate things like LPWSTR and LPTSTR not being
equivalent in UNICODE builds, stuff like that (when they MUST be in a proper
UNICODE  build).  You end up scratching your head and saying, &quot;But that HAS
to compile!&quot;.</p>
<p>So what should you do if you get this error?</p>
<p>Make sure that both macros (_UNICODE and UNICODE) are defined before this
file is included.  You can do that by either</p>
<pre><code>a) defining both yourself before any files get included
b) including the proper MS headers in the proper order
c) including this file before any other file, uncommenting
   the #defines below, and commenting out the #errors
</code></pre>
<p>Personally I recommend solution a) but it's your call.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (_UNICODE) &amp;&amp; !defined (UNICODE)</span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">error</span> UNICODE defined  but not UNICODE</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>#define UNICODE  // no longer silently fix this</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (UNICODE) &amp;&amp; !defined (_UNICODE)</span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">error</span> Warning, UNICODE defined  but not _UNICODE</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>#define _UNICODE  // no longer silently fix this</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="min-and-max.the-standard-c++-template-versions-go-by-so-many-names-at-at-least-in-the-ms-implementation-that-you-never-know-whats-available">
  <h2>
    <a href="#min-and-max.the-standard-c++-template-versions-go-by-so-many-names-at-at-least-in-the-ms-implementation-that-you-never-know-whats-available" name="min-and-max.the-standard-c++-template-versions-go-by-so-many-names-at-at-least-in-the-ms-implementation-that-you-never-know-whats-available" class="pilcrow"></a>
MIN and MAX.  The Standard C++ template versions go by so many names (at
at least in the MS implementation) that you never know what's available
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Type&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> Type&amp; <span class="hljs-title">SSMIN</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type&amp; arg1, <span class="hljs-keyword">const</span> Type&amp; arg2)</span>
</span>{
	<span class="hljs-keyword">return</span> arg2 &lt; arg1 ? arg2 : arg1;
}
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Type&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> Type&amp; <span class="hljs-title">SSMAX</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type&amp; arg1, <span class="hljs-keyword">const</span> Type&amp; arg2)</span>
</span>{
	<span class="hljs-keyword">return</span> arg2 &gt; arg1 ? arg2 : arg1;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>If they have not #included W32Base.h (part of my W32 utility library) then
we need to define some stuff.  Otherwise, this is all defined there.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(W32BASE_H)</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>If they want us to use only standard C++ stuff (no Win32 stuff)</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_ANSI</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>On Win32 we have TCHAR.H so just include it.  This is NOT violating
the spirit of SS_ANSI as we are not calling any Win32 functions here.</p>

        </td>
        <td class="code highlight">
          <pre class="c">        
		<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_WIN32</span>

			<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;TCHAR.H&gt;</span></span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;WTYPES.H&gt;</span></span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> STRICT</span>
				<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRICT</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>... but on non-Win32 platforms, we must #define the types we need.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>

			<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*		PCSTR;
			<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span>*			PSTR;
			<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">wchar_t</span>*	PCWSTR;
			<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">wchar_t</span>*		PWSTR;
			<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> UNICODE</span>
				<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">wchar_t</span>		TCHAR;
			<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
				<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span>		TCHAR;
			<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
			<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">wchar_t</span>			OLECHAR;

		<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>	<span class="hljs-comment">// #ifndef _WIN32</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>Make sure ASSERT and verify are defined using only ANSI stuff</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ASSERT</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ASSERT(f) assert((f))</span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> VERIFY</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _DEBUG</span>
				<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERIFY(x) ASSERT((x))</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
				<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERIFY(x) x</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> <span class="hljs-comment">// ...else SS_ANSI is NOT defined</span></span>

		<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;TCHAR.H&gt;</span></span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;WTYPES.H&gt;</span></span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> STRICT</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRICT</span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>Make sure ASSERT and verify are defined</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ASSERT</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;crtdbg.h&gt;</span></span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ASSERT(f) _ASSERTE((f))</span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> VERIFY</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _DEBUG</span>
				<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERIFY(x) ASSERT((x))</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
				<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERIFY(x) x</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifdef SS_ANSI</span></span>

	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> UNUSED</span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNUSED(x) x</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifndef W32BASE_H</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>Standard headers needed</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span>			<span class="hljs-comment">// basic_string</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span>		<span class="hljs-comment">// for_each, etc.</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span>		<span class="hljs-comment">// for StdStringLessNoCase, et al</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_NO_LOCALE</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;locale&gt;</span>			<span class="hljs-comment">// for various facets</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>If this is a recent enough version of VC include comdef.h, so we can write
member functions to deal with COM types &amp; compiler support classes e.g.
_bstr_t</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1100)</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;comdef.h&gt;</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_INC_COMDEF		<span class="hljs-comment">// signal that we #included MS comdef.h file</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STDSTRING_INC_COMDEF</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_NOTHROW __declspec(nothrow)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_NOTHROW</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> TRACE</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRACE_DEFINED_HERE</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRACE</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>Microsoft defines PCSTR, PCWSTR, etc, but no PCTSTR.  I hate to use the
versions with the &quot;L&quot; in front of them because that's a leftover from Win 16
days, even though it evaluates to the same thing.  Therefore, Define a PCSTR
as an LPCTSTR.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(PCTSTR) &amp;&amp; !defined(PCTSTR_DEFINED)</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> TCHAR*			PCTSTR;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PCTSTR_DEFINED</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(PCOLESTR) &amp;&amp; !defined(PCOLESTR_DEFINED)</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> OLECHAR*			PCOLESTR;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PCOLESTR_DEFINED</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(POLESTR) &amp;&amp; !defined(POLESTR_DEFINED)</span>
	<span class="hljs-keyword">typedef</span> OLECHAR*				POLESTR;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLESTR_DEFINED</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(PCUSTR) &amp;&amp; !defined(PCUSTR_DEFINED)</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*	PCUSTR;
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*			PUSTR;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PCUSTR_DEFINED</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>SGI compiler 7.3 doesnt know these  types - oh and btw, remember to use
-LANG:std in the CXX Flags</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__sgi)</span>
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>           DWORD;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> *                  LPCVOID;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<p>SS_USE_FACET macro and why we need it:</p>
<p>Since I'm a good little Standard C++ programmer, I use locales.  Thus, I
need to make use of the use_facet&lt;&gt; template function here.   Unfortunately,
this need is complicated by the fact the MS' implementation of the Standard
C++ Library has a non-standard version of use_facet that takes more
arguments than the standard dictates.  Since I'm trying to write CStdString
to work with any version of the Standard library, this presents a problem.</p>
<p>The upshot of this is that I can't do 'use_facet' directly.  The MS' docs
tell me that I have to use a macro, _USE() instead.  Since _USE obviously
won't be available in other implementations, this means that I have to write
my OWN macro -- SS_USE_FACET -- that evaluates either to _USE or to the
standard, use_facet.</p>
<p>If you are having trouble with the SS_USE_FACET macro, in your implementation
of the Standard C++ Library, you can define your own version of SS_USE_FACET.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> schMSG</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> schSTR(x)	   #x</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> schSTR2(x)	schSTR(x)</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> schMSG(desc) message(__FILE__ <span class="hljs-meta-string">"("</span> schSTR2(__LINE__) <span class="hljs-meta-string">"):"</span> #desc)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_USE_FACET</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<p>STLPort #defines a macro (__STL_NO_EXPLICIT_FUNCTION_TMPL_ARGS) for
all MSVC builds, erroneously in my opinion.  It causes problems for
my SS_ANSI builds.  In my code, I always comment out that line.  You'll
find it in   \stlport\config\stl_msvc.h</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__SGI_STL_PORT) &amp;&amp; (__SGI_STL_PORT &gt;= 0x400 )</span>

		<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__STL_NO_EXPLICIT_FUNCTION_TMPL_ARGS) &amp;&amp; defined(_MSC_VER)</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_ANSI</span>
				<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> schMSG(__STL_NO_EXPLICIT_FUNCTION_TMPL_ARGS defined!!)</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
		<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_USE_FACET(loc, fac) std::use_facet<span class="hljs-meta-string">&lt;fac &gt;</span>(loc)</span>

	<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(_MSC_VER )</span>

		<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_USE_FACET(loc, fac) std::_USE(loc, fac)</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<p>...and</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE)</span>

        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_USE_FACET(loc, fac) std::use_facet(loc, (fac*)0)</span>

	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>

		<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_USE_FACET(loc, fac) std::use_facet<span class="hljs-meta-string">&lt;fac &gt;</span>(loc)</span>

	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="unicodembcs-conversion-macros.made-to-work-just-like-the-mfcatl-ones">
  <h1>
    <a href="#unicodembcs-conversion-macros.made-to-work-just-like-the-mfcatl-ones" name="unicodembcs-conversion-macros.made-to-work-just-like-the-mfcatl-ones" class="pilcrow"></a>
=============================================================================
UNICODE/MBCS conversion macros.  Made to work just like the MFC/ATL ones.
  </h1>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;wchar.h&gt;</span>      <span class="hljs-comment">// Added to Std Library with Amendment #1.</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>First define the conversion helper functions.  We define these regardless of
any preprocessor macro settings since their names won't collide.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<p>Not sure if we need all these headers.   I believe ANSI says we do.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;wctype.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> va_start</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;varargs.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_NO_LOCALE</span>

	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_WIN32) || defined (_WIN32_WCE)</span>

		<span class="hljs-function"><span class="hljs-keyword">inline</span> PWSTR <span class="hljs-title">StdCodeCvt</span><span class="hljs-params">(PWSTR pDstW, <span class="hljs-keyword">int</span> nDst, PCSTR pSrcA, <span class="hljs-keyword">int</span> nSrc, 
			UINT acp=CP_ACP)</span>
		</span>{
			ASSERT(<span class="hljs-number">0</span> != pSrcA);
			ASSERT(<span class="hljs-number">0</span> != pDstW);
			pDstW[<span class="hljs-number">0</span>] = <span class="hljs-string">'\0'</span>;
			MultiByteToWideChar(acp, <span class="hljs-number">0</span>, pSrcA, nSrc, pDstW, nDst);
			<span class="hljs-keyword">return</span> pDstW;
		}
		<span class="hljs-function"><span class="hljs-keyword">inline</span> PWSTR <span class="hljs-title">StdCodeCvt</span><span class="hljs-params">(PWSTR pDstW, <span class="hljs-keyword">int</span> nDst, PCUSTR pSrcA, <span class="hljs-keyword">int</span> nSrc, 
			UINT acp=CP_ACP)</span>
		</span>{
			<span class="hljs-keyword">return</span> StdCodeCvt(pDstW, nDst, (PCSTR)pSrcA, nSrc, acp);
		}

		<span class="hljs-function"><span class="hljs-keyword">inline</span> PSTR <span class="hljs-title">StdCodeCvt</span><span class="hljs-params">(PSTR pDstA, <span class="hljs-keyword">int</span> nDst, PCWSTR pSrcW, <span class="hljs-keyword">int</span> nSrc, 
			UINT acp=CP_ACP)</span>
		</span>{
			ASSERT(<span class="hljs-number">0</span> != pDstA);
			ASSERT(<span class="hljs-number">0</span> != pSrcW);
			pDstA[<span class="hljs-number">0</span>] = <span class="hljs-string">'\0'</span>;
			WideCharToMultiByte(acp, <span class="hljs-number">0</span>, pSrcW, nSrc, pDstA, nDst, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
			<span class="hljs-keyword">return</span> pDstA;
		}
		<span class="hljs-function"><span class="hljs-keyword">inline</span> PUSTR <span class="hljs-title">StdCodeCvt</span><span class="hljs-params">(PUSTR pDstA, <span class="hljs-keyword">int</span> nDst, PCWSTR pSrcW, <span class="hljs-keyword">int</span> nSrc, 
			UINT acp=CP_ACP)</span>
		</span>{
			<span class="hljs-keyword">return</span> (PUSTR)StdCodeCvt((PSTR)pDstA, nDst, pSrcW, nSrc, acp);
		}
	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<p>StdCodeCvt - made to look like Win32 functions WideCharToMultiByte
			and MultiByteToWideChar but uses locales in SS_ANSI
			builds.  There are a number of overloads.
First argument is the destination buffer.
Second argument is the source buffer
#if defined (SS_ANSI) || !defined (SS_WIN32)</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<p>'SSCodeCvt' - shorthand name for the codecvt facet we use</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	typedef std::codecvt&lt;wchar_t, char, mbstate_t&gt; SSCodeCvt;

	inline PWSTR StdCodeCvt(PWSTR pDstW, int nDst, PCSTR pSrcA, int nSrc,
		const std::locale&amp; loc=std::locale())
	{
		ASSERT(0 != pSrcA);
		ASSERT(0 != pDstW);

		pDstW[0]					= '\0';	

		if ( nSrc &gt; 0 )
		{
			PCSTR pNextSrcA			= pSrcA;
			PWSTR pNextDstW			= pDstW;
			const SSCodeCvt&amp; conv	= SS_USE_FACET(loc, SSCodeCvt);
			SSCodeCvt::state_type st= { 0 };
			SSCodeCvt::result res	= conv.in(st,
                                      pSrcA, pSrcA + nSrc, pNextSrcA,
                                      pDstW, pDstW + nDst, pNextDstW);

			ASSERT(SSCodeCvt::ok == res);
			ASSERT(SSCodeCvt::error != res);
			ASSERT(pNextDstW &gt;= pDstW);
			ASSERT(pNextSrcA &gt;= pSrcA);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<p>Null terminate the converted string</p>

        </td>
        <td class="code highlight">
          <pre class="c">
			if ( pNextDstW - pDstW &gt; nDst )
				*(pDstW + nDst) = '\0';
			else
				*pNextDstW = '\0';
		}
		return pDstW;
	}
	inline PWSTR StdCodeCvt(PWSTR pDstW, int nDst, PCUSTR pSrcA, int nSrc,
		const std::locale&amp; loc=std::locale())
	{
		return StdCodeCvt(pDstW, nDst, (PCSTR)pSrcA, nSrc, loc);
	}

	inline PSTR StdCodeCvt(PSTR pDstA, int nDst, PCWSTR pSrcW, int nSrc,
		const std::locale&amp; loc=std::locale())
	{
		ASSERT(0 != pDstA);
		ASSERT(0 != pSrcW);

		pDstA[0]					= '\0';	

		if ( nSrc &gt; 0 )
		{
			PSTR pNextDstA			= pDstA;
			PCWSTR pNextSrcW		= pSrcW;
			const SSCodeCvt&amp; conv	= SS_USE_FACET(loc, SSCodeCvt);
			SSCodeCvt::state_type st= { 0 };
			SSCodeCvt::result res	= conv.out(st,
                                       pSrcW, pSrcW + nSrc, pNextSrcW,
                                       pDstA, pDstA + nDst, pNextDstA);

			ASSERT(SSCodeCvt::error != res);
			ASSERT(SSCodeCvt::ok == res);	// strict, comment out for sanity
			ASSERT(pNextDstA &gt;= pDstA);
			ASSERT(pNextSrcW &gt;= pSrcW);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<p>Null terminate the converted string</p>

        </td>
        <td class="code highlight">
          <pre class="c">
			if ( pNextDstA - pDstA &gt; nDst )
				*(pDstA + nDst) = '\0';
			else
				*pNextDstA = '\0';
		}
		return pDstA;
	}

	inline PUSTR StdCodeCvt(PUSTR pDstA, int nDst, PCWSTR pSrcW, int nSrc,
		const std::locale&amp; loc=std::locale())
	{
		return (PUSTR)StdCodeCvt((PSTR)pDstA, nDst, pSrcW, nSrc, loc);
	}

#endif



</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<p>Unicode/MBCS conversion macros are only available on implementations of
the &quot;C&quot; library that have the non-standard _alloca function.  As far as I
know that's only Microsoft's though I've heard that the function exists
elsewhere.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(SS_ALLOCA) &amp;&amp; !defined SS_NO_CONVERSION</span>

    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span>	<span class="hljs-comment">// needed for _alloca</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<p>Define our conversion macros to look exactly like Microsoft's to
facilitate using this stuff both with and without MFC/ATL</p>

        </td>
        <td class="code highlight">
          <pre class="c">
    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _CONVERSION_USES_THREAD_LOCALE</span>

	    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _DEBUG</span>
		    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSCVT int _cvt; _cvt; UINT _acp=GetACP(); \
			    _acp; PCWSTR _pw; _pw; PCSTR _pa; _pa</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSCVT int _cvt = 0; _cvt; UINT _acp=GetACP();\
			     _acp; PCWSTR _pw=0; _pw; PCSTR _pa=0; _pa</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSA2W(pa) (\
		    ((_pa = pa) == 0) ? 0 : (\
			    _cvt = (sslen(_pa)),\
			    StdCodeCvt((PWSTR) _alloca((_cvt+1)*2), (_cvt+1)*2, \
							_pa, _cvt, _acp)))</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSW2A(pw) (\
		    ((_pw = pw) == 0) ? 0 : (\
			    _cvt = sslen(_pw), \
			    StdCodeCvt((LPSTR) _alloca((_cvt+1)*2), (_cvt+1)*2, \
					_pw, _cvt, _acp)))</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>

	    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _DEBUG</span>
		    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSCVT int _cvt; _cvt; UINT _acp=CP_ACP; _acp;\
			     PCWSTR _pw; _pw; PCSTR _pa; _pa</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSCVT int _cvt = 0; _cvt; UINT _acp=CP_ACP; \
			    _acp; PCWSTR _pw=0; _pw; PCSTR _pa=0; _pa</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSA2W(pa) (\
		    ((_pa = pa) == 0) ? 0 : (\
			    _cvt = (sslen(_pa)),\
			    StdCodeCvt((PWSTR) _alloca((_cvt+1)*2), (_cvt+1)*2, \
					_pa, _cvt)))</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSW2A(pw) (\
		    ((_pw = pw) == 0) ? 0 : (\
			    _cvt = (sslen(_pw)),\
			    StdCodeCvt((LPSTR) _alloca((_cvt+1)*2), (_cvt+1)*2, \
					_pw, _cvt)))</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSA2CW(pa) ((PCWSTR)SSA2W((pa)))</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSW2CA(pw) ((PCSTR)SSW2A((pw)))</span>

    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> UNICODE</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SST2A	SSW2A</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSA2T	SSA2W</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SST2CA	SSW2CA</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSA2CT	SSA2CW</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<p>(Did you get a compiler error here about not being able to convert
PTSTR into PWSTR?  Then your _UNICODE and UNICODE flags are messed
up.  Best bet: #define BOTH macros before including any MS headers.)</p>

        </td>
        <td class="code highlight">
          <pre class="c">	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PWSTR	<span class="hljs-title">SST2W</span><span class="hljs-params">(PTSTR p)</span>			</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PTSTR	<span class="hljs-title">SSW2T</span><span class="hljs-params">(PWSTR p)</span>			</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCWSTR	<span class="hljs-title">SST2CW</span><span class="hljs-params">(PCTSTR p)</span>		</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCTSTR	<span class="hljs-title">SSW2CT</span><span class="hljs-params">(PCWSTR p)</span>		</span>{ <span class="hljs-keyword">return</span> p; }
    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SST2W	SSA2W</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSW2T	SSW2A</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SST2CW	SSA2CW</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSW2CT	SSW2CA</span>
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PSTR		<span class="hljs-title">SST2A</span><span class="hljs-params">(PTSTR p)</span>			</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PTSTR	<span class="hljs-title">SSA2T</span><span class="hljs-params">(PSTR p)</span>			</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCSTR	<span class="hljs-title">SST2CA</span><span class="hljs-params">(PCTSTR p)</span>		</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCTSTR	<span class="hljs-title">SSA2CT</span><span class="hljs-params">(PCSTR p)</span>			</span>{ <span class="hljs-keyword">return</span> p; }
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifdef UNICODE</span></span>

    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(UNICODE)</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<p>in these cases the default (TCHAR) is the same as OLECHAR</p>

        </td>
        <td class="code highlight">
          <pre class="c">	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCOLESTR	<span class="hljs-title">SST2COLE</span><span class="hljs-params">(PCTSTR p)</span>		</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCTSTR	<span class="hljs-title">SSOLE2CT</span><span class="hljs-params">(PCOLESTR p)</span>	</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> POLESTR	<span class="hljs-title">SST2OLE</span><span class="hljs-params">(PTSTR p)</span>		</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PTSTR	<span class="hljs-title">SSOLE2T</span><span class="hljs-params">(POLESTR p)</span>		</span>{ <span class="hljs-keyword">return</span> p; }
    <span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(OLE2ANSI)</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-49" id="section-49"></a>
</div>
<p>in these cases the default (TCHAR) is the same as OLECHAR</p>

        </td>
        <td class="code highlight">
          <pre class="c">	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCOLESTR	<span class="hljs-title">SST2COLE</span><span class="hljs-params">(PCTSTR p)</span>		</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCTSTR	<span class="hljs-title">SSOLE2CT</span><span class="hljs-params">(PCOLESTR p)</span>	</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> POLESTR	<span class="hljs-title">SST2OLE</span><span class="hljs-params">(PTSTR p)</span>		</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PTSTR	<span class="hljs-title">SSOLE2T</span><span class="hljs-params">(POLESTR p)</span>		</span>{ <span class="hljs-keyword">return</span> p; }
    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-50" id="section-50"></a>
</div>
<p>CharNextW doesn't work on Win95 so we use this</p>

        </td>
        <td class="code highlight">
          <pre class="c">	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SST2COLE(pa)	SSA2CW((pa))</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SST2OLE(pa)		SSA2W((pa))</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSOLE2CT(po)	SSW2CA((po))</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSOLE2T(po)		SSW2A((po))</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> OLE2ANSI</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSW2OLE		SSW2A</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSOLE2W		SSA2W</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSW2COLE	SSW2CA</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSOLE2CW	SSA2CW</span>
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> POLESTR		<span class="hljs-title">SSA2OLE</span><span class="hljs-params">(PSTR p)</span>		</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PSTR			<span class="hljs-title">SSOLE2A</span><span class="hljs-params">(POLESTR p)</span>	</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCOLESTR		<span class="hljs-title">SSA2COLE</span><span class="hljs-params">(PCSTR p)</span>	</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCSTR		<span class="hljs-title">SSOLE2CA</span><span class="hljs-params">(PCOLESTR p)</span></span>{ <span class="hljs-keyword">return</span> p; }
    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSA2OLE		SSA2W</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSOLE2A		SSW2A</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSA2COLE	SSA2CW</span>
	    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSOLE2CA	SSW2CA</span>
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> POLESTR		<span class="hljs-title">SSW2OLE</span><span class="hljs-params">(PWSTR p)</span>	</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PWSTR		<span class="hljs-title">SSOLE2W</span><span class="hljs-params">(POLESTR p)</span>	</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCOLESTR		<span class="hljs-title">SSW2COLE</span><span class="hljs-params">(PCWSTR p)</span>	</span>{ <span class="hljs-keyword">return</span> p; }
	    <span class="hljs-function"><span class="hljs-keyword">inline</span> PCWSTR		<span class="hljs-title">SSOLE2CW</span><span class="hljs-params">(PCOLESTR p)</span></span>{ <span class="hljs-keyword">return</span> p; }
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-51" id="section-51"></a>
</div>
<p>Above we've defined macros that look like MS' but all have
an 'SS' prefix.  Now we need the real macros.  We'll either
get them from the macros above or from MFC/ATL.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (USES_CONVERSION)</span>

		<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _NO_STDCONVERSION	<span class="hljs-comment">// just to be consistent</span></span>

	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>

		<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MFC_VER</span>

			<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;afxconv.h&gt;</span></span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _NO_STDCONVERSION <span class="hljs-comment">// just to be consistent</span></span>

		<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>

			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> USES_CONVERSION SSCVT</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A2CW			SSA2CW</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> W2CA			SSW2CA</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> T2A				SST2A</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A2T				SSA2T</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> T2W				SST2W</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> W2T				SSW2T</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> T2CA			SST2CA</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A2CT			SSA2CT</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> T2CW			SST2CW</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> W2CT			SSW2CT</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ocslen			sslen</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ocscpy			sscpy</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> T2COLE			SST2COLE</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OLE2CT			SSOLE2CT</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> T2OLE			SST2COLE</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OLE2T			SSOLE2CT</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A2OLE			SSA2OLE</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OLE2A			SSOLE2A</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> W2OLE			SSW2OLE</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OLE2W			SSOLE2W</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A2COLE			SSA2COLE</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OLE2CA			SSOLE2CA</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> W2COLE			SSW2COLE</span>
			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OLE2CW			SSOLE2CW</span>
	
		<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifdef _MFC_VER</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifndef USES_CONVERSION</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifndef SS_NO_CONVERSION</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-52" id="section-52"></a>
</div>
<p>Define ostring - generic name for std::basic_string<OLECHAR></p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(ostring) &amp;&amp; !defined(OSTRING_DEFINED)</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::basic_string&lt;OLECHAR&gt; ostring;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OSTRING_DEFINED</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-53" id="section-53"></a>
</div>
<p>StdCodeCvt when there's no conversion to be done</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-function"><span class="hljs-keyword">inline</span> PSTR <span class="hljs-title">StdCodeCvt</span><span class="hljs-params">(PSTR pDst, <span class="hljs-keyword">int</span> nDst, PCSTR pSrc, <span class="hljs-keyword">int</span> nSrc)</span>
</span>{
	<span class="hljs-keyword">int</span> nChars = SSMIN(nSrc, nDst);

	<span class="hljs-keyword">if</span> ( nChars &gt; <span class="hljs-number">0</span> )
	{
		pDst[<span class="hljs-number">0</span>]				= <span class="hljs-string">'\0'</span>;
		<span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">char</span>&gt;::traits_type::copy(pDst, pSrc, nChars);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-54" id="section-54"></a>
</div>
<pre><code>std::char_traits&lt;char&gt;::copy(pDst, pSrc, nChars);
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">		pDst[nChars]	= <span class="hljs-string">'\0'</span>;
	}

	<span class="hljs-keyword">return</span> pDst;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> PSTR <span class="hljs-title">StdCodeCvt</span><span class="hljs-params">(PSTR pDst, <span class="hljs-keyword">int</span> nDst, PCUSTR pSrc, <span class="hljs-keyword">int</span> nSrc)</span>
</span>{
	<span class="hljs-keyword">return</span> StdCodeCvt(pDst, nDst, (PCSTR)pSrc, nSrc);
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> PUSTR <span class="hljs-title">StdCodeCvt</span><span class="hljs-params">(PUSTR pDst, <span class="hljs-keyword">int</span> nDst, PCSTR pSrc, <span class="hljs-keyword">int</span> nSrc)</span>
</span>{
	<span class="hljs-keyword">return</span> (PUSTR)StdCodeCvt((PSTR)pDst, nDst, pSrc, nSrc);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> PWSTR <span class="hljs-title">StdCodeCvt</span><span class="hljs-params">(PWSTR pDst, <span class="hljs-keyword">int</span> nDst, PCWSTR pSrc, <span class="hljs-keyword">int</span> nSrc)</span>
</span>{
	<span class="hljs-keyword">int</span> nChars = SSMIN(nSrc, nDst);

	<span class="hljs-keyword">if</span> ( nChars &gt; <span class="hljs-number">0</span> )
	{
		pDst[<span class="hljs-number">0</span>]				= <span class="hljs-string">'\0'</span>;
		<span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">wchar_t</span>&gt;::traits_type::copy(pDst, pSrc, nChars);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-55" id="section-55"></a>
</div>
<pre><code>std::char_traits&lt;wchar_t&gt;::copy(pDst, pSrc, nChars);
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">		pDst[nChars]	= <span class="hljs-string">'\0'</span>;
	}

	<span class="hljs-keyword">return</span> pDst;
}


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-56" id="section-56"></a>
</div>
<p>Define tstring -- generic name for std::basic_string<TCHAR></p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(tstring) &amp;&amp; !defined(TSTRING_DEFINED)</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::basic_string&lt;TCHAR&gt; tstring;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TSTRING_DEFINED</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-57" id="section-57"></a>
</div>
<p>a very shorthand way of applying the fix for KB problem Q172398
(basic_string assignment bug)</p>

        </td>
        <td class="code highlight">
          <pre class="c">
#if defined ( _MSC_VER ) &amp;&amp; ( _MSC_VER &lt; 1200 )
	#define Q172398(x) (x).erase()
#else
	#define Q172398(x)
#endif

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <p>=============================================================================
INLINE FUNCTIONS ON WHICH CSTDSTRING RELIES</p>
<p>Usually for generic text mapping, we rely on preprocessor macro definitions
to map to string functions.  However the CStdStr&lt;&gt; template cannot use
macro-based generic text mappings because its character types do not get
resolved until template processing which comes AFTER macro processing.  In
other words, the preprocessor macro UNICODE is of little help to us in the
CStdStr template</p>
<p>Therefore, to keep the CStdStr declaration simple, we have these inline
functions.  The template calls them often.  Since they are inline (and NOT
exported when this is built as a DLL), they will probably be resolved away
to nothing.</p>
<div class="pilwrap" id="without-these-functions-the-cstdstrlessgreater-template-would-probably-have-to-broken-out-into-two-almost-identical-classes.either-that-or-it-would-be-a-huge-convoluted-mess-with-tons-of-if-statements-all-over-the-place-checking-the-size-of-template-parameter-ct">
  <h1>
    <a href="#without-these-functions-the-cstdstrlessgreater-template-would-probably-have-to-broken-out-into-two-almost-identical-classes.either-that-or-it-would-be-a-huge-convoluted-mess-with-tons-of-if-statements-all-over-the-place-checking-the-size-of-template-parameter-ct" name="without-these-functions-the-cstdstrlessgreater-template-would-probably-have-to-broken-out-into-two-almost-identical-classes.either-that-or-it-would-be-a-huge-convoluted-mess-with-tons-of-if-statements-all-over-the-place-checking-the-size-of-template-parameter-ct" class="pilcrow"></a>
Without these functions, the CStdStr&lt;&gt; template would probably have to broken
out into two, almost identical classes.  Either that or it would be a huge,
convoluted mess, with tons of &quot;if&quot; statements all over the place checking the
size of template parameter CT.
  </h1>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_NO_LOCALE</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="win32-getstringtypeex-wrappers">
  <h2>
    <a href="#win32-getstringtypeex-wrappers" name="win32-getstringtypeex-wrappers" class="pilcrow"></a>
Win32 GetStringTypeEx wrappers
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">wsGetStringType</span><span class="hljs-params">(LCID lc, DWORD dwT, PCSTR pS, <span class="hljs-keyword">int</span> nSize, 
		WORD* pWd)</span>
	</span>{
		<span class="hljs-keyword">return</span> FALSE != GetStringTypeExA(lc, dwT, pS, nSize, pWd);
	}
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">wsGetStringType</span><span class="hljs-params">(LCID lc, DWORD dwT, PCWSTR pS, <span class="hljs-keyword">int</span> nSize, 
		WORD* pWd)</span>
	</span>{
		<span class="hljs-keyword">return</span> FALSE != GetStringTypeExW(lc, dwT, pS, nSize, pWd);
	}


	<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT&gt;
		<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ssisspace</span> <span class="hljs-params">(CT t)</span>
	</span>{ 
		WORD toYourMother;
		<span class="hljs-keyword">return</span>	wsGetStringType(GetThreadLocale(), CT_CTYPE1, &amp;t, <span class="hljs-number">1</span>, &amp;toYourMother)
			&amp;&amp; <span class="hljs-number">0</span> != (C1_BLANK &amp; toYourMother);
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-60" id="section-60"></a>
</div>
<p>If they defined SS_NO_REFCOUNT, then we must convert all assignments</p>

        </td>
        <td class="code highlight">
          <pre class="c">
#if defined (_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1300)
	#ifdef SS_NO_REFCOUNT
		#define SSREF(x) (x).c_str()
	#else
		#define SSREF(x) (x)
	#endif
#else
	#define SSREF(x) (x)
#endif

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="sslen-strlenwcslen-wrappers">
  <h2>
    <a href="#sslen-strlenwcslen-wrappers" name="sslen-strlenwcslen-wrappers" class="pilcrow"></a>
sslen: strlen/wcslen wrappers
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sslen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* pT)</span>
</span>{
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == pT ? <span class="hljs-number">0</span> : (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">std</span>::basic_string&lt;CT&gt;::traits_type::length(pT);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-62" id="section-62"></a>
</div>
<p>return 0 == pT ? 0 : std::char_traits<CT>::length(pT);</p>

        </td>
        <td class="code highlight">
          <pre class="c">}
<span class="hljs-function"><span class="hljs-keyword">inline</span> SS_NOTHROW <span class="hljs-keyword">int</span> <span class="hljs-title">sslen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s)</span>
</span>{
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(s.length());
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> SS_NOTHROW <span class="hljs-keyword">int</span> <span class="hljs-title">sslen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::wstring&amp; s)</span>
</span>{
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(s.length());
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="sstolowersstoupper-convert-characters-to-upperlower-case">
  <h2>
    <a href="#sstolowersstoupper-convert-characters-to-upperlower-case" name="sstolowersstoupper-convert-characters-to-upperlower-case" class="pilcrow"></a>
sstolower/sstoupper -- convert characters to upper/lower case
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
#ifdef SS_NO_LOCALE
	inline char sstoupper(char ch)		{ return (char)::toupper(ch); }
	inline wchar_t sstoupper(wchar_t ch){ return (wchar_t)::towupper(ch); }
	inline char sstolower(char ch)		{ return (char)::tolower(ch); }
	inline wchar_t sstolower(wchar_t ch){ return (wchar_t)::tolower(ch); }
#else
	template&lt;typename CT&gt;
	inline CT sstolower(const CT&amp; t, const std::locale&amp; loc = std::locale())
	{
		return std::tolower&lt;CT&gt;(t, loc);
	}
	template&lt;typename CT&gt;
	inline CT sstoupper(const CT&amp; t, const std::locale&amp; loc = std::locale())
	{
		return std::toupper&lt;CT&gt;(t, loc);
	}
#endif

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="ssasn-assignment-functions-assign-ssrc-to-sdst">
  <h2>
    <a href="#ssasn-assignment-functions-assign-ssrc-to-sdst" name="ssasn-assignment-functions-assign-ssrc-to-sdst" class="pilcrow"></a>
ssasn: assignment functions -- assign &quot;sSrc&quot; to &quot;sDst&quot;
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::size_type		SS_SIZETYPE; <span class="hljs-comment">// just for shorthand, really</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::pointer		SS_PTRTYPE;  
<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::wstring::size_type		SW_SIZETYPE;
<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::wstring::pointer		SW_PTRTYPE;  

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssasn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sDst, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sSrc)</span>
</span>{
	<span class="hljs-keyword">if</span> ( sDst.c_str() != sSrc.c_str() )
	{
		sDst.erase();
		sDst.assign(SSREF(sSrc));
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssasn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sDst, PCSTR pA)</span>
</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-65" id="section-65"></a>
</div>
<p>Watch out for NULLs, as always.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> == pA )
	{
		sDst.erase();
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-66" id="section-66"></a>
</div>
<p>If pA actually points to part of sDst, we must NOT erase(), but
rather take a substring</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( pA &gt;= sDst.c_str() &amp;&amp; pA &lt;= sDst.c_str() + sDst.size() )
	{
		sDst =sDst.substr(<span class="hljs-keyword">static_cast</span>&lt;SS_SIZETYPE&gt;(pA-sDst.c_str()));
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-67" id="section-67"></a>
</div>
<p>Otherwise (most cases) apply the assignment bug fix, if applicable
and do the assignment</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-keyword">else</span>
	{
		Q172398(sDst);
		sDst.assign(pA);
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssasn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sDst, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::wstring&amp; sSrc)</span>
</span>{
	<span class="hljs-keyword">if</span> ( sSrc.empty() )
	{
		sDst.erase();
	}
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">int</span> nDst	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(sSrc.size());

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-68" id="section-68"></a>
</div>
<p>In MBCS builds, pad the buffer to account for the possibility of
some 3 byte characters.  Not perfect but should get most cases.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_MBCS</span>
		nDst	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(nDst) * <span class="hljs-number">1.3</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

		sDst.resize(nDst+<span class="hljs-number">1</span>);
		PCSTR szCvt = StdCodeCvt(<span class="hljs-keyword">const_cast</span>&lt;SS_PTRTYPE&gt;(sDst.data()), nDst,
			sSrc.c_str(), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(sSrc.size()));

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-69" id="section-69"></a>
</div>
<p>In MBCS builds, we don't know how long the destination string will be.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_MBCS</span>
		sDst.resize(sslen(szCvt));
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		szCvt;
		sDst.resize(sSrc.size());
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssasn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sDst, PCWSTR pW)</span>
</span>{
	<span class="hljs-keyword">int</span> nSrc	= sslen(pW);
	<span class="hljs-keyword">if</span> ( nSrc &gt; <span class="hljs-number">0</span> )
	{
		<span class="hljs-keyword">int</span> nSrc	= sslen(pW);
		<span class="hljs-keyword">int</span> nDst	= nSrc;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-70" id="section-70"></a>
</div>
<p>In MBCS builds, pad the buffer to account for the possibility of
some 3 byte characters.  Not perfect but should get most cases.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_MBCS</span>
		nDst	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(nDst) * <span class="hljs-number">1.3</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

		sDst.resize(nDst + <span class="hljs-number">1</span>);
		PCSTR szCvt = StdCodeCvt(<span class="hljs-keyword">const_cast</span>&lt;SS_PTRTYPE&gt;(sDst.data()), nDst,
			pW, nSrc);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-71" id="section-71"></a>
</div>
<p>In MBCS builds, we don't know how long the destination string will be.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_MBCS</span>
		sDst.resize(sslen(szCvt));
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		sDst.resize(nDst);
		szCvt;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}
	<span class="hljs-keyword">else</span>
	{
		sDst.erase();
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ssasn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sDst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> nNull)</span>
</span>{
	UNUSED(nNull);
	ASSERT(nNull==<span class="hljs-number">0</span>);
	sDst.assign(<span class="hljs-string">""</span>);
}	
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssasn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::wstring&amp; sDst, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::wstring&amp; sSrc)</span>
</span>{
	<span class="hljs-keyword">if</span> ( sDst.c_str() != sSrc.c_str() )
	{
		sDst.erase();
		sDst.assign(SSREF(sSrc));
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssasn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::wstring&amp; sDst, PCWSTR pW)</span>
</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-72" id="section-72"></a>
</div>
<p>Watch out for NULLs, as always.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> == pW )
	{
		sDst.erase();
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-73" id="section-73"></a>
</div>
<p>If pW actually points to part of sDst, we must NOT erase(), but
rather take a substring</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( pW &gt;= sDst.c_str() &amp;&amp; pW &lt;= sDst.c_str() + sDst.size() )
	{
		sDst = sDst.substr(<span class="hljs-keyword">static_cast</span>&lt;SW_SIZETYPE&gt;(pW-sDst.c_str()));
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-74" id="section-74"></a>
</div>
<p>Otherwise (most cases) apply the assignment bug fix, if applicable
and do the assignment</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-keyword">else</span>
	{
		Q172398(sDst);
		sDst.assign(pW);
	}
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> StrSizeType</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssasn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::wstring&amp; sDst, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sSrc)</span>
</span>{
	<span class="hljs-keyword">if</span> ( sSrc.empty() )
	{
		sDst.erase();
	}
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">int</span> nSrc	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(sSrc.size());
		<span class="hljs-keyword">int</span> nDst	= nSrc;

		sDst.resize(nSrc+<span class="hljs-number">1</span>);
		PCWSTR szCvt = StdCodeCvt(<span class="hljs-keyword">const_cast</span>&lt;SW_PTRTYPE&gt;(sDst.data()), nDst,
			sSrc.c_str(), nSrc);

		sDst.resize(sslen(szCvt));
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssasn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::wstring&amp; sDst, PCSTR pA)</span>
</span>{
	<span class="hljs-keyword">int</span> nSrc	= sslen(pA);

	<span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> == nSrc )
	{
		sDst.erase();
	}
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">int</span> nDst	= nSrc;
		sDst.resize(nDst+<span class="hljs-number">1</span>);
		PCWSTR szCvt = StdCodeCvt(<span class="hljs-keyword">const_cast</span>&lt;SW_PTRTYPE&gt;(sDst.data()), nDst, pA,
			nSrc);

		sDst.resize(sslen(szCvt));
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ssasn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::wstring&amp; sDst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> nNull)</span>
</span>{
	UNUSED(nNull);
	ASSERT(nNull==<span class="hljs-number">0</span>);
	sDst.assign(<span class="hljs-string">L""</span>);
}


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="ssadd-string-object-concatenation-add-second-argument-to-first">
  <h2>
    <a href="#ssadd-string-object-concatenation-add-second-argument-to-first" name="ssadd-string-object-concatenation-add-second-argument-to-first" class="pilcrow"></a>
ssadd: string object concatenation -- add second argument to first
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssadd</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sDst, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::wstring&amp; sSrc)</span>
</span>{
	<span class="hljs-keyword">int</span> nSrc	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(sSrc.size());

	<span class="hljs-keyword">if</span> ( nSrc &gt; <span class="hljs-number">0</span> )
	{
		<span class="hljs-keyword">int</span> nDst	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(sDst.size());
		<span class="hljs-keyword">int</span> nAdd	= nSrc;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-76" id="section-76"></a>
</div>
<p>In MBCS builds, pad the buffer to account for the possibility of
some 3 byte characters.  Not perfect but should get most cases.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_MBCS</span>
		nAdd		= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(nAdd) * <span class="hljs-number">1.3</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

		sDst.resize(nDst+nAdd+<span class="hljs-number">1</span>);
		PCSTR szCvt = StdCodeCvt(<span class="hljs-keyword">const_cast</span>&lt;SS_PTRTYPE&gt;(sDst.data()+nDst),
			nAdd, sSrc.c_str(), nSrc);

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_MBCS</span>
		sDst.resize(nDst + sslen(szCvt));
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		sDst.resize(nDst + nAdd);
		szCvt;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssadd</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sDst, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sSrc)</span>
</span>{
	sDst += sSrc;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssadd</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sDst, PCWSTR pW)</span>
</span>{
	<span class="hljs-keyword">int</span> nSrc		= sslen(pW);
	<span class="hljs-keyword">if</span> ( nSrc &gt; <span class="hljs-number">0</span> )
	{
		<span class="hljs-keyword">int</span> nDst	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(sDst.size());
		<span class="hljs-keyword">int</span> nAdd	= nSrc;

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_MBCS</span>
		nAdd	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(nAdd) * <span class="hljs-number">1.3</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

		sDst.resize(nDst + nAdd + <span class="hljs-number">1</span>);
		PCSTR szCvt = StdCodeCvt(<span class="hljs-keyword">const_cast</span>&lt;SS_PTRTYPE&gt;(sDst.data()+nDst),
			nAdd, pW, nSrc);

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_MBCS</span>
		sDst.resize(nDst + sslen(szCvt));
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		sDst.resize(nDst + nSrc);
		szCvt;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssadd</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sDst, PCSTR pA)</span>
</span>{
	<span class="hljs-keyword">if</span> ( pA )
	{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-77" id="section-77"></a>
</div>
<p>If the string being added is our internal string or a part of our
internal string, then we must NOT do any reallocation without
first copying that string to another object (since we're using a
direct pointer)</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-keyword">if</span> ( pA &gt;= sDst.c_str() &amp;&amp; pA &lt;= sDst.c_str()+sDst.length())
		{
			<span class="hljs-keyword">if</span> ( sDst.capacity() &lt;= sDst.size()+sslen(pA) )
				sDst.append(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(pA));
			<span class="hljs-keyword">else</span>
				sDst.append(pA);
		}
		<span class="hljs-keyword">else</span>
		{
			sDst.append(pA); 
		}
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssadd</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::wstring&amp; sDst, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::wstring&amp; sSrc)</span>
</span>{
	sDst += sSrc;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssadd</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::wstring&amp; sDst, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sSrc)</span>
</span>{
	<span class="hljs-keyword">if</span> ( !sSrc.empty() )
	{
		<span class="hljs-keyword">int</span> nSrc	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(sSrc.size());
		<span class="hljs-keyword">int</span> nDst	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(sDst.size());

		sDst.resize(nDst + nSrc + <span class="hljs-number">1</span>);
		PCWSTR szCvt = StdCodeCvt(<span class="hljs-keyword">const_cast</span>&lt;SW_PTRTYPE&gt;(sDst.data()+nDst), 
			nSrc, sSrc.c_str(), nSrc+<span class="hljs-number">1</span>);

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_MBCS</span>
		sDst.resize(nDst + sslen(szCvt));
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		sDst.resize(nDst + nSrc);
		szCvt;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssadd</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::wstring&amp; sDst, PCSTR pA)</span>
</span>{
	<span class="hljs-keyword">int</span> nSrc		= sslen(pA);

	<span class="hljs-keyword">if</span> ( nSrc &gt; <span class="hljs-number">0</span> )
	{
		<span class="hljs-keyword">int</span> nDst	= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(sDst.size());

		sDst.resize(nDst + nSrc + <span class="hljs-number">1</span>);
		PCWSTR szCvt = StdCodeCvt(<span class="hljs-keyword">const_cast</span>&lt;SW_PTRTYPE&gt;(sDst.data()+nDst),
			nSrc, pA, nSrc+<span class="hljs-number">1</span>);

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_MBCS</span>
		sDst.resize(nDst + sslen(szCvt));
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		sDst.resize(nDst + nSrc);
		szCvt;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>	<span class="hljs-title">ssadd</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::wstring&amp; sDst, PCWSTR pW)</span>
</span>{
	<span class="hljs-keyword">if</span> ( pW )
	{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-78" id="section-78"></a>
</div>
<p>If the string being added is our internal string or a part of our
internal string, then we must NOT do any reallocation without
first copying that string to another object (since we're using a
direct pointer)</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-keyword">if</span> ( pW &gt;= sDst.c_str() &amp;&amp; pW &lt;= sDst.c_str()+sDst.length())
		{
			<span class="hljs-keyword">if</span> ( sDst.capacity() &lt;= sDst.size()+sslen(pW) )
				sDst.append(<span class="hljs-built_in">std</span>::wstring(pW));
			<span class="hljs-keyword">else</span>
				sDst.append(pW);
		}
		<span class="hljs-keyword">else</span>
		{
			sDst.append(pW);
		}
	}
}


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="sscmp-comparison-case-sensitive-not-affected-by-locale">
  <h2>
    <a href="#sscmp-comparison-case-sensitive-not-affected-by-locale" name="sscmp-comparison-case-sensitive-not-affected-by-locale" class="pilcrow"></a>
sscmp: comparison (case sensitive, not affected by locale)
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* pA1, <span class="hljs-keyword">const</span> CT* pA2)</span>
</span>{
    CT f;
    CT l;

    <span class="hljs-keyword">do</span> 
    {
	    f = *(pA1++);
	    l = *(pA2++);
    } <span class="hljs-keyword">while</span> ( (f) &amp;&amp; (f == l) );

    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(f - l);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="ssicmp-comparison-case-insensitive-not-affected-by-locale">
  <h2>
    <a href="#ssicmp-comparison-case-insensitive-not-affected-by-locale" name="ssicmp-comparison-case-insensitive-not-affected-by-locale" class="pilcrow"></a>
ssicmp: comparison (case INsensitive, not affected by locale)
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ssicmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* pA1, <span class="hljs-keyword">const</span> CT* pA2)</span>
</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-81" id="section-81"></a>
</div>
<p>Using the &quot;C&quot; locale = &quot;not affected by locale&quot;</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-built_in">std</span>::locale loc = <span class="hljs-built_in">std</span>::locale::classic();
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::ctype&lt;CT&gt;&amp; ct = SS_USE_FACET(loc, <span class="hljs-built_in">std</span>::ctype&lt;CT&gt;);
    CT f;
    CT l;

    <span class="hljs-keyword">do</span> 
    {
	    f = ct.<span class="hljs-built_in">tolower</span>(*(pA1++));
	    l = ct.<span class="hljs-built_in">tolower</span>(*(pA2++));
    } <span class="hljs-keyword">while</span> ( (f) &amp;&amp; (f == l) );

    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(f - l);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="ssuprsslwr-uppercaselowercase-conversion-functions">
  <h2>
    <a href="#ssuprsslwr-uppercaselowercase-conversion-functions" name="ssuprsslwr-uppercaselowercase-conversion-functions" class="pilcrow"></a>
ssupr/sslwr: Uppercase/Lowercase conversion functions
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
template&lt;typename CT&gt;
inline void sslwr(CT* pT, size_t nLen, const std::locale&amp; loc=std::locale())
{
	SS_USE_FACET(loc, std::ctype&lt;CT&gt;).tolower(pT, pT+nLen);
}
template&lt;typename CT&gt;
inline void ssupr(CT* pT, size_t nLen, const std::locale&amp; loc=std::locale())
{
	SS_USE_FACET(loc, std::ctype&lt;CT&gt;).toupper(pT, pT+nLen);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-83" id="section-83"></a>
</div>
<hr>
<p>vsprintf/vswprintf or _vsnprintf/_vsnwprintf equivalents.  In standard
builds we can't use _vsnprintf/_vsnwsprintf because they're MS extensions.</p>
<hr>
<p>Borland's headers put some ANSI &quot;C&quot; functions in the 'std' namespace.
Promote them to the global namespace so we can use them here.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__BORLANDC__)</span>
    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vsprintf</span>;
    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::vswprintf;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-84" id="section-84"></a>
</div>
<p>GNU is supposed to have vsnprintf and vsnwprintf.  But only the newer
distributions do.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__GNUC__)</span>

	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ssvsprintf</span><span class="hljs-params">(PSTR pA, <span class="hljs-keyword">size_t</span> nCount, PCSTR pFmtA, va_list vl)</span>
	</span>{ 
		<span class="hljs-keyword">return</span> vsnprintf(pA, nCount, pFmtA, vl);
	}
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ssvsprintf</span><span class="hljs-params">(PWSTR pW, <span class="hljs-keyword">size_t</span> nCount, PCWSTR pFmtW, va_list vl)</span>
	</span>{
		<span class="hljs-keyword">return</span> vswprintf(pW, nCount, pFmtW, vl);
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-85" id="section-85"></a>
</div>
<p>Else if this is VC++ in a regular (non-ANSI) build</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(_MSC_VER) &amp;&amp; !defined(SS_ANSI)</span>

	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span>	<span class="hljs-title">ssvsprintf</span><span class="hljs-params">(PSTR pA, <span class="hljs-keyword">size_t</span> nCount, PCSTR pFmtA, va_list vl)</span>
	</span>{ 
		<span class="hljs-keyword">return</span> _vsnprintf(pA, nCount, pFmtA, vl);
	}
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span>	<span class="hljs-title">ssvsprintf</span><span class="hljs-params">(PWSTR pW, <span class="hljs-keyword">size_t</span> nCount, PCWSTR pFmtW, va_list vl)</span>
	</span>{
		<span class="hljs-keyword">return</span> _vsnwprintf(pW, nCount, pFmtW, vl);
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-86" id="section-86"></a>
</div>
<p>Else (an ANSI build) if they want to allow &quot;dangerous&quot; (i.e. non-length-
checked) formatting</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined (SS_DANGEROUS_FORMAT)  <span class="hljs-comment">// ignore buffer size parameter if needed?</span></span>

	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ssvsprintf</span><span class="hljs-params">(PSTR pA, <span class="hljs-keyword">size_t</span> <span class="hljs-comment">/*nCount*/</span>, PCSTR pFmtA, va_list vl)</span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">vsprintf</span>(pA, pFmtA, vl);
	}

	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ssvsprintf</span><span class="hljs-params">(PWSTR pW, <span class="hljs-keyword">size_t</span> nCount, PCWSTR pFmtW, va_list vl)</span>
	</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-87" id="section-87"></a>
</div>
<p>JMO: Some distributions of the &quot;C&quot; have a version of vswprintf that
takes 3 arguments (e.g. Microsoft, Borland, GNU).  Others have a
version which takes 4 arguments (an extra &quot;count&quot; argument in the
second position.  The best stab I can take at this so far is that if
you are NOT running with MS, Borland, or GNU, then I'll assume you
have the version that takes 4 arguments.</p>
<p>I'm sure that these checks don't catch every platform correctly so if
you get compiler errors on one of the lines immediately below, it's
probably because your implemntation takes a different number of
arguments.  You can comment out the offending line (and use the
alternate version) or you can figure out what compiler flag to check
and add that preprocessor check in.  Regardless, if you get an error
on these lines, I'd sure like to hear from you about it.</p>
<p>Thanks to Ronny Schulz for the SGI-specific checks here.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-88" id="section-88"></a>
</div>
<p>#if !defined(<strong>MWERKS</strong>) &amp;&amp; !defined(__SUNPRO_CC_COMPAT) &amp;&amp; !defined(__SUNPRO_CC)</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span>    !defined(_MSC_VER) \
        &amp;&amp; !defined (__BORLANDC__) \
        &amp;&amp; !defined(__GNUC__) \
        &amp;&amp; !defined(__sgi)</span>

        <span class="hljs-keyword">return</span> vswprintf(pW, nCount, pFmtW, vl);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-89" id="section-89"></a>
</div>
<p>suddenly with the current SGI 7.3 compiler there is no such function as
vswprintf and the substitute needs explicit casts to compile</p>

        </td>
        <td class="code highlight">
          <pre class="c">
    <span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(__sgi)</span>

        nCount;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vsprintf</span>( (<span class="hljs-keyword">char</span> *)pW, (<span class="hljs-keyword">char</span> *)pFmtW, vl);

    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>

        nCount;
        <span class="hljs-keyword">return</span> vswprintf(pW, pFmtW, vl);

    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-90" id="section-90"></a>
</div>
<p>OK, it's some kind of ANSI build but no &quot;dangerous&quot; formatting allowed</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> </span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="got-compiler-problems-here">
  <h2>
    <a href="#got-compiler-problems-here" name="got-compiler-problems-here" class="pilcrow"></a>
GOT COMPILER PROBLEMS HERE?
  </h2>
</div>
<p>Does your compiler choke on one or more of the following 2 functions?  It
probably means that you don't have have either vsnprintf or vsnwprintf in
your version of the CRT.  This is understandable since neither is an ANSI
&quot;C&quot; function.  However it still leaves you in a dilemma.  In order to make
this code build, you're going to have to to use some non-length-checked
formatting functions that every CRT has:  vsprintf and vswprintf.</p>
<p>This is very dangerous.  With the proper erroneous (or malicious) code, it
can lead to buffer overlows and crashing your PC.  Use at your own risk
In order to use them, just #define SS_DANGEROUS_FORMAT at the top of
this file.</p>
<p>Even THEN you might not be all the way home due to some non-conforming
distributions.  More on this in the comments below.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span>	<span class="hljs-title">ssvsprintf</span><span class="hljs-params">(PSTR pA, <span class="hljs-keyword">size_t</span> nCount, PCSTR pFmtA, va_list vl)</span>
	</span>{
	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span>
			<span class="hljs-keyword">return</span> _vsnprintf(pA, nCount, pFmtA, vl);
	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
			<span class="hljs-keyword">return</span> vsnprintf(pA, nCount, pFmtA, vl);
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span>	<span class="hljs-title">ssvsprintf</span><span class="hljs-params">(PWSTR pW, <span class="hljs-keyword">size_t</span> nCount, PCWSTR pFmtW, va_list vl)</span>
	</span>{
	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span>
			<span class="hljs-keyword">return</span> _vsnwprintf(pW, nCount, pFmtW, vl);
	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
			<span class="hljs-keyword">return</span> vsnwprintf(pW, nCount, pFmtW, vl);
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>




</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="ssload-type-safe-overloaded-loadstring-wrappers-there-is-no-equivalent-of-these-in-non-win32-specific-builds.however-im-thinking-that-with-the-message-facet-there-might-eventually-be-one">
  <h2>
    <a href="#ssload-type-safe-overloaded-loadstring-wrappers-there-is-no-equivalent-of-these-in-non-win32-specific-builds.however-im-thinking-that-with-the-message-facet-there-might-eventually-be-one" name="ssload-type-safe-overloaded-loadstring-wrappers-there-is-no-equivalent-of-these-in-non-win32-specific-builds.however-im-thinking-that-with-the-message-facet-there-might-eventually-be-one" class="pilcrow"></a>
ssload: Type safe, overloaded ::LoadString wrappers
There is no equivalent of these in non-Win32-specific builds.  However, I'm
thinking that with the message facet, there might eventually be one
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (SS_WIN32) &amp;&amp; !defined(SS_ANSI)</span>
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ssload</span><span class="hljs-params">(HMODULE hInst, UINT uId, PSTR pBuf, <span class="hljs-keyword">int</span> nMax)</span>
	</span>{
		<span class="hljs-keyword">return</span> ::LoadStringA(hInst, uId, pBuf, nMax);
	}
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ssload</span><span class="hljs-params">(HMODULE hInst, UINT uId, PWSTR pBuf, <span class="hljs-keyword">int</span> nMax)</span>
	</span>{
		<span class="hljs-keyword">return</span> ::LoadStringW(hInst, uId, pBuf, nMax);
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="sscollssicoll-collation-wrappers-note-with-msvc-i-have-reversed-the-arguments-order-here-because-the-functions-appear-to-return-the-opposite-of-what-they-should">
  <h2>
    <a href="#sscollssicoll-collation-wrappers-note-with-msvc-i-have-reversed-the-arguments-order-here-because-the-functions-appear-to-return-the-opposite-of-what-they-should" name="sscollssicoll-collation-wrappers-note-with-msvc-i-have-reversed-the-arguments-order-here-because-the-functions-appear-to-return-the-opposite-of-what-they-should" class="pilcrow"></a>
sscoll/ssicoll: Collation wrappers
	Note -- with MSVC I have reversed the arguments order here because the
	functions appear to return the opposite of what they should
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_NO_LOCALE</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> CT&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscoll</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* sz1, <span class="hljs-keyword">int</span> nLen1, <span class="hljs-keyword">const</span> CT* sz2, <span class="hljs-keyword">int</span> nLen2)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::collate&lt;CT&gt;&amp; coll =
		SS_USE_FACET(<span class="hljs-built_in">std</span>::locale(), <span class="hljs-built_in">std</span>::collate&lt;CT&gt;);

	<span class="hljs-keyword">return</span> coll.compare(sz2, sz2+nLen2, sz1, sz1+nLen1);
}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> CT&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ssicoll</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* sz1, <span class="hljs-keyword">int</span> nLen1, <span class="hljs-keyword">const</span> CT* sz2, <span class="hljs-keyword">int</span> nLen2)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::locale loc;
	<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::collate&lt;CT&gt;&amp; coll = SS_USE_FACET(loc, <span class="hljs-built_in">std</span>::collate&lt;CT&gt;);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-94" id="section-94"></a>
</div>
<p>Some implementations seem to have trouble using the collate&lt;&gt;
facet typedefs so we'll just default to basic_string and hope
that's what the collate facet uses (which it generally should)</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-95" id="section-95"></a>
</div>
<p>std::collate<CT>::string_type s1(sz1);
std::collate<CT>::string_type s2(sz2);</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::basic_string&lt;CT&gt; sEmpty;
    <span class="hljs-built_in">std</span>::basic_string&lt;CT&gt; s1(sz1 ? sz1 : sEmpty.c_str());
    <span class="hljs-built_in">std</span>::basic_string&lt;CT&gt; s2(sz2 ? sz2 : sEmpty.c_str());

	sslwr(<span class="hljs-keyword">const_cast</span>&lt;CT*&gt;(s1.c_str()), nLen1, loc);
	sslwr(<span class="hljs-keyword">const_cast</span>&lt;CT*&gt;(s2.c_str()), nLen2, loc);
	<span class="hljs-keyword">return</span> coll.compare(s2.c_str(), s2.c_str()+nLen2,
						s1.c_str(), s1.c_str()+nLen1);
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="ssfmtmsg-formatmessage-equivalents.needed-because-i-added-a-cstring-facade-again-no-equivalent-of-these-on-non-win32-builds-but-their-might-one-day-be-one-if-the-message-facet-gets-implemented">
  <h2>
    <a href="#ssfmtmsg-formatmessage-equivalents.needed-because-i-added-a-cstring-facade-again-no-equivalent-of-these-on-non-win32-builds-but-their-might-one-day-be-one-if-the-message-facet-gets-implemented" name="ssfmtmsg-formatmessage-equivalents.needed-because-i-added-a-cstring-facade-again-no-equivalent-of-these-on-non-win32-builds-but-their-might-one-day-be-one-if-the-message-facet-gets-implemented" class="pilcrow"></a>
ssfmtmsg: FormatMessage equivalents.  Needed because I added a CString facade
Again -- no equivalent of these on non-Win32 builds but their might one day
be one if the message facet gets implemented
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (SS_WIN32) &amp;&amp; !defined(SS_ANSI)</span>
	<span class="hljs-function"><span class="hljs-keyword">inline</span> DWORD <span class="hljs-title">ssfmtmsg</span><span class="hljs-params">(DWORD dwFlags, LPCVOID pSrc, DWORD dwMsgId,
						  DWORD dwLangId, PSTR pBuf, DWORD nSize,
						  va_list* vlArgs)</span>
	</span>{ 
		<span class="hljs-keyword">return</span> FormatMessageA(dwFlags, pSrc, dwMsgId, dwLangId,
							  pBuf, nSize,vlArgs);
	}
	<span class="hljs-function"><span class="hljs-keyword">inline</span> DWORD <span class="hljs-title">ssfmtmsg</span><span class="hljs-params">(DWORD dwFlags, LPCVOID pSrc, DWORD dwMsgId,
						  DWORD dwLangId, PWSTR pBuf, DWORD nSize,
						  va_list* vlArgs)</span>
	</span>{
		<span class="hljs-keyword">return</span> FormatMessageW(dwFlags, pSrc, dwMsgId, dwLangId,
							  pBuf, nSize,vlArgs);
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
 


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="function-sscpy.copies-up-to-nmax-characters-from-psrc-to-pdst">
  <h2>
    <a href="#function-sscpy.copies-up-to-nmax-characters-from-psrc-to-pdst" name="function-sscpy.copies-up-to-nmax-characters-from-psrc-to-pdst" class="pilcrow"></a>
FUNCTION: sscpy.  Copies up to 'nMax' characters from pSrc to pDst.
  </h2>
</div>
<p>FUNCTION:  sscpy
	inline int sscpy(PSTR pDst, PCSTR pSrc, int nMax=-1);
	inline int sscpy(PUSTR pDst,  PCSTR pSrc, int nMax=-1)
	inline int sscpy(PSTR pDst, PCWSTR pSrc, int nMax=-1);
	inline int sscpy(PWSTR pDst, PCWSTR pSrc, int nMax=-1);
	inline int sscpy(PWSTR pDst, PCSTR pSrc, int nMax=-1);</p>
<p>DESCRIPTION:
	This function is very much (but not exactly) like strcpy.  These
	overloads simplify copying one C-style string into another by allowing
	the caller to specify two different types of strings if necessary.</p>
<pre><code>The strings must NOT overlap

&quot;Character&quot; is expressed in terms of the destination string, not
the source.  If no 'nMax' argument is supplied, then the number of
characters copied will be sslen(pSrc).  A NULL terminator will
also be added so pDst must actually be big enough to hold nMax+1
characters.  The return value is the number of characters copied,
not including the NULL terminator.
</code></pre>
<p>PARAMETERS:
	pSrc - the string to be copied FROM.  May be a char based string, an
		   MBCS string (in Win32 builds) or a wide string (wchar_t).
	pSrc - the string to be copied TO.  Also may be either MBCS or wide
	nMax - the maximum number of characters to be copied into szDest.  Note
		   that this is expressed in whatever a &quot;character&quot; means to pDst.
		   If pDst is a wchar_t type string than this will be the maximum
		   number of wchar_ts that my be copied.  The pDst string must be
		   large enough to hold least nMaxChars+1 characters.
		   If the caller supplies no argument for nMax this is a signal to
		   the routine to copy all the characters in pSrc, regardless of
		   how long it is.</p>
<div class="pilwrap" id="return-value-none">
  <h2>
    <a href="#return-value-none" name="return-value-none" class="pilcrow"></a>
RETURN VALUE: none
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT1, <span class="hljs-keyword">typename</span> CT2&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpycvt</span><span class="hljs-params">(CT1* pDst, <span class="hljs-keyword">const</span> CT2* pSrc, <span class="hljs-keyword">int</span> nMax)</span>
</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-98" id="section-98"></a>
</div>
<p>Note -- we assume pDst is big enough to hold pSrc.  If not, we're in
big trouble.  No bounds checking.  Caveat emptor.</p>

        </td>
        <td class="code highlight">
          <pre class="c">	
	<span class="hljs-keyword">int</span> nSrc = sslen(pSrc);

	<span class="hljs-keyword">const</span> CT1* szCvt = StdCodeCvt(pDst, nMax, pSrc, nSrc);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-99" id="section-99"></a>
</div>
<p>If we're copying the same size characters, then all the &quot;code convert&quot;
just did was basically memcpy so the #of characters copied is the same
as the number requested.  I should probably specialize this function
template to achieve this purpose as it is silly to do a runtime check
of a fact known at compile time.  I'll get around to it.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-keyword">return</span> sslen(szCvt);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpycvt</span><span class="hljs-params">(PSTR pDst, PCSTR pSrc, <span class="hljs-keyword">int</span> nMax)</span>
</span>{
	<span class="hljs-keyword">int</span> nCount = nMax;
	<span class="hljs-keyword">for</span> (; nCount &gt; <span class="hljs-number">0</span> &amp;&amp; *pSrc; ++pSrc, ++pDst, --nCount)
		<span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">char</span>&gt;::traits_type::assign(*pDst, *pSrc);

	*pDst =  <span class="hljs-string">'\0'</span>;
	<span class="hljs-keyword">return</span> nMax - nCount;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpycvt</span><span class="hljs-params">(PWSTR pDst, PCWSTR pSrc, <span class="hljs-keyword">int</span> nMax)</span>
</span>{
	<span class="hljs-keyword">int</span> nCount = nMax;
	<span class="hljs-keyword">for</span> (; nCount &gt; <span class="hljs-number">0</span> &amp;&amp; *pSrc; ++pSrc, ++pDst, --nCount)
		<span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">wchar_t</span>&gt;::traits_type::assign(*pDst, *pSrc);

	*pDst = L'\<span class="hljs-number">0'</span>;
	<span class="hljs-keyword">return</span> nMax - nCount;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpycvt</span><span class="hljs-params">(PWSTR pDst, PCSTR pSrc, <span class="hljs-keyword">int</span> nMax)</span>
</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-100" id="section-100"></a>
</div>
<p>Note -- we assume pDst is big enough to hold pSrc.  If not, we're in
big trouble.  No bounds checking.  Caveat emptor.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-keyword">const</span> PWSTR szCvt = StdCodeCvt(pDst, nMax, pSrc, nMax);
	<span class="hljs-keyword">return</span> sslen(szCvt);
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT1, <span class="hljs-keyword">typename</span> CT2&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpy</span><span class="hljs-params">(CT1* pDst, <span class="hljs-keyword">const</span> CT2* pSrc, <span class="hljs-keyword">int</span> nMax, <span class="hljs-keyword">int</span> nLen)</span>
</span>{
	<span class="hljs-keyword">return</span> sscpycvt(pDst, pSrc, SSMIN(nMax, nLen));
}
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT1, <span class="hljs-keyword">typename</span> CT2&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpy</span><span class="hljs-params">(CT1* pDst, <span class="hljs-keyword">const</span> CT2* pSrc, <span class="hljs-keyword">int</span> nMax)</span>
</span>{
	<span class="hljs-keyword">return</span> sscpycvt(pDst, pSrc, SSMIN(nMax, sslen(pSrc)));
}
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT1, <span class="hljs-keyword">typename</span> CT2&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpy</span><span class="hljs-params">(CT1* pDst, <span class="hljs-keyword">const</span> CT2* pSrc)</span>
</span>{
	<span class="hljs-keyword">return</span> sscpycvt(pDst, pSrc, sslen(pSrc));
}
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT1, <span class="hljs-keyword">typename</span> CT2&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpy</span><span class="hljs-params">(CT1* pDst, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::basic_string&lt;CT2&gt;&amp; sSrc, <span class="hljs-keyword">int</span> nMax)</span>
</span>{
	<span class="hljs-keyword">return</span> sscpycvt(pDst, sSrc.c_str(), SSMIN(nMax, (<span class="hljs-keyword">int</span>)sSrc.length()));
}
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT1, <span class="hljs-keyword">typename</span> CT2&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpy</span><span class="hljs-params">(CT1* pDst, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::basic_string&lt;CT2&gt;&amp; sSrc)</span>
</span>{
	<span class="hljs-keyword">return</span> sscpycvt(pDst, sSrc.c_str(), (<span class="hljs-keyword">int</span>)sSrc.length());
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_INC_COMDEF</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT1&gt;
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpy</span><span class="hljs-params">(CT1* pDst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">_bstr_t</span>&amp; bs, <span class="hljs-keyword">int</span> nMax)</span>
	</span>{
		<span class="hljs-keyword">return</span> sscpycvt(pDst, <span class="hljs-keyword">static_cast</span>&lt;PCOLESTR&gt;(bs),
            SSMIN(nMax, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(bs.length())));
	}
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT1&gt;
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sscpy</span><span class="hljs-params">(CT1* pDst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">_bstr_t</span>&amp; bs)</span>
	</span>{
		<span class="hljs-keyword">return</span> sscpy(pDst, bs, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(bs.length()));
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="functional-objects-for-changing-case.they-also-let-you-pass-locales">
  <h2>
    <a href="#functional-objects-for-changing-case.they-also-let-you-pass-locales" name="functional-objects-for-changing-case.they-also-let-you-pass-locales" class="pilcrow"></a>
Functional objects for changing case.  They also let you pass locales
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_NO_LOCALE</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT&gt;
	<span class="hljs-keyword">struct</span> SSToUpper : <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::unary_function&lt;CT, CT&gt;
	{
		<span class="hljs-function"><span class="hljs-keyword">inline</span> CT <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT&amp; t)</span> <span class="hljs-keyword">const</span>
		</span>{
			<span class="hljs-keyword">return</span> sstoupper(t);
		}
	};
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT&gt;
	<span class="hljs-keyword">struct</span> SSToLower : <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::unary_function&lt;CT, CT&gt;
	{
		<span class="hljs-function"><span class="hljs-keyword">inline</span> CT <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT&amp; t)</span> <span class="hljs-keyword">const</span>
		</span>{
			<span class="hljs-keyword">return</span> sstolower(t);
		}
	};
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT&gt;
	<span class="hljs-keyword">struct</span> SSToUpper : <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::binary_function&lt;CT, <span class="hljs-built_in">std</span>::locale, CT&gt;
	{
		<span class="hljs-function"><span class="hljs-keyword">inline</span> CT <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT&amp; t, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::locale&amp; loc)</span> <span class="hljs-keyword">const</span>
		</span>{
			<span class="hljs-keyword">return</span> sstoupper&lt;CT&gt;(t, loc);
		}
	};
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT&gt;
	<span class="hljs-keyword">struct</span> SSToLower : <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::binary_function&lt;CT, <span class="hljs-built_in">std</span>::locale, CT&gt;
	{
		<span class="hljs-function"><span class="hljs-keyword">inline</span> CT <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT&amp; t, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::locale&amp; loc)</span> <span class="hljs-keyword">const</span>
		</span>{
			<span class="hljs-keyword">return</span> sstolower&lt;CT&gt;(t, loc);
		}
	};
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-102" id="section-102"></a>
</div>
<p>This struct is used for TrimRight() and TrimLeft() function implementations.
template<typename CT>
struct NotSpace : public std::unary_function&lt;CT, bool&gt;
{
const std::locale&amp; loc;
inline NotSpace(const std::locale&amp; locArg) : loc(locArg) {}
inline bool operator() (CT t) { return !std::isspace(t, loc); }
};</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CT&gt;
<span class="hljs-keyword">struct</span> NotSpace : <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::unary_function&lt;CT, <span class="hljs-keyword">bool</span>&gt;
{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-103" id="section-103"></a>
</div>
<p>DINKUMWARE BUG:
Note -- using std::isspace in a COM DLL gives us access violations
because it causes the dynamic addition of a function to be called
when the library shuts down.  Unfortunately the list is maintained
in DLL memory but the function is in static memory.  So the COM DLL
goes away along with the function that was supposed to be called,
and then later when the DLL CRT shuts down it unloads the list and
tries to call the long-gone function.
This is DinkumWare's implementation problem.  If you encounter this
problem, you may replace the calls here with good old isspace() and
iswspace() from the CRT unless they specify SS_ANSI</p>

        </td>
        <td class="code highlight">
          <pre class="c">    
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_NO_LOCALE</span>
	
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(CT t)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> !ssisspace(t); }

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::locale loc;
	NotSpace(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::locale&amp; locArg=<span class="hljs-built_in">std</span>::locale()) : loc(locArg) {}
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(CT t)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> !<span class="hljs-built_in">std</span>::<span class="hljs-built_in">isspace</span>(t, loc); }
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
};




</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-104" id="section-104"></a>
</div>
<pre><code>	Now we can define the template (finally!)
</code></pre>
<p>=============================================================================
TEMPLATE: CStdStr
	template<typename CT> class CStdStr : public std::basic_string<CT></p>
<p>REMARKS:
	This template derives from basic_string<CT> and adds some MFC CString-
	like functionality</p>
<pre><code>Basically, this is my attempt to make Standard C++ library strings as
easy to use as the MFC CString class.

Note that although this is a template, it makes the assumption that the
template argument (CT, the character type) is either char or wchar_t.  
</code></pre>
<p>=============================================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-105" id="section-105"></a>
</div>
<p>#define CStdStr _SS	// avoid compiler warning 4786</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-106" id="section-106"></a>
</div>
<p>template<typename ARG> ARG&amp; FmtArg(ARG&amp; arg)  { return arg; }
PCSTR  FmtArg(const std::string&amp; arg)  { return arg.c_str(); }
PCWSTR FmtArg(const std::wstring&amp; arg) { return arg.c_str(); }</p>

        </td>
        <td class="code highlight">
          <pre class="c">
template&lt;typename ARG&gt;
struct FmtArg
{
    explicit FmtArg(const ARG&amp; arg) : a_(arg) {}
    const ARG&amp; operator()() const { return a_; }
    const ARG&amp; a_;
private:
    FmtArg&amp; operator=(const FmtArg&amp;) { return *this; }
};

template&lt;typename CT&gt;
class CStdStr : public std::basic_string&lt;CT&gt;
{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-107" id="section-107"></a>
</div>
<p>Typedefs for shorter names.  Using these names also appears to help
us avoid some ambiguities that otherwise arise on some platforms</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MYBASE std::basic_string<span class="hljs-meta-string">&lt;CT&gt;</span>				 <span class="hljs-comment">// my base class</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-108" id="section-108"></a>
</div>
<p>typedef typename std::basic_string<CT>		MYBASE;	 // my base class</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-keyword">typedef</span> CStdStr&lt;CT&gt;							MYTYPE;	 <span class="hljs-comment">// myself</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MYBASE::const_pointer		PCMYSTR; <span class="hljs-comment">// PCSTR or PCWSTR </span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MYBASE::pointer			PMYSTR;	 <span class="hljs-comment">// PSTR or PWSTR</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MYBASE::iterator			MYITER;  <span class="hljs-comment">// my iterator type</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MYBASE::const_iterator		MYCITER; <span class="hljs-comment">// you get the idea...</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MYBASE::reverse_iterator	MYRITER;
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MYBASE::size_type			MYSIZE;   
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MYBASE::value_type			MYVAL; 
	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MYBASE::allocator_type		MYALLOC;
	
<span class="hljs-keyword">public</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-109" id="section-109"></a>
</div>
<p>shorthand conversion from PCTSTR to string resource ID</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSRES(pctstr)  LOWORD(reinterpret_cast<span class="hljs-meta-string">&lt;unsigned long&gt;</span>(pctstr))	</span>

	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TryLoad</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* pT)</span>
	</span>{
		<span class="hljs-keyword">bool</span> bLoaded = <span class="hljs-literal">false</span>;

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(SS_WIN32) &amp;&amp; !defined(SS_ANSI)</span>
		<span class="hljs-keyword">if</span> ( ( pT != <span class="hljs-literal">NULL</span> ) &amp;&amp; SS_IS_INTRESOURCE(pT) )
		{
			UINT nId = LOWORD(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>&gt;(pT));
			<span class="hljs-keyword">if</span> ( !LoadString(nId) )
			{
				TRACE(_T(<span class="hljs-string">"Can't load string %u\n"</span>), SSRES(pT));
			}
			bLoaded = <span class="hljs-literal">true</span>;
		}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

		<span class="hljs-keyword">return</span> bLoaded;
	}


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-110" id="section-110"></a>
</div>
<p>CStdStr inline constructors</p>

        </td>
        <td class="code highlight">
          <pre class="c">	CStdStr()
	{
	}

	CStdStr(<span class="hljs-keyword">const</span> MYTYPE&amp; str) : MYBASE(SSREF(str))
	{
	}

	CStdStr(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; str)
	{
		ssasn(*<span class="hljs-keyword">this</span>, SSREF(str));
	}

	CStdStr(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::wstring&amp; str)
	{
		ssasn(*<span class="hljs-keyword">this</span>, SSREF(str));
	}

	CStdStr(PCMYSTR pT, MYSIZE n) : MYBASE(<span class="hljs-literal">NULL</span> == pT ? MYTYPE().c_str() : pT, n)
	{
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_UNSIGNED</span>
	CStdStr(PCUSTR pU)
	{
		*<span class="hljs-keyword">this</span> = <span class="hljs-keyword">reinterpret_cast</span>&lt;PCSTR&gt;(pU);
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

	CStdStr(PCSTR pA)
	{
	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_ANSI</span>
		*<span class="hljs-keyword">this</span> = pA;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		<span class="hljs-keyword">if</span> ( !TryLoad(pA) )
			*<span class="hljs-keyword">this</span> = pA;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}

	CStdStr(PCWSTR pW)
	{
	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_ANSI</span>
		*<span class="hljs-keyword">this</span> = pW;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		<span class="hljs-keyword">if</span> ( !TryLoad(pW) )
			*<span class="hljs-keyword">this</span> = pW;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}

	CStdStr(MYCITER first, MYCITER last)
		: MYBASE(first, last)
	{
	}

	CStdStr(MYSIZE nSize, MYVAL ch, <span class="hljs-keyword">const</span> MYALLOC&amp; al=MYALLOC())
		: MYBASE(nSize, ch, al)
	{
	}

	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_INC_COMDEF</span>
		CStdStr(<span class="hljs-keyword">const</span> <span class="hljs-keyword">_bstr_t</span>&amp; bstr)
		{
			<span class="hljs-keyword">if</span> ( bstr.length() &gt; <span class="hljs-number">0</span> )
				<span class="hljs-keyword">this</span>-&gt;append(<span class="hljs-keyword">static_cast</span>&lt;PCMYSTR&gt;(bstr), bstr.length());
		}
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-111" id="section-111"></a>
</div>
<p>CStdStr inline assignment operators -- the ssasn function now takes care
of fixing  the MSVC assignment bug (see knowledge base article Q172398).</p>

        </td>
        <td class="code highlight">
          <pre class="c">	MYTYPE&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MYTYPE&amp; str)
	{ 
		ssasn(*<span class="hljs-keyword">this</span>, str); 
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	MYTYPE&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; str)
	{
		ssasn(*<span class="hljs-keyword">this</span>, str);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	MYTYPE&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::wstring&amp; str)
	{
		ssasn(*<span class="hljs-keyword">this</span>, str);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	MYTYPE&amp; <span class="hljs-keyword">operator</span>=(PCSTR pA)
	{
		ssasn(*<span class="hljs-keyword">this</span>, pA);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	MYTYPE&amp; <span class="hljs-keyword">operator</span>=(PCWSTR pW)
	{
		ssasn(*<span class="hljs-keyword">this</span>, pW);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_UNSIGNED</span>
	MYTYPE&amp; <span class="hljs-keyword">operator</span>=(PCUSTR pU)
	{
		ssasn(*<span class="hljs-keyword">this</span>, <span class="hljs-keyword">reinterpret_cast</span>&lt;PCSTR&gt;(pU));
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

	MYTYPE&amp; <span class="hljs-keyword">operator</span>=(CT t)
	{
		Q172398(*<span class="hljs-keyword">this</span>);
		<span class="hljs-keyword">this</span>-&gt;assign(<span class="hljs-number">1</span>, t);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_INC_COMDEF</span>
		MYTYPE&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">_bstr_t</span>&amp; bstr)
		{
			<span class="hljs-keyword">if</span> ( bstr.length() &gt; <span class="hljs-number">0</span> )
			{
				<span class="hljs-keyword">this</span>-&gt;assign(<span class="hljs-keyword">static_cast</span>&lt;PCMYSTR&gt;(bstr), bstr.length());
				<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
			}
			<span class="hljs-keyword">else</span>
			{
				<span class="hljs-keyword">this</span>-&gt;erase();
				<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
			}
		}
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-112" id="section-112"></a>
</div>
<p>Overloads  also needed to fix the MSVC assignment bug (KB: Q172398)
*** Thanks to Pete The Plumber for catching this one ***
They also are compiled if you have explicitly turned off refcounting</p>

        </td>
        <td class="code highlight">
          <pre class="c">	#if ( defined(_MSC_VER) &amp;&amp; ( _MSC_VER &lt; 1200 ) ) || defined(SS_NO_REFCOUNT) 

		MYTYPE&amp; assign(const MYTYPE&amp; str)
		{
			Q172398(*this);
			sscpy(GetBuffer(str.size()+1), SSREF(str));
			this-&gt;ReleaseBuffer(str.size());
			return *this;
		}

		MYTYPE&amp; assign(const MYTYPE&amp; str, MYSIZE nStart, MYSIZE nChars)
		{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-113" id="section-113"></a>
</div>
<p>This overload of basic_string::assign is supposed to assign up to
<nChars> or the NULL terminator, whichever comes first.  Since we
are about to call a less forgiving overload (in which <nChars>
must be a valid length), we must adjust the length here to a safe
value.  Thanks to Ullrich Pollähne for catching this bug</p>

        </td>
        <td class="code highlight">
          <pre class="c">
			nChars		= SSMIN(nChars, str.length() - nStart);
			MYTYPE strTemp(str.c_str()+nStart, nChars);
			Q172398(*this);
			this-&gt;assign(strTemp);
			return *this;
		}

		MYTYPE&amp; assign(const MYBASE&amp; str)
		{
			ssasn(*this, str);
			return *this;
		}

		MYTYPE&amp; assign(const MYBASE&amp; str, MYSIZE nStart, MYSIZE nChars)
		{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-114" id="section-114"></a>
</div>
<p>This overload of basic_string::assign is supposed to assign up to
<nChars> or the NULL terminator, whichever comes first.  Since we
are about to call a less forgiving overload (in which <nChars>
must be a valid length), we must adjust the length here to a safe
value. Thanks to Ullrich Pollähne for catching this bug</p>

        </td>
        <td class="code highlight">
          <pre class="c">
			nChars		= SSMIN(nChars, str.length() - nStart);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-115" id="section-115"></a>
</div>
<p>Watch out for assignment to self</p>

        </td>
        <td class="code highlight">
          <pre class="c">
			if ( this == &amp;str )
			{
				MYTYPE strTemp(str.c_str() + nStart, nChars);
				static_cast&lt;MYBASE*&gt;(this)-&gt;assign(strTemp);
			}
			else
			{
				Q172398(*this);
				static_cast&lt;MYBASE*&gt;(this)-&gt;assign(str.c_str()+nStart, nChars);
			}
			return *this;
		}

		MYTYPE&amp; assign(const CT* pC, MYSIZE nChars)
		{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-116" id="section-116"></a>
</div>
<p>Q172398 only fix -- erase before assigning, but not if we're
assigning from our own buffer</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	#if defined ( _MSC_VER ) &amp;&amp; ( _MSC_VER &lt; 1200 )
			if ( !this-&gt;empty() &amp;&amp;
				( pC &lt; this-&gt;data() || pC &gt; this-&gt;data() + this-&gt;capacity() ) )
			{
				this-&gt;erase();
			}
	#endif
			Q172398(*this);
			static_cast&lt;MYBASE*&gt;(this)-&gt;assign(pC, nChars);
			return *this;
		}

		MYTYPE&amp; assign(MYSIZE nChars, MYVAL val)
		{
			Q172398(*this);
			static_cast&lt;MYBASE*&gt;(this)-&gt;assign(nChars, val);
			return *this;
		}

		MYTYPE&amp; assign(const CT* pT)
		{
			return this-&gt;assign(pT, MYBASE::traits_type::length(pT));
		}

		MYTYPE&amp; assign(MYCITER iterFirst, MYCITER iterLast)
		{
	#if defined ( _MSC_VER ) &amp;&amp; ( _MSC_VER &lt; 1200 ) 
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-117" id="section-117"></a>
</div>
<p>Q172398 fix.  don't call erase() if we're assigning from ourself</p>

        </td>
        <td class="code highlight">
          <pre class="c">			<span class="hljs-keyword">if</span> ( iterFirst &lt; <span class="hljs-keyword">this</span>-&gt;begin() ||
                 iterFirst &gt; <span class="hljs-keyword">this</span>-&gt;begin() + <span class="hljs-keyword">this</span>-&gt;size() )
            {
				<span class="hljs-keyword">this</span>-&gt;erase()
            }
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
			<span class="hljs-keyword">this</span>-&gt;replace(<span class="hljs-keyword">this</span>-&gt;begin(), <span class="hljs-keyword">this</span>-&gt;end(), iterFirst, iterLast);
			<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
		}
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="cstdstr-inline-concatenation">
  <h2>
    <a href="#cstdstr-inline-concatenation" name="cstdstr-inline-concatenation" class="pilcrow"></a>
CStdStr inline concatenation.
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">	MYTYPE&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> MYTYPE&amp; str)
	{
		ssadd(*<span class="hljs-keyword">this</span>, str);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	MYTYPE&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; str)
	{
		ssadd(*<span class="hljs-keyword">this</span>, str);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; 
	}

	MYTYPE&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::wstring&amp; str)
	{
		ssadd(*<span class="hljs-keyword">this</span>, str);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	MYTYPE&amp; <span class="hljs-keyword">operator</span>+=(PCSTR pA)
	{
		ssadd(*<span class="hljs-keyword">this</span>, pA);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	MYTYPE&amp; <span class="hljs-keyword">operator</span>+=(PCWSTR pW)
	{
		ssadd(*<span class="hljs-keyword">this</span>, pW);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	MYTYPE&amp; <span class="hljs-keyword">operator</span>+=(CT t)
	{
		<span class="hljs-keyword">this</span>-&gt;append(<span class="hljs-number">1</span>, t);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}
	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_INC_COMDEF	<span class="hljs-comment">// if we have _bstr_t, define a += for it too.</span></span>
		MYTYPE&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">_bstr_t</span>&amp; bstr)
		{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">static_cast</span>&lt;PCMYSTR&gt;(bstr));
		}
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="case-changing-functions">
  <h2>
    <a href="#case-changing-functions" name="case-changing-functions" class="pilcrow"></a>
Case changing functions
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
    MYTYPE&amp; ToUpper(const std::locale&amp; loc=std::locale())
	{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-120" id="section-120"></a>
</div>
<p>Note -- if there are any MBCS character sets in which the lowercase
form a character takes up a different number of bytes than the
uppercase form, this would probably not work...</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-built_in">std</span>::transform(<span class="hljs-keyword">this</span>-&gt;begin(),
					   <span class="hljs-keyword">this</span>-&gt;end(),
					   <span class="hljs-keyword">this</span>-&gt;begin(),
#ifdef SS_NO_LOCALE
					   SSToUpper&lt;CT&gt;());
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
					   <span class="hljs-built_in">std</span>::bind2nd(SSToUpper&lt;CT&gt;(), loc));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-121" id="section-121"></a>
</div>
<p>...but if it were, this would probably work better.  Also, this way
seems to be a bit faster when anything other then the &quot;C&quot; locale is
used...</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-122" id="section-122"></a>
</div>
<pre><code>if ( !empty() )
{
	ssupr(this-&gt;GetBuf(), this-&gt;size(), loc);
	this-&gt;RelBuf();
}
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">
		return *this;
	}

	MYTYPE&amp; ToLower(const std::locale&amp; loc=std::locale())
	{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-123" id="section-123"></a>
</div>
<p>Note -- if there are any MBCS character sets in which the lowercase
form a character takes up a different number of bytes than the
uppercase form, this would probably not work...</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-built_in">std</span>::transform(<span class="hljs-keyword">this</span>-&gt;begin(),
					   <span class="hljs-keyword">this</span>-&gt;end(),
					   <span class="hljs-keyword">this</span>-&gt;begin(),
#ifdef SS_NO_LOCALE
					   SSToLower&lt;CT&gt;());
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
					   <span class="hljs-built_in">std</span>::bind2nd(SSToLower&lt;CT&gt;(), loc));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-124" id="section-124"></a>
</div>
<p>...but if it were, this would probably work better.  Also, this way
seems to be a bit faster when anything other then the &quot;C&quot; locale is
used...</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-125" id="section-125"></a>
</div>
<pre><code>if ( !empty() )
{
	sslwr(this-&gt;GetBuf(), this-&gt;size(), loc);
	this-&gt;RelBuf();
}
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}


	<span class="hljs-function">MYTYPE&amp; <span class="hljs-title">Normalize</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> Trim().ToLower();
	}


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="cstdstr-direct-access-to-character-buffer.in-the-ms-implementation-the-at-function-that-we-use-here-also-calls-_freeze-providing-us-some-protection-from-multithreading-problems-associated-with-ref-counting.in-vc-7-and-later-of-course-the-ref-counting-stuff-is-gone">
  <h2>
    <a href="#cstdstr-direct-access-to-character-buffer.in-the-ms-implementation-the-at-function-that-we-use-here-also-calls-_freeze-providing-us-some-protection-from-multithreading-problems-associated-with-ref-counting.in-vc-7-and-later-of-course-the-ref-counting-stuff-is-gone" name="cstdstr-direct-access-to-character-buffer.in-the-ms-implementation-the-at-function-that-we-use-here-also-calls-_freeze-providing-us-some-protection-from-multithreading-problems-associated-with-ref-counting.in-vc-7-and-later-of-course-the-ref-counting-stuff-is-gone" class="pilcrow"></a>
CStdStr -- Direct access to character buffer.  In the MS' implementation,
the at() function that we use here also calls _Freeze() providing us some
protection from multithreading problems associated with ref-counting.
In VC 7 and later, of course, the ref-counting stuff is gone.
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-function">CT* <span class="hljs-title">GetBuf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nMinLen=<span class="hljs-number">-1</span>)</span>
	</span>{
		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">this</span>-&gt;size()) &lt; nMinLen )
			<span class="hljs-keyword">this</span>-&gt;resize(<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nMinLen));

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;empty() ? <span class="hljs-keyword">const_cast</span>&lt;CT*&gt;(<span class="hljs-keyword">this</span>-&gt;data()) : &amp;(<span class="hljs-keyword">this</span>-&gt;at(<span class="hljs-number">0</span>));
	}

	<span class="hljs-function">CT* <span class="hljs-title">SetBuf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nLen)</span>
	</span>{
		nLen = ( nLen &gt; <span class="hljs-number">0</span> ? nLen : <span class="hljs-number">0</span> );
		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>-&gt;capacity() &lt; <span class="hljs-number">1</span> &amp;&amp; nLen == <span class="hljs-number">0</span> )
			<span class="hljs-keyword">this</span>-&gt;resize(<span class="hljs-number">1</span>);

		<span class="hljs-keyword">this</span>-&gt;resize(<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nLen));
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">const_cast</span>&lt;CT*&gt;(<span class="hljs-keyword">this</span>-&gt;data());
	}
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RelBuf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nNewLen=<span class="hljs-number">-1</span>)</span>
	</span>{
		<span class="hljs-keyword">this</span>-&gt;resize(<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nNewLen &gt; <span class="hljs-number">-1</span> ? nNewLen :
                                                        sslen(<span class="hljs-keyword">this</span>-&gt;c_str())));
	}

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BufferRel</span><span class="hljs-params">()</span>		 </span>{ RelBuf(); }			<span class="hljs-comment">// backwards compatability</span>
	<span class="hljs-function">CT*  <span class="hljs-title">Buffer</span><span class="hljs-params">()</span>			 </span>{ <span class="hljs-keyword">return</span> GetBuf(); }	<span class="hljs-comment">// backwards compatability</span>
	<span class="hljs-function">CT*  <span class="hljs-title">BufferSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nLen)</span> </span>{ <span class="hljs-keyword">return</span> SetBuf(nLen);}<span class="hljs-comment">// backwards compatability</span>

	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Equals</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* pT, <span class="hljs-keyword">bool</span> bUseCase=<span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-keyword">return</span>  <span class="hljs-number">0</span> == (bUseCase ? <span class="hljs-keyword">this</span>-&gt;compare(pT) : ssicmp(<span class="hljs-keyword">this</span>-&gt;c_str(), pT));
	} 

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<p>FUNCTION:  CStdStr::Load
REMARKS:
	Loads string from resource specified by nID</p>
<p>PARAMETERS:
	nID - resource Identifier.  Purely a Win32 thing in this case</p>
<div class="pilwrap" id="return-value-true-if-successful-false-otherwise">
  <h2>
    <a href="#return-value-true-if-successful-false-otherwise" name="return-value-true-if-successful-false-otherwise" class="pilcrow"></a>
RETURN VALUE:
	true if successful, false otherwise
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_ANSI</span>

	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Load</span><span class="hljs-params">(UINT nId, HMODULE hModule=<span class="hljs-literal">NULL</span>)</span>
	</span>{
		<span class="hljs-keyword">bool</span> bLoaded		= <span class="hljs-literal">false</span>;	<span class="hljs-comment">// set to true of we succeed.</span>

	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MFC_VER		<span class="hljs-comment">// When in Rome (or MFC land)...</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-128" id="section-128"></a>
</div>
<p>If they gave a resource handle, use it.  Note - this is archaic
and not really what I would recommend.  But then again, in MFC
land, you ought to be using CString for resources anyway since
it walks the resource chain for you.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		HMODULE hModuleOld = <span class="hljs-literal">NULL</span>;

		<span class="hljs-keyword">if</span> ( <span class="hljs-literal">NULL</span> != hModule )
		{
			hModuleOld = AfxGetResourceHandle();
			AfxSetResourceHandle(hModule);
		}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-129" id="section-129"></a>
</div>
<p>...load the string</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		CString strRes;
		bLoaded				= FALSE != strRes.LoadString(nId);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-130" id="section-130"></a>
</div>
<p>...and if we set the resource handle, restore it.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-keyword">if</span> ( <span class="hljs-literal">NULL</span> != hModuleOld )
			AfxSetResourceHandle(hModule);

		<span class="hljs-keyword">if</span> ( bLoaded )
			*<span class="hljs-keyword">this</span>			= strRes;

	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> <span class="hljs-comment">// otherwise make our own hackneyed version of CString's Load</span></span>
		
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-131" id="section-131"></a>
</div>
<p>Get the resource name and module handle</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-keyword">if</span> ( <span class="hljs-literal">NULL</span> == hModule )
			hModule			= GetResourceHandle();

		PCTSTR szName		= MAKEINTRESOURCE((nId&gt;&gt;<span class="hljs-number">4</span>)+<span class="hljs-number">1</span>); <span class="hljs-comment">// lifted </span>
		DWORD dwSize		= <span class="hljs-number">0</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-132" id="section-132"></a>
</div>
<p>No sense continuing if we can't find the resource</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		HRSRC hrsrc			= ::FindResource(hModule, szName, RT_STRING);

		<span class="hljs-keyword">if</span> ( <span class="hljs-literal">NULL</span> == hrsrc )
		{
			TRACE(_T(<span class="hljs-string">"Cannot find resource %d: 0x%X"</span>), nId, ::GetLastError());
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> == (dwSize = ::SizeofResource(hModule, hrsrc) / <span class="hljs-keyword">sizeof</span>(CT)))
		{
			TRACE(_T(<span class="hljs-string">"Cant get size of resource %d 0x%X\n"</span>),nId,GetLastError());
		}
		<span class="hljs-keyword">else</span>
		{
			bLoaded			= <span class="hljs-number">0</span> != ssload(hModule, nId, GetBuf(dwSize), dwSize);
			ReleaseBuffer();
		}

	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// #ifdef _MFC_VER</span></span>

		<span class="hljs-keyword">if</span> ( !bLoaded )
			TRACE(_T(<span class="hljs-string">"String not loaded 0x%X\n"</span>), ::GetLastError());

		<span class="hljs-keyword">return</span> bLoaded;
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// #ifdef SS_ANSI</span></span>
	
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<p>FUNCTION:  CStdStr::Format
	void _cdecl Formst(CStdStringA&amp; PCSTR szFormat, ...)
	void _cdecl Format(PCSTR szFormat);</p>
<p>DESCRIPTION:
	This function does sprintf/wsprintf style formatting on CStdStringA
	objects.  It looks a lot like MFC's CString::Format.  Some people
	might even call this identical.  Fortunately, these people are now
	dead... heh heh.</p>
<p>PARAMETERS:
	nId - ID of string resource holding the format string
	szFormat - a PCSTR holding the format specifiers
	argList - a va_list holding the arguments for the format specifiers.</p>
<div class="pilwrap" id="return-value-none-1">
  <h2>
    <a href="#return-value-none-1" name="return-value-none-1" class="pilcrow"></a>
RETURN VALUE:  None.
  </h2>
</div>
<p>formatting (using wsprintf style formatting)</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-134" id="section-134"></a>
</div>
<p>If they want a Format() function that safely handles string objects
without casting</p>

        </td>
        <td class="code highlight">
          <pre class="c"> 
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_SAFE_FORMAT       </span>
    
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-135" id="section-135"></a>
</div>
<p>Question:  Joe, you wacky coder you, why do you have so many overloads
of the Format() function
Answer:  One reason only - CString compatability.  In short, by making
the Format() function a template this way, I can do strong typing
and allow people to pass CStdString arguments as fillers for
&quot;%s&quot; format specifiers without crashing their program!  The downside
is that I need to overload on the number of arguments.   If you are
passing more arguments than I have listed below in any of my
overloads, just add another one.</p>
<pre><code> Yes, yes, this is really ugly.  In essence what I am doing here is
 protecting people from a bad (and incorrect) programming practice
 that they should not be doing anyway.  I am protecting them from
 themselves.  Why am I doing this?  Well, if you had any idea the
 number of times I've been emailed by people about this
 &quot;incompatability&quot; in my code, you wouldn't ask.
</code></pre>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fmt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, ...)</span>
	</span>{
		va_list argList;
		va_start(argList, szFmt);
		FormatV(szFmt, argList);
		va_end(argList);
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_ANSI</span>

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) ) 
            <span class="hljs-keyword">this</span>-&gt;swap(strFmt);
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
            Fmt(strFmt, FmtArg&lt;A1&gt;(v)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
           Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(),FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(),FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
           Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
                FmtArg&lt;A9&gt;(v9)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
                FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
                FmtArg&lt;A9&gt;(v9)(),FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
                FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
                FmtArg&lt;A12&gt;(v12)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12,
        <span class="hljs-keyword">class</span> A13&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12, <span class="hljs-keyword">const</span> A13&amp; v13)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
                FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
                FmtArg&lt;A12&gt;(v12)(), FmtArg&lt;A13&gt;(v13)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12,
        <span class="hljs-keyword">class</span> A13, <span class="hljs-keyword">class</span> A14&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12, <span class="hljs-keyword">const</span> A13&amp; v13, <span class="hljs-keyword">const</span> A14&amp; v14)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
                FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
                FmtArg&lt;A12&gt;(v12)(), FmtArg&lt;A13&gt;(v13)(),FmtArg&lt;A14&gt;(v14)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12,
        <span class="hljs-keyword">class</span> A13, <span class="hljs-keyword">class</span> A14, <span class="hljs-keyword">class</span> A15&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12, <span class="hljs-keyword">const</span> A13&amp; v13, <span class="hljs-keyword">const</span> A14&amp; v14, <span class="hljs-keyword">const</span> A15&amp; v15)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
                FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
                FmtArg&lt;A12&gt;(v12)(),FmtArg&lt;A13&gt;(v13)(),FmtArg&lt;A14&gt;(v14)(),
                FmtArg&lt;A15&gt;(v15)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12,
        <span class="hljs-keyword">class</span> A13, <span class="hljs-keyword">class</span> A14, <span class="hljs-keyword">class</span> A15, <span class="hljs-keyword">class</span> A16&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12, <span class="hljs-keyword">const</span> A13&amp; v13, <span class="hljs-keyword">const</span> A14&amp; v14, <span class="hljs-keyword">const</span> A15&amp; v15,
                <span class="hljs-keyword">const</span> A16&amp; v16)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
                FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
                FmtArg&lt;A12&gt;(v12)(),FmtArg&lt;A13&gt;(v13)(),FmtArg&lt;A14&gt;(v14)(),
                FmtArg&lt;A15&gt;(v15)(), FmtArg&lt;A16&gt;(v16)());
        }
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12,
        <span class="hljs-keyword">class</span> A13, <span class="hljs-keyword">class</span> A14, <span class="hljs-keyword">class</span> A15, <span class="hljs-keyword">class</span> A16, <span class="hljs-keyword">class</span> A17&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12, <span class="hljs-keyword">const</span> A13&amp; v13, <span class="hljs-keyword">const</span> A14&amp; v14, <span class="hljs-keyword">const</span> A15&amp; v15,
                <span class="hljs-keyword">const</span> A16&amp; v16, <span class="hljs-keyword">const</span> A17&amp; v17)</span>
    </span>{
		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
        {
            Fmt(strFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
                FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
                FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
                FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
                FmtArg&lt;A12&gt;(v12)(),FmtArg&lt;A13&gt;(v13)(),FmtArg&lt;A14&gt;(v14)(),
                FmtArg&lt;A15&gt;(v15)(),FmtArg&lt;A16&gt;(v16)(),FmtArg&lt;A17&gt;(v17)());
        }
    }
    
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifndef SS_ANSI</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-136" id="section-136"></a>
</div>
<p>...now the other overload of Format: the one that takes a string literal</p>

        </td>
        <td class="code highlight">
          <pre class="c">
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt)</span>
    </span>{
        *<span class="hljs-keyword">this</span> = szFmt;
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
            FmtArg&lt;A9&gt;(v9)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
            FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
            FmtArg&lt;A9&gt;(v9)(),FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
            FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
            FmtArg&lt;A12&gt;(v12)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12,
        <span class="hljs-keyword">class</span> A13&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12, <span class="hljs-keyword">const</span> A13&amp; v13)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
            FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
            FmtArg&lt;A12&gt;(v12)(), FmtArg&lt;A13&gt;(v13)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12,
        <span class="hljs-keyword">class</span> A13, <span class="hljs-keyword">class</span> A14&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12, <span class="hljs-keyword">const</span> A13&amp; v13, <span class="hljs-keyword">const</span> A14&amp; v14)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
            FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
            FmtArg&lt;A12&gt;(v12)(), FmtArg&lt;A13&gt;(v13)(),FmtArg&lt;A14&gt;(v14)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12,
        <span class="hljs-keyword">class</span> A13, <span class="hljs-keyword">class</span> A14, <span class="hljs-keyword">class</span> A15&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12, <span class="hljs-keyword">const</span> A13&amp; v13, <span class="hljs-keyword">const</span> A14&amp; v14, <span class="hljs-keyword">const</span> A15&amp; v15)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
            FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
            FmtArg&lt;A12&gt;(v12)(),FmtArg&lt;A13&gt;(v13)(),FmtArg&lt;A14&gt;(v14)(),
            FmtArg&lt;A15&gt;(v15)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12,
        <span class="hljs-keyword">class</span> A13, <span class="hljs-keyword">class</span> A14, <span class="hljs-keyword">class</span> A15, <span class="hljs-keyword">class</span> A16&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12, <span class="hljs-keyword">const</span> A13&amp; v13, <span class="hljs-keyword">const</span> A14&amp; v14, <span class="hljs-keyword">const</span> A15&amp; v15,
                <span class="hljs-keyword">const</span> A16&amp; v16)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
            FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
            FmtArg&lt;A12&gt;(v12)(),FmtArg&lt;A13&gt;(v13)(),FmtArg&lt;A14&gt;(v14)(),
            FmtArg&lt;A15&gt;(v15)(), FmtArg&lt;A16&gt;(v16)());
    }
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> A1, <span class="hljs-keyword">class</span> A2, <span class="hljs-keyword">class</span> A3, <span class="hljs-keyword">class</span> A4, <span class="hljs-keyword">class</span> A5, <span class="hljs-keyword">class</span> A6,
        <span class="hljs-keyword">class</span> A7, <span class="hljs-keyword">class</span> A8, <span class="hljs-keyword">class</span> A9, <span class="hljs-keyword">class</span> A10, <span class="hljs-keyword">class</span> A11, <span class="hljs-keyword">class</span> A12,
        <span class="hljs-keyword">class</span> A13, <span class="hljs-keyword">class</span> A14, <span class="hljs-keyword">class</span> A15, <span class="hljs-keyword">class</span> A16, <span class="hljs-keyword">class</span> A17&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, <span class="hljs-keyword">const</span> A1&amp; v1, <span class="hljs-keyword">const</span> A2&amp; v2, <span class="hljs-keyword">const</span> A3&amp; v3,
                <span class="hljs-keyword">const</span> A4&amp; v4, <span class="hljs-keyword">const</span> A5&amp; v5, <span class="hljs-keyword">const</span> A6&amp; v6, <span class="hljs-keyword">const</span> A7&amp; v7,
                <span class="hljs-keyword">const</span> A8&amp; v8, <span class="hljs-keyword">const</span> A9&amp; v9, <span class="hljs-keyword">const</span> A10&amp; v10, <span class="hljs-keyword">const</span> A11&amp; v11,
                <span class="hljs-keyword">const</span> A12&amp; v12, <span class="hljs-keyword">const</span> A13&amp; v13, <span class="hljs-keyword">const</span> A14&amp; v14, <span class="hljs-keyword">const</span> A15&amp; v15,
                <span class="hljs-keyword">const</span> A16&amp; v16, <span class="hljs-keyword">const</span> A17&amp; v17)</span>
    </span>{
        Fmt(szFmt, FmtArg&lt;A1&gt;(v1)(), FmtArg&lt;A2&gt;(v2)(),
            FmtArg&lt;A3&gt;(v3)(), FmtArg&lt;A4&gt;(v4)(), FmtArg&lt;A5&gt;(v5)(),
            FmtArg&lt;A6&gt;(v6)(), FmtArg&lt;A7&gt;(v7)(), FmtArg&lt;A8&gt;(v8)(),
            FmtArg&lt;A9&gt;(v9)(), FmtArg&lt;A10&gt;(v10)(),FmtArg&lt;A11&gt;(v11)(),
            FmtArg&lt;A12&gt;(v12)(),FmtArg&lt;A13&gt;(v13)(),FmtArg&lt;A14&gt;(v14)(),
            FmtArg&lt;A15&gt;(v15)(),FmtArg&lt;A16&gt;(v16)(),FmtArg&lt;A17&gt;(v17)());
    }

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>  <span class="hljs-comment">// #ifdef SS_SAFE_FORMAT</span></span>


<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_ANSI</span>

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(UINT nId, ...)</span>
	</span>{
		va_list argList;
		va_start(argList, nId);

		MYTYPE strFmt;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
			FormatV(strFmt, argList);

		va_end(argList);
	}
    
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// #ifdef SS_ANSI</span></span>

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, ...)</span>
	</span>{
		va_list argList;
		va_start(argList, szFmt);
		FormatV(szFmt, argList);
		va_end(argList);
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifdef SS_SAFE_FORMAT</span></span>

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AppendFormat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, ...)</span>
	</span>{
		va_list argList;
		va_start(argList, szFmt);
		AppendFormatV(szFmt, argList);
		va_end(argList);
	}

	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_FMT_TRIES		5	 <span class="hljs-comment">// #of times we try </span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FMT_BLOCK_SIZE		2048 <span class="hljs-comment">// # of bytes to increment per try</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFSIZE_1ST	256</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFSIZE_2ND 512</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STD_BUF_SIZE		1024</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-137" id="section-137"></a>
</div>
<p>an efficient way to add formatted characters to the string.  You may only
add up to STD_BUF_SIZE characters at a time, though</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AppendFormatV</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFmt, va_list argList)</span>
	</span>{
		CT szBuf[STD_BUF_SIZE];
		<span class="hljs-keyword">int</span> nLen = ssvsprintf(szBuf, STD_BUF_SIZE<span class="hljs-number">-1</span>, szFmt, argList);

		<span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> &lt; nLen )
			<span class="hljs-keyword">this</span>-&gt;append(szBuf, nLen);
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<p>FUNCTION:  FormatV
	void FormatV(PCSTR szFormat, va_list, argList);</p>
<p>DESCRIPTION:
	This function formats the string with sprintf style format-specs.
	It makes a general guess at required buffer size and then tries
	successively larger buffers until it finds one big enough or a
	threshold (MAX_FMT_TRIES) is exceeded.</p>
<p>PARAMETERS:
	szFormat - a PCSTR holding the format of the output
	argList - a Microsoft specific va_list for variable argument lists</p>
<div class="pilwrap" id="return-value">
  <h2>
    <a href="#return-value" name="return-value" class="pilcrow"></a>
RETURN VALUE:
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FormatV</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CT* szFormat, va_list argList)</span>
	</span>{
	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_ANSI</span>
		MYTYPE str;
		<span class="hljs-keyword">int</span> nLen	= sslen(szFormat) + STD_BUF_SIZE;
		ssvsprintf(str.GetBuffer(nLen), nLen<span class="hljs-number">-1</span>, szFormat, argList);
		str.ReleaseBuffer();
		*<span class="hljs-keyword">this</span> = str;

	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>

		CT* pBuf			= <span class="hljs-literal">NULL</span>;
		<span class="hljs-keyword">int</span> nChars			= <span class="hljs-number">1</span>;
		<span class="hljs-keyword">int</span> nUsed			= <span class="hljs-number">0</span>;
		size_type nActual	= <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> nTry			= <span class="hljs-number">0</span>;

		<span class="hljs-keyword">do</span>	
		{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-139" id="section-139"></a>
</div>
<p>Grow more than linearly (e.g. 512, 1536, 3072, etc)</p>

        </td>
        <td class="code highlight">
          <pre class="c">
			nChars			+= ((nTry+<span class="hljs-number">1</span>) * FMT_BLOCK_SIZE);
			pBuf			= <span class="hljs-keyword">reinterpret_cast</span>&lt;CT*&gt;(_alloca(<span class="hljs-keyword">sizeof</span>(CT)*nChars));
			nUsed			= ssvsprintf(pBuf, nChars<span class="hljs-number">-1</span>, szFormat, argList);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-140" id="section-140"></a>
</div>
<p>Ensure proper NULL termination.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
			nActual			= nUsed == <span class="hljs-number">-1</span> ? nChars<span class="hljs-number">-1</span> : SSMIN(nUsed, nChars<span class="hljs-number">-1</span>);
			pBuf[nActual]= <span class="hljs-string">'\0'</span>;


		} <span class="hljs-keyword">while</span> ( nUsed &lt; <span class="hljs-number">0</span> &amp;&amp; nTry++ &lt; MAX_FMT_TRIES );

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-141" id="section-141"></a>
</div>
<p>assign whatever we managed to format</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-keyword">this</span>-&gt;assign(pBuf, nActual);

	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<p>CString Facade Functions:</p>
<div class="pilwrap" id="the-following-methods-are-intended-to-allow-you-to-use-this-class-as-a-near-drop-in-replacement-for-cstring">
  <h2>
    <a href="#the-following-methods-are-intended-to-allow-you-to-use-this-class-as-a-near-drop-in-replacement-for-cstring" name="the-following-methods-are-intended-to-allow-you-to-use-this-class-as-a-near-drop-in-replacement-for-cstring" class="pilcrow"></a>
The following methods are intended to allow you to use this class as a
near drop-in replacement for CString.
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_WIN32</span>
		<span class="hljs-function">BSTR <span class="hljs-title">AllocSysString</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
		</span>{
			ostring os;
			ssasn(os, *<span class="hljs-keyword">this</span>);
			<span class="hljs-keyword">return</span> ::SysAllocString(os.c_str());
		}
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_NO_LOCALE</span>
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Collate</span><span class="hljs-params">(PCMYSTR szThat)</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-keyword">return</span> sscoll(<span class="hljs-keyword">this</span>-&gt;c_str(), <span class="hljs-keyword">this</span>-&gt;length(), szThat, sslen(szThat));
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CollateNoCase</span><span class="hljs-params">(PCMYSTR szThat)</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-keyword">return</span> ssicoll(<span class="hljs-keyword">this</span>-&gt;c_str(), <span class="hljs-keyword">this</span>-&gt;length(), szThat, sslen(szThat));
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Compare</span><span class="hljs-params">(PCMYSTR szThat)</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;compare(szThat);	
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CompareNoCase</span><span class="hljs-params">(PCMYSTR szThat)</span>	<span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-keyword">return</span> ssicmp(<span class="hljs-keyword">this</span>-&gt;c_str(), szThat);
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nIdx, <span class="hljs-keyword">int</span> nCount=<span class="hljs-number">1</span>)</span>
	</span>{
        <span class="hljs-keyword">if</span> ( nIdx &lt; <span class="hljs-number">0</span> )
			nIdx = <span class="hljs-number">0</span>;

		<span class="hljs-keyword">if</span> ( nIdx &lt; <span class="hljs-keyword">this</span>-&gt;GetLength() )
			<span class="hljs-keyword">this</span>-&gt;erase(<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIdx), <span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nCount));

		<span class="hljs-keyword">return</span> GetLength();
	}

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">this</span>-&gt;erase();
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(CT ch)</span> <span class="hljs-keyword">const</span>
	</span>{
		MYSIZE nIdx	= <span class="hljs-keyword">this</span>-&gt;find_first_of(ch);
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(MYBASE::npos == nIdx  ? <span class="hljs-number">-1</span> : nIdx);
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(PCMYSTR szSub)</span> <span class="hljs-keyword">const</span>
	</span>{
		MYSIZE nIdx	= <span class="hljs-keyword">this</span>-&gt;find(szSub);
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(MYBASE::npos == nIdx ? <span class="hljs-number">-1</span> : nIdx);
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(CT ch, <span class="hljs-keyword">int</span> nStart)</span> <span class="hljs-keyword">const</span>
	</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-143" id="section-143"></a>
</div>
<p>CString::Find docs say add 1 to nStart when it's not zero
CString::Find code doesn't do that however.  We'll stick
with what the code does</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		MYSIZE nIdx	= <span class="hljs-keyword">this</span>-&gt;find_first_of(ch, <span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nStart));
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(MYBASE::npos == nIdx ? <span class="hljs-number">-1</span> : nIdx);
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(PCMYSTR szSub, <span class="hljs-keyword">int</span> nStart)</span> <span class="hljs-keyword">const</span>
	</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-144" id="section-144"></a>
</div>
<p>CString::Find docs say add 1 to nStart when it's not zero
CString::Find code doesn't do that however.  We'll stick
with what the code does</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		MYSIZE nIdx	= <span class="hljs-keyword">this</span>-&gt;find(szSub, <span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nStart));
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(MYBASE::npos == nIdx ? <span class="hljs-number">-1</span> : nIdx);
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FindOneOf</span><span class="hljs-params">(PCMYSTR szCharSet)</span> <span class="hljs-keyword">const</span>
	</span>{
		MYSIZE nIdx = <span class="hljs-keyword">this</span>-&gt;find_first_of(szCharSet);
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(MYBASE::npos == nIdx ? <span class="hljs-number">-1</span> : nIdx);
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_ANSI</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FormatMessage</span><span class="hljs-params">(PCMYSTR szFormat, ...)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::exception)</span>
	</span>{
		va_list argList;
		va_start(argList, szFormat);
		PMYSTR szTemp;
		<span class="hljs-keyword">if</span> ( ssfmtmsg(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
					   szFormat, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
					   <span class="hljs-keyword">reinterpret_cast</span>&lt;PMYSTR&gt;(&amp;szTemp), <span class="hljs-number">0</span>, &amp;argList) == <span class="hljs-number">0</span> ||
			 szTemp == <span class="hljs-number">0</span> )
		{
			<span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"out of memory"</span>);
		}
		*<span class="hljs-keyword">this</span> = szTemp;
		LocalFree(szTemp);
		va_end(argList);
	}

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FormatMessage</span><span class="hljs-params">(UINT nFormatId, ...)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::exception)</span>
	</span>{
		MYTYPE sFormat;
		VERIFY(sFormat.LoadString(nFormatId));
		va_list argList;
		va_start(argList, nFormatId);
		PMYSTR szTemp;
		<span class="hljs-keyword">if</span> ( ssfmtmsg(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
					   sFormat, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
					   <span class="hljs-keyword">reinterpret_cast</span>&lt;PMYSTR&gt;(&amp;szTemp), <span class="hljs-number">0</span>, &amp;argList) == <span class="hljs-number">0</span> ||
			szTemp == <span class="hljs-number">0</span>)
		{
			<span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"out of memory"</span>);
		}
		*<span class="hljs-keyword">this</span> = szTemp;
		LocalFree(szTemp);
		va_end(argList);
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-145" id="section-145"></a>
</div>
<p>GetAllocLength -- an MSVC7 function but it costs us nothing to add it.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetAllocLength</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">this</span>-&gt;capacity());
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="getxxxx-direct-access-to-character-buffer">
  <h2>
    <a href="#getxxxx-direct-access-to-character-buffer" name="getxxxx-direct-access-to-character-buffer" class="pilcrow"></a>
GetXXXX -- Direct access to character buffer
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-function">CT <span class="hljs-title">GetAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nIdx)</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;at(<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIdx));
	}

	<span class="hljs-function">CT* <span class="hljs-title">GetBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nMinLen=<span class="hljs-number">-1</span>)</span>
	</span>{
		<span class="hljs-keyword">return</span> GetBuf(nMinLen);
	}

	<span class="hljs-function">CT* <span class="hljs-title">GetBufferSetLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nLen)</span>
	</span>{
		<span class="hljs-keyword">return</span> BufferSet(nLen);
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-147" id="section-147"></a>
</div>
<p>GetLength() -- MFC docs say this is the # of BYTES but
in truth it is the number of CHARACTERs (chars or wchar_ts)</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">this</span>-&gt;length());
	}
	
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-148" id="section-148"></a>
</div>
<p>GetString function added in Visual Studio 2008, if I recall correctly.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
    <span class="hljs-function">PCMYSTR <span class="hljs-title">GetString</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;c_str();
    }

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nIdx, CT ch)</span>
	</span>{
		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIdx) &gt; <span class="hljs-keyword">this</span>-&gt;size()<span class="hljs-number">-1</span> )
			<span class="hljs-keyword">this</span>-&gt;append(<span class="hljs-number">1</span>, ch);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">this</span>-&gt;insert(<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIdx), <span class="hljs-number">1</span>, ch);

		<span class="hljs-keyword">return</span> GetLength();
	}
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nIdx, PCMYSTR sz)</span>
	</span>{
		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIdx) &gt;= <span class="hljs-keyword">this</span>-&gt;size() )
			<span class="hljs-keyword">this</span>-&gt;append(sz, <span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(sslen(sz)));
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">this</span>-&gt;insert(<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIdx), sz);

		<span class="hljs-keyword">return</span> GetLength();
	}

	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;empty();
	}

	<span class="hljs-function">MYTYPE <span class="hljs-title">Left</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nCount)</span> <span class="hljs-keyword">const</span>
	</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-149" id="section-149"></a>
</div>
<p>Range check the count.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		nCount = SSMAX(<span class="hljs-number">0</span>, SSMIN(nCount, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">this</span>-&gt;size())));
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;substr(<span class="hljs-number">0</span>, <span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nCount)); 
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_ANSI</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">LoadString</span><span class="hljs-params">(UINT nId)</span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;Load(nId);
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MakeLower</span><span class="hljs-params">()</span>
	</span>{
		ToLower();
	}

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MakeReverse</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-built_in">std</span>::reverse(<span class="hljs-keyword">this</span>-&gt;begin(), <span class="hljs-keyword">this</span>-&gt;end());
	}

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MakeUpper</span><span class="hljs-params">()</span>
	</span>{ 
		ToUpper();
	}

	<span class="hljs-function">MYTYPE <span class="hljs-title">Mid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nFirst)</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-keyword">return</span> Mid(nFirst, <span class="hljs-keyword">this</span>-&gt;GetLength()-nFirst);
	}

	<span class="hljs-function">MYTYPE <span class="hljs-title">Mid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nFirst, <span class="hljs-keyword">int</span> nCount)</span> <span class="hljs-keyword">const</span>
	</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-150" id="section-150"></a>
</div>
<p>CString does range checking here.  Since we're trying to emulate it,
we must check too.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		<span class="hljs-keyword">if</span> ( nFirst &lt; <span class="hljs-number">0</span> )
			nFirst = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> ( nCount &lt; <span class="hljs-number">0</span> )
			nCount = <span class="hljs-number">0</span>;

		<span class="hljs-keyword">int</span> nSize = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">this</span>-&gt;size());

		<span class="hljs-keyword">if</span> ( nFirst + nCount &gt; nSize )
			nCount = nSize - nFirst;

		<span class="hljs-keyword">if</span> ( nFirst &gt; nSize )
			<span class="hljs-keyword">return</span> MYTYPE();

		ASSERT(nFirst &gt;= <span class="hljs-number">0</span>);
		ASSERT(nFirst + nCount &lt;= nSize);

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;substr(<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nFirst),
							<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nCount));
	}

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReleaseBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nNewLen=<span class="hljs-number">-1</span>)</span>
	</span>{
		RelBuf(nNewLen);
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Remove</span><span class="hljs-params">(CT ch)</span>
	</span>{
		MYSIZE nIdx		= <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> nRemoved	= <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span> ( (nIdx=<span class="hljs-keyword">this</span>-&gt;find_first_of(ch)) != MYBASE::npos )
		{
			<span class="hljs-keyword">this</span>-&gt;erase(nIdx, <span class="hljs-number">1</span>);
			nRemoved++;
		}
		<span class="hljs-keyword">return</span> nRemoved;
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Replace</span><span class="hljs-params">(CT chOld, CT chNew)</span>
	</span>{
		<span class="hljs-keyword">int</span> nReplaced	= <span class="hljs-number">0</span>;

		<span class="hljs-keyword">for</span> ( MYITER iter=<span class="hljs-keyword">this</span>-&gt;begin(); iter != <span class="hljs-keyword">this</span>-&gt;end(); ++iter )
		{
			<span class="hljs-keyword">if</span> ( *iter == chOld )
			{
				*iter = chNew;
				nReplaced++;
			}
		}

		<span class="hljs-keyword">return</span> nReplaced;
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Replace</span><span class="hljs-params">(PCMYSTR szOld, PCMYSTR szNew)</span>
	</span>{
		<span class="hljs-keyword">int</span> nReplaced		= <span class="hljs-number">0</span>;
		MYSIZE nIdx			= <span class="hljs-number">0</span>;
		MYSIZE nOldLen		= sslen(szOld);

		<span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> != nOldLen )
		{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-151" id="section-151"></a>
</div>
<p>If the replacement string is longer than the one it replaces, this
string is going to have to grow in size,  Figure out how much
and grow it all the way now, rather than incrementally</p>

        </td>
        <td class="code highlight">
          <pre class="c">
			MYSIZE nNewLen		= sslen(szNew);
			<span class="hljs-keyword">if</span> ( nNewLen &gt; nOldLen )
			{
				<span class="hljs-keyword">int</span> nFound			= <span class="hljs-number">0</span>;
				<span class="hljs-keyword">while</span> ( nIdx &lt; <span class="hljs-keyword">this</span>-&gt;length() &amp;&amp;
					(nIdx=<span class="hljs-keyword">this</span>-&gt;find(szOld, nIdx)) != MYBASE::npos )
				{
					nFound++;
					nIdx += nOldLen;
				}
				<span class="hljs-keyword">this</span>-&gt;reserve(<span class="hljs-keyword">this</span>-&gt;size() + nFound * (nNewLen - nOldLen));
			}


			<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> CT ch	= CT(<span class="hljs-number">0</span>);
			PCMYSTR szRealNew	= szNew == <span class="hljs-number">0</span> ? &amp;ch : szNew;
			nIdx				= <span class="hljs-number">0</span>;

			<span class="hljs-keyword">while</span> ( nIdx &lt; <span class="hljs-keyword">this</span>-&gt;length() &amp;&amp; 
				(nIdx=<span class="hljs-keyword">this</span>-&gt;find(szOld, nIdx)) != MYBASE::npos )
			{
				<span class="hljs-keyword">this</span>-&gt;replace(<span class="hljs-keyword">this</span>-&gt;begin()+nIdx, <span class="hljs-keyword">this</span>-&gt;begin()+nIdx+nOldLen,
					szRealNew);

				nReplaced++;
				nIdx += nNewLen;
			}
		}

		<span class="hljs-keyword">return</span> nReplaced;
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ReverseFind</span><span class="hljs-params">(CT ch)</span> <span class="hljs-keyword">const</span>
	</span>{
		MYSIZE nIdx	= <span class="hljs-keyword">this</span>-&gt;find_last_of(ch);
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(MYBASE::npos == nIdx ? <span class="hljs-number">-1</span> : nIdx);
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-152" id="section-152"></a>
</div>
<p>ReverseFind overload that's not in CString but might be useful</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ReverseFind</span><span class="hljs-params">(PCMYSTR szFind, MYSIZE pos=MYBASE::npos)</span> <span class="hljs-keyword">const</span>
	</span>{
		MYSIZE nIdx	= <span class="hljs-keyword">this</span>-&gt;rfind(<span class="hljs-number">0</span> == szFind ? MYTYPE() : szFind, pos);
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(MYBASE::npos == nIdx ? <span class="hljs-number">-1</span> : nIdx);
	}

	<span class="hljs-function">MYTYPE <span class="hljs-title">Right</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nCount)</span> <span class="hljs-keyword">const</span>
	</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-153" id="section-153"></a>
</div>
<p>Range check the count.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		nCount = SSMAX(<span class="hljs-number">0</span>, SSMIN(nCount, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">this</span>-&gt;size())));
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;substr(<span class="hljs-keyword">this</span>-&gt;size()-<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nCount));
	}

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nIndex, CT ch)</span>
	</span>{
		ASSERT(<span class="hljs-keyword">this</span>-&gt;size() &gt; <span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIndex));
		<span class="hljs-keyword">this</span>-&gt;at(<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIndex))		= ch;
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_ANSI</span>
	<span class="hljs-function">BSTR <span class="hljs-title">SetSysString</span><span class="hljs-params">(BSTR* pbstr)</span> <span class="hljs-keyword">const</span>
	</span>{
		ostring os;
		ssasn(os, *<span class="hljs-keyword">this</span>);
		<span class="hljs-keyword">if</span> ( !::SysReAllocStringLen(pbstr, os.c_str(), os.length()) )
			<span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"out of memory"</span>);

		ASSERT(*pbstr != <span class="hljs-number">0</span>);
		<span class="hljs-keyword">return</span> *pbstr;
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

	<span class="hljs-function">MYTYPE <span class="hljs-title">SpanExcluding</span><span class="hljs-params">(PCMYSTR szCharSet)</span> <span class="hljs-keyword">const</span>
	</span>{
        MYSIZE pos = <span class="hljs-keyword">this</span>-&gt;find_first_of(szCharSet);
        <span class="hljs-keyword">return</span> pos == MYBASE::npos ? *<span class="hljs-keyword">this</span> : Left(pos);
	}

	<span class="hljs-function">MYTYPE <span class="hljs-title">SpanIncluding</span><span class="hljs-params">(PCMYSTR szCharSet)</span> <span class="hljs-keyword">const</span>
	</span>{
        MYSIZE pos = <span class="hljs-keyword">this</span>-&gt;find_first_not_of(szCharSet);
        <span class="hljs-keyword">return</span> pos == MYBASE::npos ? *<span class="hljs-keyword">this</span> : Left(pos);
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined SS_WIN32 &amp;&amp; !defined(UNICODE) &amp;&amp; !defined(SS_ANSI)</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-154" id="section-154"></a>
</div>
<p>CString's OemToAnsi and AnsiToOem functions are available only in
Unicode builds.  However since we're a template we also need a
runtime check of CT and a reinterpret_cast to account for the fact
that CStdStringW gets instantiated even in non-Unicode builds.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AnsiToOem</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">sizeof</span>(CT) == <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) &amp;&amp; !empty() )
		{
			::CharToOem(<span class="hljs-keyword">reinterpret_cast</span>&lt;PCSTR&gt;(<span class="hljs-keyword">this</span>-&gt;c_str()),
						<span class="hljs-keyword">reinterpret_cast</span>&lt;PSTR&gt;(GetBuf()));
		}
		<span class="hljs-keyword">else</span>
		{
			ASSERT(<span class="hljs-literal">false</span>);
		}
	}

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OemToAnsi</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">sizeof</span>(CT) == <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) &amp;&amp; !empty() )
		{
			::OemToChar(<span class="hljs-keyword">reinterpret_cast</span>&lt;PCSTR&gt;(<span class="hljs-keyword">this</span>-&gt;c_str()),
						<span class="hljs-keyword">reinterpret_cast</span>&lt;PSTR&gt;(GetBuf()));
		}
		<span class="hljs-keyword">else</span>
		{
			ASSERT(<span class="hljs-literal">false</span>);
		}
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="trim-and-its-variants">
  <h2>
    <a href="#trim-and-its-variants" name="trim-and-its-variants" class="pilcrow"></a>
Trim and its variants
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-function">MYTYPE&amp; <span class="hljs-title">Trim</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> TrimLeft().TrimRight();
	}

	<span class="hljs-function">MYTYPE&amp; <span class="hljs-title">TrimLeft</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">this</span>-&gt;erase(<span class="hljs-keyword">this</span>-&gt;begin(),
			<span class="hljs-built_in">std</span>::find_if(<span class="hljs-keyword">this</span>-&gt;begin(), <span class="hljs-keyword">this</span>-&gt;end(), NotSpace&lt;CT&gt;()));

		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	<span class="hljs-function">MYTYPE&amp;  <span class="hljs-title">TrimLeft</span><span class="hljs-params">(CT tTrim)</span>
	</span>{
		<span class="hljs-keyword">this</span>-&gt;erase(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;find_first_not_of(tTrim));
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	<span class="hljs-function">MYTYPE&amp;  <span class="hljs-title">TrimLeft</span><span class="hljs-params">(PCMYSTR szTrimChars)</span>
	</span>{
		<span class="hljs-keyword">this</span>-&gt;erase(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;find_first_not_of(szTrimChars));
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	<span class="hljs-function">MYTYPE&amp; <span class="hljs-title">TrimRight</span><span class="hljs-params">()</span>
	</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-156" id="section-156"></a>
</div>
<p>NOTE:  When comparing reverse_iterators here (MYRITER), I avoid using
operator!=.  This is because namespace rel_ops also has a template
operator!= which conflicts with the global operator!= already defined
for reverse_iterator in the header <utility>.
Thanks to John James for alerting me to this.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
		MYRITER it = <span class="hljs-built_in">std</span>::find_if(<span class="hljs-keyword">this</span>-&gt;rbegin(), <span class="hljs-keyword">this</span>-&gt;rend(), NotSpace&lt;CT&gt;());
		<span class="hljs-keyword">if</span> ( !(<span class="hljs-keyword">this</span>-&gt;rend() == it) )
			<span class="hljs-keyword">this</span>-&gt;erase(<span class="hljs-keyword">this</span>-&gt;rend() - it);

		<span class="hljs-keyword">this</span>-&gt;erase(!(it == <span class="hljs-keyword">this</span>-&gt;rend()) ? <span class="hljs-keyword">this</span>-&gt;find_last_of(*it) + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	<span class="hljs-function">MYTYPE&amp;  <span class="hljs-title">TrimRight</span><span class="hljs-params">(CT tTrim)</span>
	</span>{
		MYSIZE nIdx	= <span class="hljs-keyword">this</span>-&gt;find_last_not_of(tTrim);
		<span class="hljs-keyword">this</span>-&gt;erase(MYBASE::npos == nIdx ? <span class="hljs-number">0</span> : ++nIdx);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	<span class="hljs-function">MYTYPE&amp;  <span class="hljs-title">TrimRight</span><span class="hljs-params">(PCMYSTR szTrimChars)</span>
	</span>{
		MYSIZE nIdx	= <span class="hljs-keyword">this</span>-&gt;find_last_not_of(szTrimChars);
		<span class="hljs-keyword">this</span>-&gt;erase(MYBASE::npos == nIdx ? <span class="hljs-number">0</span> : ++nIdx);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	<span class="hljs-function"><span class="hljs-keyword">void</span>			<span class="hljs-title">FreeExtra</span><span class="hljs-params">()</span>
	</span>{
		MYTYPE mt;
		<span class="hljs-keyword">this</span>-&gt;swap(mt);
		<span class="hljs-keyword">if</span> ( !mt.empty() )
			<span class="hljs-keyword">this</span>-&gt;assign(mt.c_str(), mt.size());
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-157" id="section-157"></a>
</div>
<p>I have intentionally not implemented the following CString
functions.   You cannot make them work without taking advantage
of implementation specific behavior.  However if you absolutely
MUST have them, uncomment out these lines for &quot;sort-of-like&quot;
their behavior.  You're on your own.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-158" id="section-158"></a>
</div>
<p>CT*				LockBuffer()	{ return GetBuf(); }// won't really lock
void			UnlockBuffer(); { }	// why have UnlockBuffer w/o LockBuffer?</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-159" id="section-159"></a>
</div>
<p>Array-indexing operators.  Required because we defined an implicit cast
to operator const CT* (Thanks to Julian Selman for pointing this out)</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	CT&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> nIdx)
	{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;MYBASE*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIdx));
	}

	<span class="hljs-keyword">const</span> CT&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> nIdx) <span class="hljs-keyword">const</span>
	{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> MYBASE*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIdx));
	}

	CT&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nIdx)
	{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;MYBASE*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIdx));
	}

	<span class="hljs-keyword">const</span> CT&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nIdx) <span class="hljs-keyword">const</span>
	{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> MYBASE*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">static_cast</span>&lt;MYSIZE&gt;(nIdx));
	}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_NO_IMPLICIT_CAST</span>
	<span class="hljs-keyword">operator</span> <span class="hljs-keyword">const</span> CT*() <span class="hljs-keyword">const</span>
	{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;c_str();
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-160" id="section-160"></a>
</div>
<p>IStream related functions.  Useful in IPersistStream implementations</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_INC_COMDEF</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-161" id="section-161"></a>
</div>
<p>struct SSSHDR - useful for non Std C++ persistence schemes.</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> SSSHDR
	{
		BYTE	byCtrl;
		ULONG	nChars;
	} SSSHDR;	<span class="hljs-comment">// as in "Standard String Stream Header"</span>

	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSSO_UNICODE	0x01	<span class="hljs-comment">// the string is a wide string</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SSSO_COMPRESS	0x02	<span class="hljs-comment">// the string is compressed</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="function-streamsize-remarks-returns-how-many-bytes-it-will-take-to-streamsave-this-cstdstring-object-to-an-istream">
  <h2>
    <a href="#function-streamsize-remarks-returns-how-many-bytes-it-will-take-to-streamsave-this-cstdstring-object-to-an-istream" name="function-streamsize-remarks-returns-how-many-bytes-it-will-take-to-streamsave-this-cstdstring-object-to-an-istream" class="pilcrow"></a>
FUNCTION: StreamSize
REMARKS:
	Returns how many bytes it will take to StreamSave() this CStdString
	object to an IStream.
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-function">ULONG <span class="hljs-title">StreamSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
	</span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-163" id="section-163"></a>
</div>
<p>Control header plus string</p>

        </td>
        <td class="code highlight">
          <pre class="c">		ASSERT(<span class="hljs-keyword">this</span>-&gt;size()*<span class="hljs-keyword">sizeof</span>(CT) &lt; <span class="hljs-number">0xffffffff</span>UL - <span class="hljs-keyword">sizeof</span>(SSSHDR));
		<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;size() * <span class="hljs-keyword">sizeof</span>(CT)) + <span class="hljs-keyword">sizeof</span>(SSSHDR);
	}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="function-streamsave-remarks-saves-this-cstdstring-object-to-a-com-istream">
  <h2>
    <a href="#function-streamsave-remarks-saves-this-cstdstring-object-to-a-com-istream" name="function-streamsave-remarks-saves-this-cstdstring-object-to-a-com-istream" class="pilcrow"></a>
FUNCTION: StreamSave
REMARKS:
	Saves this CStdString object to a COM IStream.
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-function">HRESULT <span class="hljs-title">StreamSave</span><span class="hljs-params">(IStream* pStream)</span> <span class="hljs-keyword">const</span>
	</span>{
		ASSERT(<span class="hljs-keyword">this</span>-&gt;size()*<span class="hljs-keyword">sizeof</span>(CT) &lt; <span class="hljs-number">0xffffffff</span>UL - <span class="hljs-keyword">sizeof</span>(SSSHDR));
		HRESULT hr		= E_FAIL;
		ASSERT(pStream != <span class="hljs-number">0</span>);
		SSSHDR hdr;
		hdr.byCtrl		= <span class="hljs-keyword">sizeof</span>(CT) == <span class="hljs-number">2</span> ? SSSO_UNICODE : <span class="hljs-number">0</span>;
		hdr.nChars		= <span class="hljs-keyword">this</span>-&gt;size();


		<span class="hljs-keyword">if</span> ( FAILED(hr=pStream-&gt;Write(&amp;hdr, <span class="hljs-keyword">sizeof</span>(SSSHDR), <span class="hljs-number">0</span>)) )
		{
			TRACE(_T(<span class="hljs-string">"StreamSave: Cannot write control header, ERR=0x%X\n"</span>),hr);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( empty() )
		{
			;		<span class="hljs-comment">// nothing to write</span>
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( FAILED(hr=pStream-&gt;Write(<span class="hljs-keyword">this</span>-&gt;c_str(),
			<span class="hljs-keyword">this</span>-&gt;size()*<span class="hljs-keyword">sizeof</span>(CT), <span class="hljs-number">0</span>)) )
		{
			TRACE(_T(<span class="hljs-string">"StreamSave: Cannot write string to stream 0x%X\n"</span>), hr);
		}

		<span class="hljs-keyword">return</span> hr;
	}


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="function-streamload-remarks-this-method-loads-the-object-from-an-istream">
  <h2>
    <a href="#function-streamload-remarks-this-method-loads-the-object-from-an-istream" name="function-streamload-remarks-this-method-loads-the-object-from-an-istream" class="pilcrow"></a>
FUNCTION: StreamLoad
REMARKS:
	This method loads the object from an IStream.
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-function">HRESULT <span class="hljs-title">StreamLoad</span><span class="hljs-params">(IStream* pStream)</span>
	</span>{
		ASSERT(pStream != <span class="hljs-number">0</span>);
		SSSHDR hdr;
		HRESULT hr			= E_FAIL;

		<span class="hljs-keyword">if</span> ( FAILED(hr=pStream-&gt;Read(&amp;hdr, <span class="hljs-keyword">sizeof</span>(SSSHDR), <span class="hljs-number">0</span>)) )
		{
			TRACE(_T(<span class="hljs-string">"StreamLoad: Cant read control header, ERR=0x%X\n"</span>), hr);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( hdr.nChars &gt; <span class="hljs-number">0</span> )
		{
			ULONG nRead		= <span class="hljs-number">0</span>;
			PMYSTR pMyBuf	= BufferSet(hdr.nChars);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-166" id="section-166"></a>
</div>
<p>If our character size matches the character size of the string
we're trying to read, then we can read it directly into our
buffer. Otherwise, we have to read into an intermediate buffer
and convert.</p>

        </td>
        <td class="code highlight">
          <pre class="c">			
			<span class="hljs-keyword">if</span> ( (hdr.byCtrl &amp; SSSO_UNICODE) != <span class="hljs-number">0</span> )
			{
				ULONG nBytes	= hdr.nChars * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">wchar_t</span>);
				<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">sizeof</span>(CT) == <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">wchar_t</span>) )
				{
					<span class="hljs-keyword">if</span> ( FAILED(hr=pStream-&gt;Read(pMyBuf, nBytes, &amp;nRead)) )
						TRACE(_T(<span class="hljs-string">"StreamLoad: Cannot read string: 0x%X\n"</span>), hr);
				}
				<span class="hljs-keyword">else</span>
				{	
					PWSTR pBufW = <span class="hljs-keyword">reinterpret_cast</span>&lt;PWSTR&gt;(_alloca((nBytes)+<span class="hljs-number">1</span>));
					<span class="hljs-keyword">if</span> ( FAILED(hr=pStream-&gt;Read(pBufW, nBytes, &amp;nRead)) )
						TRACE(_T(<span class="hljs-string">"StreamLoad: Cannot read string: 0x%X\n"</span>), hr);
					<span class="hljs-keyword">else</span>
						sscpy(pMyBuf, pBufW, hdr.nChars);
				}
			}
			<span class="hljs-keyword">else</span>
			{
				ULONG nBytes	= hdr.nChars * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>);
				<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">sizeof</span>(CT) == <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) )
				{
					<span class="hljs-keyword">if</span> ( FAILED(hr=pStream-&gt;Read(pMyBuf, nBytes, &amp;nRead)) )
						TRACE(_T(<span class="hljs-string">"StreamLoad: Cannot read string: 0x%X\n"</span>), hr);
				}
				<span class="hljs-keyword">else</span>
				{
					PSTR pBufA = <span class="hljs-keyword">reinterpret_cast</span>&lt;PSTR&gt;(_alloca(nBytes));
					<span class="hljs-keyword">if</span> ( FAILED(hr=pStream-&gt;Read(pBufA, hdr.nChars, &amp;nRead)) )
						TRACE(_T(<span class="hljs-string">"StreamLoad: Cannot read string: 0x%X\n"</span>), hr);
					<span class="hljs-keyword">else</span>
						sscpy(pMyBuf, pBufA, hdr.nChars);
				}
			}
		}
		<span class="hljs-keyword">else</span>
		{
			<span class="hljs-keyword">this</span>-&gt;erase();
		}
		<span class="hljs-keyword">return</span> hr;
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifdef SS_INC_COMDEF</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SS_ANSI</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-167" id="section-167"></a>
</div>
<p>SetResourceHandle/GetResourceHandle.  In MFC builds, these map directly
to AfxSetResourceHandle and AfxGetResourceHandle.  In non-MFC builds they
point to a single static HINST so that those who call the member
functions that take resource IDs can provide an alternate HINST of a DLL
to search.  This is not exactly the list of HMODULES that MFC provides
but it's better than nothing.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
	<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MFC_VER</span>
		<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetResourceHandle</span><span class="hljs-params">(HMODULE hNew)</span>
		</span>{
			AfxSetResourceHandle(hNew);
		}
		<span class="hljs-function"><span class="hljs-keyword">static</span> HMODULE <span class="hljs-title">GetResourceHandle</span><span class="hljs-params">()</span>
		</span>{
			<span class="hljs-keyword">return</span> AfxGetResourceHandle();
		}
	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
		<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetResourceHandle</span><span class="hljs-params">(HMODULE hNew)</span>
		</span>{
			SSResourceHandle() = hNew;
		}
		<span class="hljs-function"><span class="hljs-keyword">static</span> HMODULE <span class="hljs-title">GetResourceHandle</span><span class="hljs-params">()</span>
		</span>{
			<span class="hljs-keyword">return</span> SSResourceHandle();
		}
	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-168" id="section-168"></a>
</div>
<hr>
<p>MSVC USERS: HOW TO EXPORT CSTDSTRING FROM A DLL</p>
<p>If you are using MS Visual C++ and you want to export CStdStringA and
CStdStringW from a DLL, then all you need to</p>
<pre><code>1.	make sure that all components link to the same DLL version
	of the CRT (not the static one).
2.	Uncomment the 3 lines of code below
3.	#define 2 macros per the instructions in MS KnowledgeBase
	article Q168958.  The macros are:

MACRO		DEFINTION WHEN EXPORTING		DEFINITION WHEN IMPORTING
-----		------------------------		-------------------------
SSDLLEXP	(nothing, just #define it)		extern
SSDLLSPEC	__declspec(dllexport)			__declspec(dllimport)

Note that these macros must be available to ALL clients who want to 
link to the DLL and use the class.  If they 
</code></pre>
<p>A word of advice: Don't bother.</p>
<p>Really, it is not necessary to export CStdString functions from a DLL.  I
never do.  In my projects, I do generally link to the DLL version of the
Standard C++ Library, but I do NOT attempt to export CStdString functions.
I simply include the header where it is needed and allow for the code
redundancy.</p>
<p>That redundancy is a lot less than you think.  This class does most of its
work via the Standard C++ Library, particularly the base_class basic_string&lt;&gt;
member functions.  Most of the functions here are small enough to be inlined
anyway.  Besides, you'll find that in actual practice you use less than 1/2
of the code here, even in big projects and different modules will use as
little as 10% of it.  That means a lot less functions actually get linked
your binaries.  If you export this code from a DLL, it ALL gets linked in.</p>
<p>I've compared the size of the binaries from exporting vs NOT exporting.  Take
my word for it -- exporting this code is not worth the hassle.</p>
<hr>
<p>#pragma warning(disable:4231) // non-standard extension (&quot;extern template&quot;)
SSDLLEXP template class SSDLLSPEC CStdStr<char>;
SSDLLEXP template class SSDLLSPEC CStdStr&lt;wchar_t&gt;;</p>

        </td>
        <td class="code highlight">
          <pre class="c">

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="end-of-cstdstr-inline-function-definitions">
  <h1>
    <a href="#end-of-cstdstr-inline-function-definitions" name="end-of-cstdstr-inline-function-definitions" class="pilcrow"></a>
=============================================================================
					END OF CStdStr INLINE FUNCTION DEFINITIONS
  </h1>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-170" id="section-170"></a>
</div>
<p>Now typedef our class names based upon this humongous template</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">typedef</span> CStdStr&lt;<span class="hljs-keyword">char</span>&gt;		CStdStringA;	<span class="hljs-comment">// a better std::string</span>
<span class="hljs-keyword">typedef</span> CStdStr&lt;<span class="hljs-keyword">wchar_t</span>&gt;	CStdStringW;	<span class="hljs-comment">// a better std::wstring</span>
<span class="hljs-keyword">typedef</span> CStdStr&lt;OLECHAR&gt;	CStdStringO;	<span class="hljs-comment">// almost always CStdStringW</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="cstdstr-addition-functions-defined-as-inline">
  <h2>
    <a href="#cstdstr-addition-functions-defined-as-inline" name="cstdstr-addition-functions-defined-as-inline" class="pilcrow"></a>
CStdStr addition functions defined as inline
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">

inline CStdStringA operator+(const CStdStringA&amp; s1, const CStdStringA&amp; s2)
{
	CStdStringA sRet(SSREF(s1));
	sRet.append(s2);
	return sRet;
}
inline CStdStringA operator+(const CStdStringA&amp; s1, CStdStringA::value_type t)
{
	CStdStringA sRet(SSREF(s1));
	sRet.append(1, t);
	return sRet;
}
inline CStdStringA operator+(const CStdStringA&amp; s1, PCSTR pA)
{
	CStdStringA sRet(SSREF(s1));
	sRet.append(pA);
	return sRet;
}
inline CStdStringA operator+(PCSTR pA, const CStdStringA&amp; sA)
{
	CStdStringA sRet;
	CStdStringA::size_type nObjSize = sA.size();
	CStdStringA::size_type nLitSize = 
		static_cast&lt;CStdStringA::size_type&gt;(sslen(pA));

	sRet.reserve(nLitSize + nObjSize);
	sRet.assign(pA);
	sRet.append(sA);
	return sRet;
}


inline CStdStringA operator+(const CStdStringA&amp; s1, const CStdStringW&amp; s2)
{
	return s1 + CStdStringA(s2);
}
inline CStdStringW operator+(const CStdStringW&amp; s1, const CStdStringW&amp; s2)
{
	CStdStringW sRet(SSREF(s1));
	sRet.append(s2);
	return sRet;
}
inline CStdStringA operator+(const CStdStringA&amp; s1, PCWSTR pW)
{
	return s1 + CStdStringA(pW);
}

#ifdef UNICODE
	inline CStdStringW operator+(PCWSTR pW, const CStdStringA&amp; sA)
	{
		return CStdStringW(pW) + CStdStringW(SSREF(sA));
	}
	inline CStdStringW operator+(PCSTR pA, const CStdStringW&amp; sW)
	{
		return CStdStringW(pA) + sW;
	}
#else
	inline CStdStringA operator+(PCWSTR pW, const CStdStringA&amp; sA)
	{
		return CStdStringA(pW) + sA;
	}
	inline CStdStringA operator+(PCSTR pA, const CStdStringW&amp; sW)
	{
		return pA + CStdStringA(sW);
	}
#endif

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-172" id="section-172"></a>
</div>
<p>...Now the wide string versions.</p>

        </td>
        <td class="code highlight">
          <pre class="c">inline CStdStringW operator+(const CStdStringW&amp; s1, CStdStringW::value_type t)
{
	CStdStringW sRet(SSREF(s1));
	sRet.append(1, t);
	return sRet;
}
inline CStdStringW operator+(const CStdStringW&amp; s1, PCWSTR pW)
{
	CStdStringW sRet(SSREF(s1));
	sRet.append(pW);
	return sRet;
}
inline CStdStringW operator+(PCWSTR pW, const CStdStringW&amp; sW)
{
	CStdStringW sRet;
	CStdStringW::size_type nObjSize = sW.size();
	CStdStringA::size_type nLitSize = 
		static_cast&lt;CStdStringW::size_type&gt;(sslen(pW));

	sRet.reserve(nLitSize + nObjSize);
	sRet.assign(pW);
	sRet.append(sW);
	return sRet;
}

inline CStdStringW operator+(const CStdStringW&amp; s1, const CStdStringA&amp; s2)
{
	return s1 + CStdStringW(s2);
}
inline CStdStringW operator+(const CStdStringW&amp; s1, PCSTR pA)
{
	return s1 + CStdStringW(pA);
}


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-173" id="section-173"></a>
</div>
<p>New-style format function is a template</p>

        </td>
        <td class="code highlight">
          <pre class="c">
#ifdef SS_SAFE_FORMAT

template&lt;&gt;
struct FmtArg&lt;CStdStringA&gt;
{
    explicit FmtArg(const CStdStringA&amp; arg) : a_(arg) {}
    PCSTR operator()() const { return a_.c_str(); }
    const CStdStringA&amp; a_;
private:
    FmtArg&lt;CStdStringA&gt;&amp; operator=(const FmtArg&lt;CStdStringA&gt;&amp;) { return *this; }
};
template&lt;&gt;
struct FmtArg&lt;CStdStringW&gt;
{
    explicit FmtArg(const CStdStringW&amp; arg) : a_(arg) {}
    PCWSTR operator()() const { return a_.c_str(); }
    const CStdStringW&amp; a_;
private:
    FmtArg&lt;CStdStringW&gt;&amp; operator=(const FmtArg&lt;CStdStringW&gt;&amp;) { return *this; }
};

template&lt;&gt;
struct FmtArg&lt;std::string&gt;
{
    explicit FmtArg(const std::string&amp; arg) : a_(arg) {}
    PCSTR operator()() const { return a_.c_str(); }
    const std::string&amp; a_;
private:
    FmtArg&lt;std::string&gt;&amp; operator=(const FmtArg&lt;std::string&gt;&amp;) { return *this; }
};
template&lt;&gt;
struct FmtArg&lt;std::wstring&gt;
{
    explicit FmtArg(const std::wstring&amp; arg) : a_(arg) {}
    PCWSTR operator()() const { return a_.c_str(); }
    const std::wstring&amp; a_;
private:
    FmtArg&lt;std::wstring&gt;&amp; operator=(const FmtArg&lt;std::wstring&gt;&amp;) {return *this;}
};
#endif // #ifdef SS_SAFEFORMAT

#ifndef SS_ANSI
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-174" id="section-174"></a>
</div>
<p>SSResourceHandle: our MFC-like resource handle</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-function"><span class="hljs-keyword">inline</span> HMODULE&amp; <span class="hljs-title">SSResourceHandle</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">static</span> HMODULE hModuleSS	= GetModuleHandle(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">return</span> hModuleSS;
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-175" id="section-175"></a>
</div>
<p>In MFC builds, define some global serialization operators
Special operators that allow us to serialize CStdStrings to CArchives.
Note that we use an intermediate CString object in order to ensure that
we use the exact same format.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MFC_VER</span>
	<span class="hljs-keyword">inline</span> CArchive&amp; AFXAPI <span class="hljs-keyword">operator</span>&lt;&lt;(CArchive&amp; ar, <span class="hljs-keyword">const</span> CStdStringA&amp; strA)
	{
		<span class="hljs-function">CString <span class="hljs-title">strTemp</span><span class="hljs-params">(strA)</span></span>;
		<span class="hljs-keyword">return</span> ar &lt;&lt; strTemp;
	}
	<span class="hljs-keyword">inline</span> CArchive&amp; AFXAPI <span class="hljs-keyword">operator</span>&lt;&lt;(CArchive&amp; ar, <span class="hljs-keyword">const</span> CStdStringW&amp; strW)
	{
		<span class="hljs-function">CString <span class="hljs-title">strTemp</span><span class="hljs-params">(strW)</span></span>;
		<span class="hljs-keyword">return</span> ar &lt;&lt; strTemp;
	}

	<span class="hljs-keyword">inline</span> CArchive&amp; AFXAPI <span class="hljs-keyword">operator</span>&gt;&gt;(CArchive&amp; ar, CStdStringA&amp; strA)
	{
		CString strTemp;
		ar &gt;&gt; strTemp;
		strA = strTemp;
		<span class="hljs-keyword">return</span> ar;
	}
	<span class="hljs-keyword">inline</span> CArchive&amp; AFXAPI <span class="hljs-keyword">operator</span>&gt;&gt;(CArchive&amp; ar, CStdStringW&amp; strW)
	{
		CString strTemp;
		ar &gt;&gt; strTemp;
		strW = strTemp;
		<span class="hljs-keyword">return</span> ar;
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>	<span class="hljs-comment">// #ifdef _MFC_VER -- (i.e. is this MFC?)</span></span>



</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<p>GLOBAL FUNCTION:  WUFormat
	CStdStringA WUFormat(UINT nId, ...);
	CStdStringA WUFormat(PCSTR szFormat, ...);</p>
<div class="pilwrap" id="remarks-this-function-allows-the-caller-for-format-and-return-a-cstdstringa-object-with-a-single-line-of-code">
  <h2>
    <a href="#remarks-this-function-allows-the-caller-for-format-and-return-a-cstdstringa-object-with-a-single-line-of-code" name="remarks-this-function-allows-the-caller-for-format-and-return-a-cstdstringa-object-with-a-single-line-of-code" class="pilcrow"></a>
REMARKS:
	This function allows the caller for format and return a CStdStringA
	object with a single line of code.
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> CStdStringA <span class="hljs-title">WUFormatA</span><span class="hljs-params">(PCSTR szFormat, ...)</span>
</span>{
	va_list argList;
	va_start(argList, szFormat);
	CStdStringA strOut;
	strOut.FormatV(szFormat, argList);
	va_end(argList);
	<span class="hljs-keyword">return</span> strOut;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> CStdStringW <span class="hljs-title">WUFormatW</span><span class="hljs-params">(PCWSTR szwFormat, ...)</span>
</span>{
	va_list argList;
	va_start(argList, szwFormat);
	CStdStringW strOut;
	strOut.FormatV(szwFormat, argList);
	va_end(argList);
	<span class="hljs-keyword">return</span> strOut;
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SS_ANSI</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	<span class="hljs-function"><span class="hljs-keyword">inline</span> CStdStringA <span class="hljs-title">WUFormatA</span><span class="hljs-params">(UINT nId, ...)</span>
	</span>{
		va_list argList;
		va_start(argList, nId);

		CStdStringA strFmt;
		CStdStringA strOut;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
			strOut.FormatV(strFmt, argList);

		va_end(argList);
		<span class="hljs-keyword">return</span> strOut;
	}

	<span class="hljs-function"><span class="hljs-keyword">inline</span> CStdStringW <span class="hljs-title">WUFormatW</span><span class="hljs-params">(UINT nId, ...)</span>
	</span>{
		va_list argList;
		va_start(argList, nId);

		CStdStringW strFmt;
		CStdStringW strOut;
		<span class="hljs-keyword">if</span> ( strFmt.Load(nId) )
			strOut.FormatV(strFmt, argList);

		va_end(argList);
		<span class="hljs-keyword">return</span> strOut;
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifdef SS_ANSI</span></span>



<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(SS_WIN32) &amp;&amp; !defined (SS_ANSI)</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<p>FUNCTION: WUSysMessage
CStdStringA WUSysMessageA(DWORD dwError, DWORD dwLangId=SS_DEFLANGID);
CStdStringW WUSysMessageW(DWORD dwError, DWORD dwLangId=SS_DEFLANGID);</p>
<p>DESCRIPTION:
This function simplifies the process of obtaining a string equivalent
of a system error code returned from GetLastError().  You simply
supply the value returned by GetLastError() to this function and the
corresponding system string is returned in the form of a CStdStringA.</p>
<p>PARAMETERS:
dwError - a DWORD value representing the error code to be translated
dwLangId - the language id to use.  defaults to english.</p>
<div class="pilwrap" id="return-value-a-cstdstringa-equivalent-of-the-error-code.currently-this-function-only-returns-either-english-of-the-system-default-language-strings">
  <h2>
    <a href="#return-value-a-cstdstringa-equivalent-of-the-error-code.currently-this-function-only-returns-either-english-of-the-system-default-language-strings" name="return-value-a-cstdstringa-equivalent-of-the-error-code.currently-this-function-only-returns-either-english-of-the-system-default-language-strings" class="pilcrow"></a>
RETURN VALUE:
a CStdStringA equivalent of the error code.  Currently, this function
only returns either English of the system default language strings.
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SS_DEFLANGID MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT)</span>
	<span class="hljs-function"><span class="hljs-keyword">inline</span> CStdStringA <span class="hljs-title">WUSysMessageA</span><span class="hljs-params">(DWORD dwError, DWORD dwLangId=SS_DEFLANGID)</span>
	</span>{
		CHAR szBuf[<span class="hljs-number">512</span>];

		<span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> != ::FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, <span class="hljs-literal">NULL</span>, dwError,
								   dwLangId, szBuf, <span class="hljs-number">511</span>, <span class="hljs-literal">NULL</span>) )
			<span class="hljs-keyword">return</span> WUFormatA(<span class="hljs-string">"%s (0x%X)"</span>, szBuf, dwError);
		<span class="hljs-keyword">else</span>
 			<span class="hljs-keyword">return</span> WUFormatA(<span class="hljs-string">"Unknown error (0x%X)"</span>, dwError);
	}
	<span class="hljs-function"><span class="hljs-keyword">inline</span> CStdStringW <span class="hljs-title">WUSysMessageW</span><span class="hljs-params">(DWORD dwError, DWORD dwLangId=SS_DEFLANGID)</span>
	</span>{
		WCHAR szBuf[<span class="hljs-number">512</span>];

		<span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> != ::FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM, <span class="hljs-literal">NULL</span>, dwError,
								   dwLangId, szBuf, <span class="hljs-number">511</span>, <span class="hljs-literal">NULL</span>) )
			<span class="hljs-keyword">return</span> WUFormatW(<span class="hljs-string">L"%s (0x%X)"</span>, szBuf, dwError);
		<span class="hljs-keyword">else</span>
 			<span class="hljs-keyword">return</span> WUFormatW(<span class="hljs-string">L"Unknown error (0x%X)"</span>, dwError);
	}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-178" id="section-178"></a>
</div>
<p>Define TCHAR based friendly names for some of these functions</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> UNICODE</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-179" id="section-179"></a>
</div>
<p>#define CStdString				CStdStringW</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-keyword">typedef</span> CStdStringW				CStdString;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WUSysMessage			WUSysMessageW</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WUFormat				WUFormatW</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-180" id="section-180"></a>
</div>
<p>#define CStdString				CStdStringA</p>

        </td>
        <td class="code highlight">
          <pre class="c">	<span class="hljs-keyword">typedef</span> CStdStringA				CStdString;
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WUSysMessage			WUSysMessageA</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WUFormat				WUFormatA</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-181" id="section-181"></a>
</div>
<p>...and some shorter names for the space-efficient</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WUSysMsg					WUSysMessage</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WUSysMsgA					WUSysMessageA</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WUSysMsgW					WUSysMessageW</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WUFmtA						WUFormatA</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>	WUFmtW						WUFormatW</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WUFmt						WUFormat</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WULastErrMsg()				WUSysMessage(::GetLastError())</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WULastErrMsgA()				WUSysMessageA(::GetLastError())</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WULastErrMsgW()				WUSysMessageW(::GetLastError())</span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <hr>
<div class="pilwrap" id="functional-comparators-remarks-these-structs-are-derived-from-the-std-binary_function-template.they-give-us-functional-classes-which-may-be-used-in-standard-c++-library-collections-and-algorithms-that-perform-case-insensitive-comparisons-of-cstdstring-objects.this-is-useful-for-maps-in-which-the-key-may-be-the-proper-string-but-in-the-wrong-case">
  <h2>
    <a href="#functional-comparators-remarks-these-structs-are-derived-from-the-std-binary_function-template.they-give-us-functional-classes-which-may-be-used-in-standard-c++-library-collections-and-algorithms-that-perform-case-insensitive-comparisons-of-cstdstring-objects.this-is-useful-for-maps-in-which-the-key-may-be-the-proper-string-but-in-the-wrong-case" name="functional-comparators-remarks-these-structs-are-derived-from-the-std-binary_function-template.they-give-us-functional-classes-which-may-be-used-in-standard-c++-library-collections-and-algorithms-that-perform-case-insensitive-comparisons-of-cstdstring-objects.this-is-useful-for-maps-in-which-the-key-may-be-the-proper-string-but-in-the-wrong-case" class="pilcrow"></a>
FUNCTIONAL COMPARATORS:
REMARKS:
	These structs are derived from the std::binary_function template.  They
	give us functional classes (which may be used in Standard C++ Library
	collections and algorithms) that perform case-insensitive comparisons of
	CStdString objects.  This is useful for maps in which the key may be the
	 proper string but in the wrong case.
  </h2>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> StdStringLessNoCaseW		SSLNCW	<span class="hljs-comment">// avoid VC compiler warning 4786</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> StdStringEqualsNoCaseW		SSENCW		</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> StdStringLessNoCaseA		SSLNCA		</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> StdStringEqualsNoCaseA		SSENCA		</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> UNICODE</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> StdStringLessNoCase		SSLNCW		</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> StdStringEqualsNoCase	SSENCW		</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> StdStringLessNoCase		SSLNCA		</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> StdStringEqualsNoCase	SSENCA		</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">struct</span> StdStringLessNoCaseW
	: <span class="hljs-built_in">std</span>::binary_function&lt;CStdStringW, CStdStringW, <span class="hljs-keyword">bool</span>&gt;
{
	<span class="hljs-function"><span class="hljs-keyword">inline</span>
	<span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CStdStringW&amp; sLeft, <span class="hljs-keyword">const</span> CStdStringW&amp; sRight)</span> <span class="hljs-keyword">const</span>
	</span>{ <span class="hljs-keyword">return</span> ssicmp(sLeft.c_str(), sRight.c_str()) &lt; <span class="hljs-number">0</span>; }
};
<span class="hljs-keyword">struct</span> StdStringEqualsNoCaseW
	: <span class="hljs-built_in">std</span>::binary_function&lt;CStdStringW, CStdStringW, <span class="hljs-keyword">bool</span>&gt;
{
	<span class="hljs-function"><span class="hljs-keyword">inline</span>
	<span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CStdStringW&amp; sLeft, <span class="hljs-keyword">const</span> CStdStringW&amp; sRight)</span> <span class="hljs-keyword">const</span>
	</span>{ <span class="hljs-keyword">return</span> ssicmp(sLeft.c_str(), sRight.c_str()) == <span class="hljs-number">0</span>; }
};
<span class="hljs-keyword">struct</span> StdStringLessNoCaseA
	: <span class="hljs-built_in">std</span>::binary_function&lt;CStdStringA, CStdStringA, <span class="hljs-keyword">bool</span>&gt;
{
	<span class="hljs-function"><span class="hljs-keyword">inline</span>
	<span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CStdStringA&amp; sLeft, <span class="hljs-keyword">const</span> CStdStringA&amp; sRight)</span> <span class="hljs-keyword">const</span>
	</span>{ <span class="hljs-keyword">return</span> ssicmp(sLeft.c_str(), sRight.c_str()) &lt; <span class="hljs-number">0</span>; }
};
<span class="hljs-keyword">struct</span> StdStringEqualsNoCaseA
	: <span class="hljs-built_in">std</span>::binary_function&lt;CStdStringA, CStdStringA, <span class="hljs-keyword">bool</span>&gt;
{
	<span class="hljs-function"><span class="hljs-keyword">inline</span>
	<span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CStdStringA&amp; sLeft, <span class="hljs-keyword">const</span> CStdStringA&amp; sRight)</span> <span class="hljs-keyword">const</span>
	</span>{ <span class="hljs-keyword">return</span> ssicmp(sLeft.c_str(), sRight.c_str()) == <span class="hljs-number">0</span>; }
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-183" id="section-183"></a>
</div>
<p>If we had to define our own version of TRACE above, get rid of it now</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> TRACE_DEFINED_HERE</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> TRACE</span>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> TRACE_DEFINED_HERE</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-184" id="section-184"></a>
</div>
<p>These std::swap specializations come courtesy of Mike Crusader.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-185" id="section-185"></a>
</div>
<p>namespace std
{
inline void swap(CStdStringA&amp; s1, CStdStringA&amp; s2) throw()
{
	s1.swap(s2);
}
template&lt;&gt;
inline void swap(CStdStringW&amp; s1, CStdStringW&amp; s2) throw()
{
	s1.swap(s2);
}
}</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-186" id="section-186"></a>
</div>
<p>Turn back on any Borland warnings we turned off.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __BORLANDC__</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> option pop  <span class="hljs-comment">// Turn back on inline function warnings</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-187" id="section-187"></a>
</div>
<p>#pragma warn +inl   // Turn back on inline function warnings</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>	<span class="hljs-comment">// #ifndef STDSTRING_H</span></span>

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
