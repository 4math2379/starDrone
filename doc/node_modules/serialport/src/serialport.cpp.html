<!DOCTYPE html>
<html>
<head>
  <title>serialport.cpp</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "node_modules/serialport/src/serialport.cpp";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>serialport.cpp</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"./serialport.h"</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WIN32</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> strncasecmp strnicmp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"./serialport_poller.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">struct</span> _WriteQueue {
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> _fd;  <span class="hljs-comment">// the fd that is associated with this write queue</span>
  QueuedWrite _write_queue;
  <span class="hljs-keyword">uv_mutex_t</span> _write_queue_mutex;
  _WriteQueue *_next;

  _WriteQueue(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd) : _fd(fd), _write_queue(), _next(<span class="hljs-literal">NULL</span>) {
    uv_mutex_init(&amp;_write_queue_mutex);
  }

  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>{ uv_mutex_lock(&amp;_write_queue_mutex); }
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>{ uv_mutex_unlock(&amp;_write_queue_mutex); }

  <span class="hljs-function">QueuedWrite &amp;<span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> _write_queue; }
};

<span class="hljs-keyword">static</span> _WriteQueue *write_queues = <span class="hljs-literal">NULL</span>;

<span class="hljs-keyword">static</span> _<span class="hljs-function">WriteQueue *<span class="hljs-title">qForFD</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd)</span> </span>{
  _WriteQueue *q = write_queues;
  <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span>) {
    <span class="hljs-keyword">if</span> (q-&gt;_fd == fd) {
      <span class="hljs-keyword">return</span> q;
    }
    q = q-&gt;_next;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-keyword">static</span> _<span class="hljs-function">WriteQueue *<span class="hljs-title">newQForFD</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd)</span> </span>{
  _WriteQueue *q = qForFD(fd);

  <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>) {
    <span class="hljs-keyword">if</span> (write_queues == <span class="hljs-literal">NULL</span>) {
      write_queues = <span class="hljs-keyword">new</span> _WriteQueue(fd);
      <span class="hljs-keyword">return</span> write_queues;
    } <span class="hljs-keyword">else</span> {
      q = write_queues;
      <span class="hljs-keyword">while</span> (q-&gt;_next != <span class="hljs-literal">NULL</span>) {
        q = q-&gt;_next;
      }
      q-&gt;_next = <span class="hljs-keyword">new</span> _WriteQueue(fd);
      <span class="hljs-keyword">return</span> q-&gt;_next;
    }
  }

  <span class="hljs-keyword">return</span> q;
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteQForFD</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd)</span> </span>{
  <span class="hljs-keyword">if</span> (write_queues == <span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;

  _WriteQueue *q = write_queues;
  <span class="hljs-keyword">if</span> (write_queues-&gt;_fd == fd) {
    write_queues = write_queues-&gt;_next;
    <span class="hljs-keyword">delete</span> q;

    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">while</span> (q-&gt;_next != <span class="hljs-literal">NULL</span>) {
    <span class="hljs-keyword">if</span> (q-&gt;_next-&gt;_fd == fd) {
      _WriteQueue *out_q = q-&gt;_next;
      q-&gt;_next = q-&gt;_next-&gt;_next;
      <span class="hljs-keyword">delete</span> out_q;

      <span class="hljs-keyword">return</span>;
    }
    q = q-&gt;_next;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>It wasn't found...</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">}

NAN_METHOD(Open) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>path</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  if (!info[0]-&gt;IsString()) {
    Nan::ThrowTypeError("First argument must be a string");
    return;
  }
  v8::String::Utf8Value path(info[0]-&gt;ToString());

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>options</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">1</span>]-&gt;IsObject()) {
    Nan::ThrowTypeError(<span class="hljs-string">"Second argument must be an object"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Object&gt; options = info[<span class="hljs-number">1</span>]-&gt;ToObject();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>callback</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">2</span>]-&gt;IsFunction()) {
    Nan::ThrowTypeError(<span class="hljs-string">"Third argument must be a function"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Function&gt; callback = info[<span class="hljs-number">2</span>].As&lt;v8::Function&gt;();

  OpenBaton* baton = <span class="hljs-keyword">new</span> OpenBaton();
  <span class="hljs-built_in">memset</span>(baton, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(OpenBaton));
  <span class="hljs-built_in">strcpy</span>(baton-&gt;path, *path);
  baton-&gt;baudRate = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"baudRate"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToInt32()-&gt;Int32Value();
  baton-&gt;dataBits = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"dataBits"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToInt32()-&gt;Int32Value();
  baton-&gt;bufferSize = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"bufferSize"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToInt32()-&gt;Int32Value();
  baton-&gt;parity = ToParityEnum(Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"parity"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToString());
  baton-&gt;stopBits = ToStopBitEnum(Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"stopBits"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToNumber()-&gt;NumberValue());
  baton-&gt;rtscts = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"rtscts"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;xon = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"xon"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;xoff = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"xoff"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;xany = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"xany"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;hupcl = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"hupcl"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();

  v8::Local&lt;v8::Object&gt; platformOptions = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"platformOptions"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToObject();
  baton-&gt;platformOptions = ParsePlatformOptions(platformOptions);

  baton-&gt;callback = <span class="hljs-keyword">new</span> Nan::Callback(callback);
  baton-&gt;dataCallback = <span class="hljs-keyword">new</span> Nan::Callback(Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"dataCallback"</span>).ToLocalChecked()).ToLocalChecked().As&lt;v8::Function&gt;());
  baton-&gt;disconnectedCallback = <span class="hljs-keyword">new</span> Nan::Callback(Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"disconnectedCallback"</span>).ToLocalChecked()).ToLocalChecked().As&lt;v8::Function&gt;());
  baton-&gt;errorCallback = <span class="hljs-keyword">new</span> Nan::Callback(Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"errorCallback"</span>).ToLocalChecked()).ToLocalChecked().As&lt;v8::Function&gt;());

  <span class="hljs-keyword">uv_work_t</span>* req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uv_work_t</span>();
  req-&gt;data = baton;

  uv_queue_work(uv_default_loop(), req, EIO_Open, (uv_after_work_cb)EIO_AfterOpen);

  <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_AfterOpen</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  Nan::HandleScope scope;

  OpenBaton* data = <span class="hljs-keyword">static_cast</span>&lt;OpenBaton*&gt;(req-&gt;data);

  v8::Local&lt;v8::Value&gt; argv[<span class="hljs-number">2</span>];
  <span class="hljs-keyword">if</span> (data-&gt;errorString[<span class="hljs-number">0</span>]) {
    argv[<span class="hljs-number">0</span>] = v8::Exception::Error(Nan::New&lt;v8::String&gt;(data-&gt;errorString).ToLocalChecked());
    argv[<span class="hljs-number">1</span>] = Nan::Undefined();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>not needed because we're not calling AfterOpenSuccess</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">    <span class="hljs-keyword">delete</span> data-&gt;dataCallback;
    <span class="hljs-keyword">delete</span> data-&gt;errorCallback;
    <span class="hljs-keyword">delete</span> data-&gt;disconnectedCallback;
  } <span class="hljs-keyword">else</span> {
    argv[<span class="hljs-number">0</span>] = Nan::Null();
    argv[<span class="hljs-number">1</span>] = Nan::New&lt;v8::Int32&gt;(data-&gt;result);

    <span class="hljs-keyword">int</span> fd = argv[<span class="hljs-number">1</span>]-&gt;ToInt32()-&gt;Int32Value();
    newQForFD(fd);

    AfterOpenSuccess(data-&gt;result, data-&gt;dataCallback, data-&gt;disconnectedCallback, data-&gt;errorCallback);
  }

  data-&gt;callback-&gt;Call(<span class="hljs-number">2</span>, argv);

  <span class="hljs-keyword">delete</span> data-&gt;platformOptions;
  <span class="hljs-keyword">delete</span> data-&gt;callback;
  <span class="hljs-keyword">delete</span> data;
  <span class="hljs-keyword">delete</span> req;
}

NAN_METHOD(Update) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>file descriptor</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">0</span>]-&gt;IsInt32()) {
    Nan::ThrowTypeError(<span class="hljs-string">"First argument must be an int"</span>);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">int</span> fd = info[<span class="hljs-number">0</span>]-&gt;ToInt32()-&gt;Int32Value();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>options</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">1</span>]-&gt;IsObject()) {
    Nan::ThrowTypeError(<span class="hljs-string">"Second argument must be an object"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Object&gt; options = info[<span class="hljs-number">1</span>]-&gt;ToObject();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>callback</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">2</span>]-&gt;IsFunction()) {
    Nan::ThrowTypeError(<span class="hljs-string">"Third argument must be a function"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Function&gt; callback = info[<span class="hljs-number">2</span>].As&lt;v8::Function&gt;();

  OpenBaton* baton = <span class="hljs-keyword">new</span> OpenBaton();
  <span class="hljs-built_in">memset</span>(baton, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(OpenBaton));
  baton-&gt;fd = fd;
  baton-&gt;baudRate = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"baudRate"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToInt32()-&gt;Int32Value();
  baton-&gt;dataBits = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"dataBits"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToInt32()-&gt;Int32Value();
  baton-&gt;bufferSize = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"bufferSize"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToInt32()-&gt;Int32Value();
  baton-&gt;parity = ToParityEnum(Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"parity"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToString());
  baton-&gt;stopBits = ToStopBitEnum(Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"stopBits"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToNumber()-&gt;NumberValue());
  baton-&gt;rtscts = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"rtscts"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;xon = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"xon"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;xoff = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"xoff"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;xany = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"xany"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();

  v8::Local&lt;v8::Object&gt; platformOptions = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"platformOptions"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToObject();
  baton-&gt;platformOptions = ParsePlatformOptions(platformOptions);

  baton-&gt;callback = <span class="hljs-keyword">new</span> Nan::Callback(callback);
  baton-&gt;dataCallback = <span class="hljs-keyword">new</span> Nan::Callback(Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"dataCallback"</span>).ToLocalChecked()).ToLocalChecked().As&lt;v8::Function&gt;());
  baton-&gt;disconnectedCallback = <span class="hljs-keyword">new</span> Nan::Callback(Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"disconnectedCallback"</span>).ToLocalChecked()).ToLocalChecked().As&lt;v8::Function&gt;());
  baton-&gt;errorCallback = <span class="hljs-keyword">new</span> Nan::Callback(Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"errorCallback"</span>).ToLocalChecked()).ToLocalChecked().As&lt;v8::Function&gt;());

  <span class="hljs-keyword">uv_work_t</span>* req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uv_work_t</span>();
  req-&gt;data = baton;

  uv_queue_work(uv_default_loop(), req, EIO_Update, (uv_after_work_cb)EIO_AfterUpdate);

  <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_AfterUpdate</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  Nan::HandleScope scope;

  OpenBaton* data = <span class="hljs-keyword">static_cast</span>&lt;OpenBaton*&gt;(req-&gt;data);

  v8::Local&lt;v8::Value&gt; argv[<span class="hljs-number">2</span>];
  <span class="hljs-keyword">if</span> (data-&gt;errorString[<span class="hljs-number">0</span>]) {
    argv[<span class="hljs-number">0</span>] = v8::Exception::Error(Nan::New&lt;v8::String&gt;(data-&gt;errorString).ToLocalChecked());
    argv[<span class="hljs-number">1</span>] = Nan::Undefined();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>not needed because we're not calling AfterOpenSuccess</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">    <span class="hljs-keyword">delete</span> data-&gt;dataCallback;
    <span class="hljs-keyword">delete</span> data-&gt;errorCallback;
    <span class="hljs-keyword">delete</span> data-&gt;disconnectedCallback;
  } <span class="hljs-keyword">else</span> {
    argv[<span class="hljs-number">0</span>] = Nan::Null();
    argv[<span class="hljs-number">1</span>] = Nan::New&lt;v8::Int32&gt;(data-&gt;result);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>TODO figure out if this is a bug</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">    <span class="hljs-keyword">int</span> fd = argv[<span class="hljs-number">1</span>]-&gt;ToInt32()-&gt;Int32Value();
    newQForFD(fd);

    AfterOpenSuccess(data-&gt;result, data-&gt;dataCallback, data-&gt;disconnectedCallback, data-&gt;errorCallback);
  }

  data-&gt;callback-&gt;Call(<span class="hljs-number">2</span>, argv);

  <span class="hljs-keyword">delete</span> data-&gt;platformOptions;
  <span class="hljs-keyword">delete</span> data-&gt;callback;
  <span class="hljs-keyword">delete</span> data;
  <span class="hljs-keyword">delete</span> req;
}

NAN_METHOD(Write) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>file descriptor</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">0</span>]-&gt;IsInt32()) {
    Nan::ThrowTypeError(<span class="hljs-string">"First argument must be an int"</span>);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">int</span> fd = info[<span class="hljs-number">0</span>]-&gt;ToInt32()-&gt;Int32Value();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>buffer</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">1</span>]-&gt;IsObject() || !node::Buffer::HasInstance(info[<span class="hljs-number">1</span>])) {
    Nan::ThrowTypeError(<span class="hljs-string">"Second argument must be a buffer"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Object&gt; buffer = info[<span class="hljs-number">1</span>]-&gt;ToObject();
  <span class="hljs-keyword">char</span>* bufferData = node::Buffer::Data(buffer);
  <span class="hljs-keyword">size_t</span> bufferLength = node::Buffer::Length(buffer);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>callback</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">2</span>]-&gt;IsFunction()) {
    Nan::ThrowTypeError(<span class="hljs-string">"Third argument must be a function"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Function&gt; callback = info[<span class="hljs-number">2</span>].As&lt;v8::Function&gt;();

  WriteBaton* baton = <span class="hljs-keyword">new</span> WriteBaton();
  <span class="hljs-built_in">memset</span>(baton, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(WriteBaton));
  baton-&gt;fd = fd;
  baton-&gt;buffer.Reset(buffer);
  baton-&gt;bufferData = bufferData;
  baton-&gt;bufferLength = bufferLength;
  baton-&gt;offset = <span class="hljs-number">0</span>;
  baton-&gt;callback = <span class="hljs-keyword">new</span> Nan::Callback(callback);

  QueuedWrite* queuedWrite = <span class="hljs-keyword">new</span> QueuedWrite();
  <span class="hljs-built_in">memset</span>(queuedWrite, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(QueuedWrite));
  queuedWrite-&gt;baton = baton;
  queuedWrite-&gt;req.data = queuedWrite;

  _WriteQueue *q = qForFD(fd);
  <span class="hljs-keyword">if</span> (!q) {
    Nan::ThrowTypeError(<span class="hljs-string">"There's no write queue for that file descriptor (write)!"</span>);
    <span class="hljs-keyword">return</span>;
  }

  q-&gt;lock();
  QueuedWrite &amp;write_queue = q-&gt;get();
  <span class="hljs-keyword">bool</span> empty = write_queue.empty();

  write_queue.insert_tail(queuedWrite);

  <span class="hljs-keyword">if</span> (empty) {
    uv_queue_work(uv_default_loop(), &amp;queuedWrite-&gt;req, EIO_Write, (uv_after_work_cb)EIO_AfterWrite);
  }
  q-&gt;unlock();

  <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_AfterWrite</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  Nan::HandleScope scope;

  QueuedWrite* queuedWrite = <span class="hljs-keyword">static_cast</span>&lt;QueuedWrite*&gt;(req-&gt;data);
  WriteBaton* data = <span class="hljs-keyword">static_cast</span>&lt;WriteBaton*&gt;(queuedWrite-&gt;baton);

  v8::Local&lt;v8::Value&gt; argv[<span class="hljs-number">2</span>];
  <span class="hljs-keyword">if</span> (data-&gt;errorString[<span class="hljs-number">0</span>]) {
    argv[<span class="hljs-number">0</span>] = v8::Exception::Error(Nan::New&lt;v8::String&gt;(data-&gt;errorString).ToLocalChecked());
    argv[<span class="hljs-number">1</span>] = Nan::Undefined();
  } <span class="hljs-keyword">else</span> {
    argv[<span class="hljs-number">0</span>] = Nan::Undefined();
    argv[<span class="hljs-number">1</span>] = Nan::New&lt;v8::Int32&gt;(data-&gt;result);
  }
  data-&gt;callback-&gt;Call(<span class="hljs-number">2</span>, argv);

  <span class="hljs-keyword">if</span> (data-&gt;offset &lt; data-&gt;bufferLength &amp;&amp; !data-&gt;errorString[<span class="hljs-number">0</span>]) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>We're not done with this baton, so throw it right back onto the queue.
Don't re-push the write in the event loop if there was an error; because same error could occur again!
TODO: Add a uv_poll here for unix...
fprintf(stderr, &quot;Write again...\n&quot;);</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">    uv_queue_work(uv_default_loop(), req, EIO_Write, (uv_after_work_cb)EIO_AfterWrite);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">int</span> fd = data-&gt;fd;
  _WriteQueue *q = qForFD(fd);
  <span class="hljs-keyword">if</span> (!q) {
    Nan::ThrowTypeError(<span class="hljs-string">"There's no write queue for that file descriptor (after write)!"</span>);
    <span class="hljs-keyword">return</span>;
  }

  q-&gt;lock();
  QueuedWrite &amp;write_queue = q-&gt;get();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>remove this one from the list</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  queuedWrite-&gt;remove();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>If there are any left, start a new thread to write the next one.</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!write_queue.empty()) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>Always pull the next work item from the head of the queue</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">    QueuedWrite* nextQueuedWrite = write_queue.next;
    uv_queue_work(uv_default_loop(), &amp;nextQueuedWrite-&gt;req, EIO_Write, (uv_after_work_cb)EIO_AfterWrite);
  }
  q-&gt;unlock();

  data-&gt;buffer.Reset();
  <span class="hljs-keyword">delete</span> data-&gt;callback;
  <span class="hljs-keyword">delete</span> data;
  <span class="hljs-keyword">delete</span> queuedWrite;
}

NAN_METHOD(Close) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>file descriptor</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">0</span>]-&gt;IsInt32()) {
    Nan::ThrowTypeError(<span class="hljs-string">"First argument must be an int"</span>);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">int</span> fd = info[<span class="hljs-number">0</span>]-&gt;ToInt32()-&gt;Int32Value();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>callback</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">1</span>]-&gt;IsFunction()) {
    Nan::ThrowTypeError(<span class="hljs-string">"Second argument must be a function"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Function&gt; callback = info[<span class="hljs-number">1</span>].As&lt;v8::Function&gt;();

  CloseBaton* baton = <span class="hljs-keyword">new</span> CloseBaton();
  <span class="hljs-built_in">memset</span>(baton, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(CloseBaton));
  baton-&gt;fd = fd;
  baton-&gt;callback = <span class="hljs-keyword">new</span> Nan::Callback(callback);

  <span class="hljs-keyword">uv_work_t</span>* req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uv_work_t</span>();
  req-&gt;data = baton;
  uv_queue_work(uv_default_loop(), req, EIO_Close, (uv_after_work_cb)EIO_AfterClose);

  <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_AfterClose</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  Nan::HandleScope scope;

  CloseBaton* data = <span class="hljs-keyword">static_cast</span>&lt;CloseBaton*&gt;(req-&gt;data);

  v8::Local&lt;v8::Value&gt; argv[<span class="hljs-number">1</span>];
  <span class="hljs-keyword">if</span> (data-&gt;errorString[<span class="hljs-number">0</span>]) {
    argv[<span class="hljs-number">0</span>] = v8::Exception::Error(Nan::New&lt;v8::String&gt;(data-&gt;errorString).ToLocalChecked());
  } <span class="hljs-keyword">else</span> {
    argv[<span class="hljs-number">0</span>] = Nan::Undefined();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>We don't have an error, so clean up the write queue for that fd</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">
    _WriteQueue *q = qForFD(data-&gt;fd);
    <span class="hljs-keyword">if</span> (q) {
      q-&gt;lock();
      QueuedWrite &amp;write_queue = q-&gt;get();
      <span class="hljs-keyword">while</span> (!write_queue.empty()) {
        QueuedWrite *del_q = write_queue.next;
        del_q-&gt;baton-&gt;buffer.Reset();
        del_q-&gt;remove();
      }
      q-&gt;unlock();

      deleteQForFD(data-&gt;fd);
    }
  }
  data-&gt;callback-&gt;Call(<span class="hljs-number">1</span>, argv);

  <span class="hljs-keyword">delete</span> data-&gt;callback;
  <span class="hljs-keyword">delete</span> data;
  <span class="hljs-keyword">delete</span> req;
}

NAN_METHOD(List) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>callback</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">0</span>]-&gt;IsFunction()) {
    Nan::ThrowTypeError(<span class="hljs-string">"First argument must be a function"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Function&gt; callback = info[<span class="hljs-number">0</span>].As&lt;v8::Function&gt;();

  ListBaton* baton = <span class="hljs-keyword">new</span> ListBaton();
  <span class="hljs-built_in">strcpy</span>(baton-&gt;errorString, <span class="hljs-string">""</span>);
  baton-&gt;callback = <span class="hljs-keyword">new</span> Nan::Callback(callback);

  <span class="hljs-keyword">uv_work_t</span>* req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uv_work_t</span>();
  req-&gt;data = baton;
  uv_queue_work(uv_default_loop(), req, EIO_List, (uv_after_work_cb)EIO_AfterList);

  <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_AfterList</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  Nan::HandleScope scope;

  ListBaton* data = <span class="hljs-keyword">static_cast</span>&lt;ListBaton*&gt;(req-&gt;data);

  v8::Local&lt;v8::Value&gt; argv[<span class="hljs-number">2</span>];
  <span class="hljs-keyword">if</span> (data-&gt;errorString[<span class="hljs-number">0</span>]) {
    argv[<span class="hljs-number">0</span>] = v8::Exception::Error(Nan::New&lt;v8::String&gt;(data-&gt;errorString).ToLocalChecked());
    argv[<span class="hljs-number">1</span>] = Nan::Undefined();
  } <span class="hljs-keyword">else</span> {
    v8::Local&lt;v8::Array&gt; results = Nan::New&lt;v8::Array&gt;();
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;ListResultItem*&gt;::iterator it = data-&gt;results.begin(); it != data-&gt;results.end(); ++it, i++) {
      v8::Local&lt;v8::Object&gt; item = Nan::New&lt;v8::Object&gt;();

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>((*it)-&gt;comName.c_str()) &gt; <span class="hljs-number">0</span>) {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"comName"</span>).ToLocalChecked(), Nan::New&lt;v8::String&gt;((*it)-&gt;comName.c_str()).ToLocalChecked());
      } <span class="hljs-keyword">else</span> {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"comName"</span>).ToLocalChecked(), Nan::Undefined());
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>((*it)-&gt;manufacturer.c_str()) &gt; <span class="hljs-number">0</span>) {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"manufacturer"</span>).ToLocalChecked(), Nan::New&lt;v8::String&gt;((*it)-&gt;manufacturer.c_str()).ToLocalChecked());
      } <span class="hljs-keyword">else</span> {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"manufacturer"</span>).ToLocalChecked(), Nan::Undefined());
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>((*it)-&gt;serialNumber.c_str()) &gt; <span class="hljs-number">0</span>) {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"serialNumber"</span>).ToLocalChecked(), Nan::New&lt;v8::String&gt;((*it)-&gt;serialNumber.c_str()).ToLocalChecked());
      } <span class="hljs-keyword">else</span> {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"serialNumber"</span>).ToLocalChecked(), Nan::Undefined());
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>((*it)-&gt;pnpId.c_str()) &gt; <span class="hljs-number">0</span>) {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"pnpId"</span>).ToLocalChecked(), Nan::New&lt;v8::String&gt;((*it)-&gt;pnpId.c_str()).ToLocalChecked());
      } <span class="hljs-keyword">else</span> {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"pnpId"</span>).ToLocalChecked(), Nan::Undefined());
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>((*it)-&gt;locationId.c_str()) &gt; <span class="hljs-number">0</span>) {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"locationId"</span>).ToLocalChecked(), Nan::New&lt;v8::String&gt;((*it)-&gt;locationId.c_str()).ToLocalChecked());
      } <span class="hljs-keyword">else</span> {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"locationId"</span>).ToLocalChecked(), Nan::Undefined());
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>((*it)-&gt;vendorId.c_str()) &gt; <span class="hljs-number">0</span>) {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"vendorId"</span>).ToLocalChecked(), Nan::New&lt;v8::String&gt;((*it)-&gt;vendorId.c_str()).ToLocalChecked());
      } <span class="hljs-keyword">else</span> {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"vendorId"</span>).ToLocalChecked(), Nan::Undefined());
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>((*it)-&gt;productId.c_str()) &gt; <span class="hljs-number">0</span>) {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"productId"</span>).ToLocalChecked(), Nan::New&lt;v8::String&gt;((*it)-&gt;productId.c_str()).ToLocalChecked());
      } <span class="hljs-keyword">else</span> {
        Nan::Set(item, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"productId"</span>).ToLocalChecked(), Nan::Undefined());
      }

      Nan::Set(results, i, item);
    }
    argv[<span class="hljs-number">0</span>] = Nan::Null();
    argv[<span class="hljs-number">1</span>] = results;
  }
  data-&gt;callback-&gt;Call(<span class="hljs-number">2</span>, argv);

  <span class="hljs-keyword">delete</span> data-&gt;callback;
  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;ListResultItem*&gt;::iterator it = data-&gt;results.begin(); it != data-&gt;results.end(); ++it) {
    <span class="hljs-keyword">delete</span> *it;
  }
  <span class="hljs-keyword">delete</span> data;
  <span class="hljs-keyword">delete</span> req;
}

NAN_METHOD(Flush) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>file descriptor</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">0</span>]-&gt;IsInt32()) {
    Nan::ThrowTypeError(<span class="hljs-string">"First argument must be an int"</span>);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">int</span> fd = info[<span class="hljs-number">0</span>]-&gt;ToInt32()-&gt;Int32Value();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>callback</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">1</span>]-&gt;IsFunction()) {
    Nan::ThrowTypeError(<span class="hljs-string">"Second argument must be a function"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Function&gt; callback = info[<span class="hljs-number">1</span>].As&lt;v8::Function&gt;();

  FlushBaton* baton = <span class="hljs-keyword">new</span> FlushBaton();
  <span class="hljs-built_in">memset</span>(baton, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(FlushBaton));
  baton-&gt;fd = fd;
  baton-&gt;callback = <span class="hljs-keyword">new</span> Nan::Callback(callback);

  <span class="hljs-keyword">uv_work_t</span>* req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uv_work_t</span>();
  req-&gt;data = baton;
  uv_queue_work(uv_default_loop(), req, EIO_Flush, (uv_after_work_cb)EIO_AfterFlush);

  <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_AfterFlush</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  Nan::HandleScope scope;

  FlushBaton* data = <span class="hljs-keyword">static_cast</span>&lt;FlushBaton*&gt;(req-&gt;data);

  v8::Local&lt;v8::Value&gt; argv[<span class="hljs-number">2</span>];

  <span class="hljs-keyword">if</span> (data-&gt;errorString[<span class="hljs-number">0</span>]) {
    argv[<span class="hljs-number">0</span>] = v8::Exception::Error(Nan::New&lt;v8::String&gt;(data-&gt;errorString).ToLocalChecked());
    argv[<span class="hljs-number">1</span>] = Nan::Undefined();
  } <span class="hljs-keyword">else</span> {
    argv[<span class="hljs-number">0</span>] = Nan::Undefined();
    argv[<span class="hljs-number">1</span>] = Nan::New&lt;v8::Int32&gt;(data-&gt;result);
  }
  data-&gt;callback-&gt;Call(<span class="hljs-number">2</span>, argv);

  <span class="hljs-keyword">delete</span> data-&gt;callback;
  <span class="hljs-keyword">delete</span> data;
  <span class="hljs-keyword">delete</span> req;
}

NAN_METHOD(Set) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>file descriptor</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">0</span>]-&gt;IsInt32()) {
    Nan::ThrowTypeError(<span class="hljs-string">"First argument must be an int"</span>);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">int</span> fd = info[<span class="hljs-number">0</span>]-&gt;ToInt32()-&gt;Int32Value();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>options</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">1</span>]-&gt;IsObject()) {
    Nan::ThrowTypeError(<span class="hljs-string">"Second argument must be an object"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Object&gt; options = info[<span class="hljs-number">1</span>]-&gt;ToObject();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>callback</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">2</span>]-&gt;IsFunction()) {
    Nan::ThrowTypeError(<span class="hljs-string">"Third argument must be a function"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Function&gt; callback = info[<span class="hljs-number">2</span>].As&lt;v8::Function&gt;();

  SetBaton* baton = <span class="hljs-keyword">new</span> SetBaton();
  <span class="hljs-built_in">memset</span>(baton, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(SetBaton));
  baton-&gt;fd = fd;
  baton-&gt;callback = <span class="hljs-keyword">new</span> Nan::Callback(callback);
  baton-&gt;brk = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"brk"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;rts = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"rts"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;cts = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"cts"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;dtr = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"dtr"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();
  baton-&gt;dsr = Nan::Get(options, Nan::New&lt;v8::String&gt;(<span class="hljs-string">"dsr"</span>).ToLocalChecked()).ToLocalChecked()-&gt;ToBoolean()-&gt;BooleanValue();

  <span class="hljs-keyword">uv_work_t</span>* req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uv_work_t</span>();
  req-&gt;data = baton;
  uv_queue_work(uv_default_loop(), req, EIO_Set, (uv_after_work_cb)EIO_AfterSet);

  <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_AfterSet</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  Nan::HandleScope scope;

  SetBaton* data = <span class="hljs-keyword">static_cast</span>&lt;SetBaton*&gt;(req-&gt;data);

  v8::Local&lt;v8::Value&gt; argv[<span class="hljs-number">2</span>];

  <span class="hljs-keyword">if</span> (data-&gt;errorString[<span class="hljs-number">0</span>]) {
    argv[<span class="hljs-number">0</span>] = v8::Exception::Error(Nan::New&lt;v8::String&gt;(data-&gt;errorString).ToLocalChecked());
    argv[<span class="hljs-number">1</span>] = Nan::Undefined();
  } <span class="hljs-keyword">else</span> {
    argv[<span class="hljs-number">0</span>] = Nan::Undefined();
    argv[<span class="hljs-number">1</span>] = Nan::New&lt;v8::Int32&gt;(data-&gt;result);
  }
  data-&gt;callback-&gt;Call(<span class="hljs-number">2</span>, argv);

  <span class="hljs-keyword">delete</span> data-&gt;callback;
  <span class="hljs-keyword">delete</span> data;
  <span class="hljs-keyword">delete</span> req;
}

NAN_METHOD(Drain) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>file descriptor</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">0</span>]-&gt;IsInt32()) {
    Nan::ThrowTypeError(<span class="hljs-string">"First argument must be an int"</span>);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">int</span> fd = info[<span class="hljs-number">0</span>]-&gt;ToInt32()-&gt;Int32Value();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>callback</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  <span class="hljs-keyword">if</span> (!info[<span class="hljs-number">1</span>]-&gt;IsFunction()) {
    Nan::ThrowTypeError(<span class="hljs-string">"Second argument must be a function"</span>);
    <span class="hljs-keyword">return</span>;
  }
  v8::Local&lt;v8::Function&gt; callback = info[<span class="hljs-number">1</span>].As&lt;v8::Function&gt;();

  DrainBaton* baton = <span class="hljs-keyword">new</span> DrainBaton();
  <span class="hljs-built_in">memset</span>(baton, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(DrainBaton));
  baton-&gt;fd = fd;
  baton-&gt;callback = <span class="hljs-keyword">new</span> Nan::Callback(callback);

  <span class="hljs-keyword">uv_work_t</span>* req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uv_work_t</span>();
  req-&gt;data = baton;
  uv_queue_work(uv_default_loop(), req, EIO_Drain, (uv_after_work_cb)EIO_AfterDrain);

  <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EIO_AfterDrain</span><span class="hljs-params">(<span class="hljs-keyword">uv_work_t</span>* req)</span> </span>{
  Nan::HandleScope scope;

  DrainBaton* data = <span class="hljs-keyword">static_cast</span>&lt;DrainBaton*&gt;(req-&gt;data);

  v8::Local&lt;v8::Value&gt; argv[<span class="hljs-number">2</span>];

  <span class="hljs-keyword">if</span> (data-&gt;errorString[<span class="hljs-number">0</span>]) {
    argv[<span class="hljs-number">0</span>] = v8::Exception::Error(Nan::New&lt;v8::String&gt;(data-&gt;errorString).ToLocalChecked());
    argv[<span class="hljs-number">1</span>] = Nan::Undefined();
  } <span class="hljs-keyword">else</span> {
    argv[<span class="hljs-number">0</span>] = Nan::Undefined();
    argv[<span class="hljs-number">1</span>] = Nan::New&lt;v8::Int32&gt;(data-&gt;result);
  }
  data-&gt;callback-&gt;Call(<span class="hljs-number">2</span>, argv);

  <span class="hljs-keyword">delete</span> data-&gt;callback;
  <span class="hljs-keyword">delete</span> data;
  <span class="hljs-keyword">delete</span> req;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>Change request for ticket #401 - credit to @sguilly</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">SerialPortParity NAN_INLINE(ToParityEnum(const v8::Local&lt;v8::String&gt;&amp; v8str)) {
  Nan::HandleScope scope;
  Nan::Utf8String *str = new Nan::Utf8String(v8str);
  size_t count = strlen(**str);
  SerialPortParity parity = SERIALPORT_PARITY_NONE;
  if (!strncasecmp(**str, "none", count)) {
  parity = SERIALPORT_PARITY_NONE;
  } else if (!strncasecmp(**str, "even", count)) {
  parity = SERIALPORT_PARITY_EVEN;
  } else if (!strncasecmp(**str, "mark", count)) {
  parity = SERIALPORT_PARITY_MARK;
  } else if (!strncasecmp(**str, "odd", count)) {
  parity = SERIALPORT_PARITY_ODD;
  } else if (!strncasecmp(**str, "space", count)) {
  parity = SERIALPORT_PARITY_SPACE;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>delete[] str;</p>

        </td>
        <td class="code highlight">
          <pre class="cpp">  return parity;
}


SerialPortStopBits NAN_INLINE(ToStopBitEnum(double stopBits)) {
  if (stopBits &gt; 1.4 &amp;&amp; stopBits &lt; 1.6) {
    return SERIALPORT_STOPBITS_ONE_FIVE;
  }
  if (stopBits == 2) {
    return SERIALPORT_STOPBITS_TWO;
  }
  return SERIALPORT_STOPBITS_ONE;
}

extern "C" {
  void init(v8::Handle&lt;v8::Object&gt; target) {
    Nan::HandleScope scope;
    Nan::SetMethod(target, "set", Set);
    Nan::SetMethod(target, "open", Open);
    Nan::SetMethod(target, "update", Update);
    Nan::SetMethod(target, "write", Write);
    Nan::SetMethod(target, "close", Close);
    Nan::SetMethod(target, "list", List);
    Nan::SetMethod(target, "flush", Flush);
    Nan::SetMethod(target, "drain", Drain);

#ifndef WIN32
    SerialportPoller::Init(target);
#endif
  }
}

NODE_MODULE(serialport, init);

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
