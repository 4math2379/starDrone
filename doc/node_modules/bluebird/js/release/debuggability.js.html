<!DOCTYPE html>
<html>
<head>
  <title>debuggability.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../../doc-style.css" />
  <script src="../../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../../";
    var thisFile = "node_modules/bluebird/js/release/debuggability.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>debuggability.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">"use strict"</span>;
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Promise, Context</span>) </span>{
<span class="hljs-keyword">var</span> getDomain = <span class="hljs-built_in">Promise</span>._getDomain;
<span class="hljs-keyword">var</span> <span class="hljs-keyword">async</span> = <span class="hljs-built_in">Promise</span>._async;
<span class="hljs-keyword">var</span> Warning = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./errors"</span>).Warning;
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./util"</span>);
<span class="hljs-keyword">var</span> canAttachTrace = util.canAttachTrace;
<span class="hljs-keyword">var</span> unhandledRejectionHandled;
<span class="hljs-keyword">var</span> possiblyUnhandledRejection;
<span class="hljs-keyword">var</span> bluebirdFramePattern =
    <span class="hljs-regexp">/[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/</span>;
<span class="hljs-keyword">var</span> nodeFramePattern = <span class="hljs-regexp">/\((?:timers\.js):\d+:\d+\)/</span>;
<span class="hljs-keyword">var</span> parseLinePattern = <span class="hljs-regexp">/[\/&lt;\(](.+?):(\d+):(\d+)\)?\s*$/</span>;
<span class="hljs-keyword">var</span> stackFramePattern = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">var</span> formatStack = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">var</span> indentStackFrames = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">var</span> printWarning;
<span class="hljs-keyword">var</span> debugging = !!(util.env(<span class="hljs-string">"BLUEBIRD_DEBUG"</span>) != <span class="hljs-number">0</span> &amp;&amp;
                        (<span class="hljs-literal">false</span> ||
                         util.env(<span class="hljs-string">"BLUEBIRD_DEBUG"</span>) ||
                         util.env(<span class="hljs-string">"NODE_ENV"</span>) === <span class="hljs-string">"development"</span>));

<span class="hljs-keyword">var</span> warnings = !!(util.env(<span class="hljs-string">"BLUEBIRD_WARNINGS"</span>) != <span class="hljs-number">0</span> &amp;&amp;
    (debugging || util.env(<span class="hljs-string">"BLUEBIRD_WARNINGS"</span>)));

<span class="hljs-keyword">var</span> longStackTraces = !!(util.env(<span class="hljs-string">"BLUEBIRD_LONG_STACK_TRACES"</span>) != <span class="hljs-number">0</span> &amp;&amp;
    (debugging || util.env(<span class="hljs-string">"BLUEBIRD_LONG_STACK_TRACES"</span>)));

<span class="hljs-keyword">var</span> wForgottenReturn = util.env(<span class="hljs-string">"BLUEBIRD_W_FORGOTTEN_RETURN"</span>) != <span class="hljs-number">0</span> &amp;&amp;
    (warnings || !!util.env(<span class="hljs-string">"BLUEBIRD_W_FORGOTTEN_RETURN"</span>));

<span class="hljs-built_in">Promise</span>.prototype.suppressUnhandledRejections = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> target = <span class="hljs-keyword">this</span>._target();
    target._bitField = ((target._bitField &amp; (~<span class="hljs-number">1048576</span>)) |
                      <span class="hljs-number">524288</span>);
};

<span class="hljs-built_in">Promise</span>.prototype._ensurePossibleRejectionHandled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>._bitField &amp; <span class="hljs-number">524288</span>) !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>._setRejectionIsUnhandled();
    <span class="hljs-keyword">async</span>.invokeLater(<span class="hljs-keyword">this</span>._notifyUnhandledRejection, <span class="hljs-keyword">this</span>, <span class="hljs-literal">undefined</span>);
};

<span class="hljs-built_in">Promise</span>.prototype._notifyUnhandledRejectionIsHandled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    fireRejectionEvent(<span class="hljs-string">"rejectionHandled"</span>,
                                  unhandledRejectionHandled, <span class="hljs-literal">undefined</span>, <span class="hljs-keyword">this</span>);
};

<span class="hljs-built_in">Promise</span>.prototype._setReturnedNonUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._bitField = <span class="hljs-keyword">this</span>._bitField | <span class="hljs-number">268435456</span>;
};

<span class="hljs-built_in">Promise</span>.prototype._returnedNonUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>._bitField &amp; <span class="hljs-number">268435456</span>) !== <span class="hljs-number">0</span>;
};

<span class="hljs-built_in">Promise</span>.prototype._notifyUnhandledRejection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._isRejectionUnhandled()) {
        <span class="hljs-keyword">var</span> reason = <span class="hljs-keyword">this</span>._settledValue();
        <span class="hljs-keyword">this</span>._setUnhandledRejectionIsNotified();
        fireRejectionEvent(<span class="hljs-string">"unhandledRejection"</span>,
                                      possiblyUnhandledRejection, reason, <span class="hljs-keyword">this</span>);
    }
};

<span class="hljs-built_in">Promise</span>.prototype._setUnhandledRejectionIsNotified = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._bitField = <span class="hljs-keyword">this</span>._bitField | <span class="hljs-number">262144</span>;
};

<span class="hljs-built_in">Promise</span>.prototype._unsetUnhandledRejectionIsNotified = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._bitField = <span class="hljs-keyword">this</span>._bitField &amp; (~<span class="hljs-number">262144</span>);
};

<span class="hljs-built_in">Promise</span>.prototype._isUnhandledRejectionNotified = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>._bitField &amp; <span class="hljs-number">262144</span>) &gt; <span class="hljs-number">0</span>;
};

<span class="hljs-built_in">Promise</span>.prototype._setRejectionIsUnhandled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._bitField = <span class="hljs-keyword">this</span>._bitField | <span class="hljs-number">1048576</span>;
};

<span class="hljs-built_in">Promise</span>.prototype._unsetRejectionIsUnhandled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._bitField = <span class="hljs-keyword">this</span>._bitField &amp; (~<span class="hljs-number">1048576</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._isUnhandledRejectionNotified()) {
        <span class="hljs-keyword">this</span>._unsetUnhandledRejectionIsNotified();
        <span class="hljs-keyword">this</span>._notifyUnhandledRejectionIsHandled();
    }
};

<span class="hljs-built_in">Promise</span>.prototype._isRejectionUnhandled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>._bitField &amp; <span class="hljs-number">1048576</span>) &gt; <span class="hljs-number">0</span>;
};

<span class="hljs-built_in">Promise</span>.prototype._warn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, shouldUseOwnTrace, promise</span>) </span>{
    <span class="hljs-keyword">return</span> warn(message, shouldUseOwnTrace, promise || <span class="hljs-keyword">this</span>);
};

<span class="hljs-built_in">Promise</span>.onPossiblyUnhandledRejection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">var</span> domain = getDomain();
    possiblyUnhandledRejection =
        <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">"function"</span> ? (domain === <span class="hljs-literal">null</span> ?
                                            fn : util.domainBind(domain, fn))
                                 : <span class="hljs-literal">undefined</span>;
};

<span class="hljs-built_in">Promise</span>.onUnhandledRejectionHandled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">var</span> domain = getDomain();
    unhandledRejectionHandled =
        <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">"function"</span> ? (domain === <span class="hljs-literal">null</span> ?
                                            fn : util.domainBind(domain, fn))
                                 : <span class="hljs-literal">undefined</span>;
};

<span class="hljs-keyword">var</span> disableLongStackTraces = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
<span class="hljs-built_in">Promise</span>.longStackTraces = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">async</span>.haveItemsQueued() &amp;&amp; !config.longStackTraces) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a"</span>);
    }
    <span class="hljs-keyword">if</span> (!config.longStackTraces &amp;&amp; longStackTracesIsSupported()) {
        <span class="hljs-keyword">var</span> Promise_captureStackTrace = <span class="hljs-built_in">Promise</span>.prototype._captureStackTrace;
        <span class="hljs-keyword">var</span> Promise_attachExtraTrace = <span class="hljs-built_in">Promise</span>.prototype._attachExtraTrace;
        config.longStackTraces = <span class="hljs-literal">true</span>;
        disableLongStackTraces = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">async</span>.haveItemsQueued() &amp;&amp; !config.longStackTraces) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a"</span>);
            }
            <span class="hljs-built_in">Promise</span>.prototype._captureStackTrace = Promise_captureStackTrace;
            <span class="hljs-built_in">Promise</span>.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            <span class="hljs-keyword">async</span>.enableTrampoline();
            config.longStackTraces = <span class="hljs-literal">false</span>;
        };
        <span class="hljs-built_in">Promise</span>.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        <span class="hljs-built_in">Promise</span>.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        <span class="hljs-keyword">async</span>.disableTrampolineIfNecessary();
    }
};

<span class="hljs-built_in">Promise</span>.hasLongStackTraces = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> config.longStackTraces &amp;&amp; longStackTracesIsSupported();
};

<span class="hljs-keyword">var</span> fireDomEvent = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> CustomEvent === <span class="hljs-string">"function"</span>) {
            <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">"CustomEvent"</span>);
            util.global.dispatchEvent(event);
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, event</span>) </span>{
                <span class="hljs-keyword">var</span> domEvent = <span class="hljs-keyword">new</span> CustomEvent(name.toLowerCase(), {
                    <span class="hljs-attr">detail</span>: event,
                    <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">true</span>
                });
                <span class="hljs-keyword">return</span> !util.global.dispatchEvent(domEvent);
            };
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Event === <span class="hljs-string">"function"</span>) {
            <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> Event(<span class="hljs-string">"CustomEvent"</span>);
            util.global.dispatchEvent(event);
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, event</span>) </span>{
                <span class="hljs-keyword">var</span> domEvent = <span class="hljs-keyword">new</span> Event(name.toLowerCase(), {
                    <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">true</span>
                });
                domEvent.detail = event;
                <span class="hljs-keyword">return</span> !util.global.dispatchEvent(domEvent);
            };
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> event = <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">"CustomEvent"</span>);
            event.initCustomEvent(<span class="hljs-string">"testingtheevent"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, {});
            util.global.dispatchEvent(event);
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, event</span>) </span>{
                <span class="hljs-keyword">var</span> domEvent = <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">"CustomEvent"</span>);
                domEvent.initCustomEvent(name.toLowerCase(), <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>,
                    event);
                <span class="hljs-keyword">return</span> !util.global.dispatchEvent(domEvent);
            };
        }
    } <span class="hljs-keyword">catch</span> (e) {}
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };
})();

<span class="hljs-keyword">var</span> fireGlobalEvent = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (util.isNode) {
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> process.emit.apply(process, <span class="hljs-built_in">arguments</span>);
        };
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (!util.global) {
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            };
        }
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
            <span class="hljs-keyword">var</span> methodName = <span class="hljs-string">"on"</span> + name.toLowerCase();
            <span class="hljs-keyword">var</span> method = util.global[methodName];
            <span class="hljs-keyword">if</span> (!method) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            method.apply(util.global, [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        };
    }
})();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generatePromiseLifecycleEventObject</span>(<span class="hljs-params">name, promise</span>) </span>{
    <span class="hljs-keyword">return</span> {<span class="hljs-attr">promise</span>: promise};
}

<span class="hljs-keyword">var</span> eventToObjectGenerator = {
    <span class="hljs-attr">promiseCreated</span>: generatePromiseLifecycleEventObject,
    <span class="hljs-attr">promiseFulfilled</span>: generatePromiseLifecycleEventObject,
    <span class="hljs-attr">promiseRejected</span>: generatePromiseLifecycleEventObject,
    <span class="hljs-attr">promiseResolved</span>: generatePromiseLifecycleEventObject,
    <span class="hljs-attr">promiseCancelled</span>: generatePromiseLifecycleEventObject,
    <span class="hljs-attr">promiseChained</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, promise, child</span>) </span>{
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">promise</span>: promise, <span class="hljs-attr">child</span>: child};
    },
    <span class="hljs-attr">warning</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, warning</span>) </span>{
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">warning</span>: warning};
    },
    <span class="hljs-attr">unhandledRejection</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, reason, promise</span>) </span>{
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">reason</span>: reason, <span class="hljs-attr">promise</span>: promise};
    },
    <span class="hljs-attr">rejectionHandled</span>: generatePromiseLifecycleEventObject
};

<span class="hljs-keyword">var</span> activeFireEvent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">var</span> globalEventFired = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">try</span> {
        globalEventFired = fireGlobalEvent.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>);
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">async</span>.throwLater(e);
        globalEventFired = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">var</span> domEventFired = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">try</span> {
        domEventFired = fireDomEvent(name,
                    eventToObjectGenerator[name].apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>));
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">async</span>.throwLater(e);
        domEventFired = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> domEventFired || globalEventFired;
};

<span class="hljs-built_in">Promise</span>.config = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">opts</span>) </span>{
    opts = <span class="hljs-built_in">Object</span>(opts);
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"longStackTraces"</span> <span class="hljs-keyword">in</span> opts) {
        <span class="hljs-keyword">if</span> (opts.longStackTraces) {
            <span class="hljs-built_in">Promise</span>.longStackTraces();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!opts.longStackTraces &amp;&amp; <span class="hljs-built_in">Promise</span>.hasLongStackTraces()) {
            disableLongStackTraces();
        }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"warnings"</span> <span class="hljs-keyword">in</span> opts) {
        <span class="hljs-keyword">var</span> warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;

        <span class="hljs-keyword">if</span> (util.isObject(warningsOption)) {
            <span class="hljs-keyword">if</span> (<span class="hljs-string">"wForgottenReturn"</span> <span class="hljs-keyword">in</span> warningsOption) {
                wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
        }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"cancellation"</span> <span class="hljs-keyword">in</span> opts &amp;&amp; opts.cancellation &amp;&amp; !config.cancellation) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">async</span>.haveItemsQueued()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                <span class="hljs-string">"cannot enable cancellation after promises are in use"</span>);
        }
        <span class="hljs-built_in">Promise</span>.prototype._clearCancellationData =
            cancellationClearCancellationData;
        <span class="hljs-built_in">Promise</span>.prototype._propagateFrom = cancellationPropagateFrom;
        <span class="hljs-built_in">Promise</span>.prototype._onCancel = cancellationOnCancel;
        <span class="hljs-built_in">Promise</span>.prototype._setOnCancel = cancellationSetOnCancel;
        <span class="hljs-built_in">Promise</span>.prototype._attachCancellationCallback =
            cancellationAttachCancellationCallback;
        <span class="hljs-built_in">Promise</span>.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"monitoring"</span> <span class="hljs-keyword">in</span> opts) {
        <span class="hljs-keyword">if</span> (opts.monitoring &amp;&amp; !config.monitoring) {
            config.monitoring = <span class="hljs-literal">true</span>;
            <span class="hljs-built_in">Promise</span>.prototype._fireEvent = activeFireEvent;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!opts.monitoring &amp;&amp; config.monitoring) {
            config.monitoring = <span class="hljs-literal">false</span>;
            <span class="hljs-built_in">Promise</span>.prototype._fireEvent = defaultFireEvent;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultFireEvent</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }

<span class="hljs-built_in">Promise</span>.prototype._fireEvent = defaultFireEvent;
<span class="hljs-built_in">Promise</span>.prototype._execute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">executor, resolve, reject</span>) </span>{
    <span class="hljs-keyword">try</span> {
        executor(resolve, reject);
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> e;
    }
};
<span class="hljs-built_in">Promise</span>.prototype._onCancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
<span class="hljs-built_in">Promise</span>.prototype._setOnCancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">handler</span>) </span>{ ; };
<span class="hljs-built_in">Promise</span>.prototype._attachCancellationCallback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onCancel</span>) </span>{
    ;
};
<span class="hljs-built_in">Promise</span>.prototype._captureStackTrace = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
<span class="hljs-built_in">Promise</span>.prototype._attachExtraTrace = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
<span class="hljs-built_in">Promise</span>.prototype._clearCancellationData = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
<span class="hljs-built_in">Promise</span>.prototype._propagateFrom = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, flags</span>) </span>{
    ;
    ;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancellationExecute</span>(<span class="hljs-params">executor, resolve, reject</span>) </span>{
    <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">try</span> {
        executor(resolve, reject, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onCancel</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onCancel !== <span class="hljs-string">"function"</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"onCancel must be a function, got: "</span> +
                                    util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
        });
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> e;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancellationAttachCancellationCallback</span>(<span class="hljs-params">onCancel</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._isCancellable()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> previousOnCancel = <span class="hljs-keyword">this</span>._onCancel();
    <span class="hljs-keyword">if</span> (previousOnCancel !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">if</span> (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>._setOnCancel([previousOnCancel, onCancel]);
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>._setOnCancel(onCancel);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancellationOnCancel</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._onCancelField;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancellationSetOnCancel</span>(<span class="hljs-params">onCancel</span>) </span>{
    <span class="hljs-keyword">this</span>._onCancelField = onCancel;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancellationClearCancellationData</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._cancellationParent = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">this</span>._onCancelField = <span class="hljs-literal">undefined</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancellationPropagateFrom</span>(<span class="hljs-params">parent, flags</span>) </span>{
    <span class="hljs-keyword">if</span> ((flags &amp; <span class="hljs-number">1</span>) !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>._cancellationParent = parent;
        <span class="hljs-keyword">var</span> branchesRemainingToCancel = parent._branchesRemainingToCancel;
        <span class="hljs-keyword">if</span> (branchesRemainingToCancel === <span class="hljs-literal">undefined</span>) {
            branchesRemainingToCancel = <span class="hljs-number">0</span>;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">if</span> ((flags &amp; <span class="hljs-number">2</span>) !== <span class="hljs-number">0</span> &amp;&amp; parent._isBound()) {
        <span class="hljs-keyword">this</span>._setBoundTo(parent._boundTo);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindingPropagateFrom</span>(<span class="hljs-params">parent, flags</span>) </span>{
    <span class="hljs-keyword">if</span> ((flags &amp; <span class="hljs-number">2</span>) !== <span class="hljs-number">0</span> &amp;&amp; parent._isBound()) {
        <span class="hljs-keyword">this</span>._setBoundTo(parent._boundTo);
    }
}
<span class="hljs-keyword">var</span> propagateFromFunction = bindingPropagateFrom;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boundValueFunction</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> ret = <span class="hljs-keyword">this</span>._boundTo;
    <span class="hljs-keyword">if</span> (ret !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">if</span> (ret <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {
            <span class="hljs-keyword">if</span> (ret.isFulfilled()) {
                <span class="hljs-keyword">return</span> ret.value();
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            }
        }
    }
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longStackTracesCaptureStackTrace</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._trace = <span class="hljs-keyword">new</span> CapturedTrace(<span class="hljs-keyword">this</span>._peekContext());
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longStackTracesAttachExtraTrace</span>(<span class="hljs-params">error, ignoreSelf</span>) </span>{
    <span class="hljs-keyword">if</span> (canAttachTrace(error)) {
        <span class="hljs-keyword">var</span> trace = <span class="hljs-keyword">this</span>._trace;
        <span class="hljs-keyword">if</span> (trace !== <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">if</span> (ignoreSelf) trace = trace._parent;
        }
        <span class="hljs-keyword">if</span> (trace !== <span class="hljs-literal">undefined</span>) {
            trace.attachExtraTrace(error);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!error.__stackCleaned__) {
            <span class="hljs-keyword">var</span> parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, <span class="hljs-string">"stack"</span>,
                parsed.message + <span class="hljs-string">"\n"</span> + parsed.stack.join(<span class="hljs-string">"\n"</span>));
            util.notEnumerableProp(error, <span class="hljs-string">"__stackCleaned__"</span>, <span class="hljs-literal">true</span>);
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkForgottenReturns</span>(<span class="hljs-params">returnValue, promiseCreated, name, promise,
                               parent</span>) </span>{
    <span class="hljs-keyword">if</span> (returnValue === <span class="hljs-literal">undefined</span> &amp;&amp; promiseCreated !== <span class="hljs-literal">null</span> &amp;&amp;
        wForgottenReturn) {
        <span class="hljs-keyword">if</span> (parent !== <span class="hljs-literal">undefined</span> &amp;&amp; parent._returnedNonUndefined()) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> ((promise._bitField &amp; <span class="hljs-number">65535</span>) === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">if</span> (name) name = name + <span class="hljs-string">" "</span>;
        <span class="hljs-keyword">var</span> handlerLine = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">var</span> creatorLine = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">if</span> (promiseCreated._trace) {
            <span class="hljs-keyword">var</span> traceLines = promiseCreated._trace.stack.split(<span class="hljs-string">"\n"</span>);
            <span class="hljs-keyword">var</span> stack = cleanStack(traceLines);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = stack.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
                <span class="hljs-keyword">var</span> line = stack[i];
                <span class="hljs-keyword">if</span> (!nodeFramePattern.test(line)) {
                    <span class="hljs-keyword">var</span> lineMatches = line.match(parseLinePattern);
                    <span class="hljs-keyword">if</span> (lineMatches) {
                        handlerLine  = <span class="hljs-string">"at "</span> + lineMatches[<span class="hljs-number">1</span>] +
                            <span class="hljs-string">":"</span> + lineMatches[<span class="hljs-number">2</span>] + <span class="hljs-string">":"</span> + lineMatches[<span class="hljs-number">3</span>] + <span class="hljs-string">" "</span>;
                    }
                    <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (stack.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">var</span> firstUserLine = stack[<span class="hljs-number">0</span>];
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; traceLines.length; ++i) {

                    <span class="hljs-keyword">if</span> (traceLines[i] === firstUserLine) {
                        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
                            creatorLine = <span class="hljs-string">"\n"</span> + traceLines[i - <span class="hljs-number">1</span>];
                        }
                        <span class="hljs-keyword">break</span>;
                    }
                }

            }
        }
        <span class="hljs-keyword">var</span> msg = <span class="hljs-string">"a promise was created in a "</span> + name +
            <span class="hljs-string">"handler "</span> + handlerLine + <span class="hljs-string">"but was not returned from it, "</span> +
            <span class="hljs-string">"see http://goo.gl/rRqMUw"</span> +
            creatorLine;
        promise._warn(msg, <span class="hljs-literal">true</span>, promiseCreated);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deprecated</span>(<span class="hljs-params">name, replacement</span>) </span>{
    <span class="hljs-keyword">var</span> message = name +
        <span class="hljs-string">" is deprecated and will be removed in a future version."</span>;
    <span class="hljs-keyword">if</span> (replacement) message += <span class="hljs-string">" Use "</span> + replacement + <span class="hljs-string">" instead."</span>;
    <span class="hljs-keyword">return</span> warn(message);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warn</span>(<span class="hljs-params">message, shouldUseOwnTrace, promise</span>) </span>{
    <span class="hljs-keyword">if</span> (!config.warnings) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> warning = <span class="hljs-keyword">new</span> Warning(message);
    <span class="hljs-keyword">var</span> ctx;
    <span class="hljs-keyword">if</span> (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config.longStackTraces &amp;&amp; (ctx = <span class="hljs-built_in">Promise</span>._peekContext())) {
        ctx.attachExtraTrace(warning);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + <span class="hljs-string">"\n"</span> + parsed.stack.join(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-keyword">if</span> (!activeFireEvent(<span class="hljs-string">"warning"</span>, warning)) {
        formatAndLogError(warning, <span class="hljs-string">""</span>, <span class="hljs-literal">true</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconstructStack</span>(<span class="hljs-params">message, stacks</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; stacks.length - <span class="hljs-number">1</span>; ++i) {
        stacks[i].push(<span class="hljs-string">"From previous event:"</span>);
        stacks[i] = stacks[i].join(<span class="hljs-string">"\n"</span>);
    }
    <span class="hljs-keyword">if</span> (i &lt; stacks.length) {
        stacks[i] = stacks[i].join(<span class="hljs-string">"\n"</span>);
    }
    <span class="hljs-keyword">return</span> message + <span class="hljs-string">"\n"</span> + stacks.join(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeDuplicateOrEmptyJumps</span>(<span class="hljs-params">stacks</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; stacks.length; ++i) {
        <span class="hljs-keyword">if</span> (stacks[i].length === <span class="hljs-number">0</span> ||
            ((i + <span class="hljs-number">1</span> &lt; stacks.length) &amp;&amp; stacks[i][<span class="hljs-number">0</span>] === stacks[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])) {
            stacks.splice(i, <span class="hljs-number">1</span>);
            i--;
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeCommonRoots</span>(<span class="hljs-params">stacks</span>) </span>{
    <span class="hljs-keyword">var</span> current = stacks[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; stacks.length; ++i) {
        <span class="hljs-keyword">var</span> prev = stacks[i];
        <span class="hljs-keyword">var</span> currentLastIndex = current.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> currentLastLine = current[currentLastIndex];
        <span class="hljs-keyword">var</span> commonRootMeetPoint = <span class="hljs-number">-1</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = prev.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) {
            <span class="hljs-keyword">if</span> (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = commonRootMeetPoint; j &gt;= <span class="hljs-number">0</span>; --j) {
            <span class="hljs-keyword">var</span> line = prev[j];
            <span class="hljs-keyword">if</span> (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">break</span>;
            }
        }
        current = prev;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanStack</span>(<span class="hljs-params">stack</span>) </span>{
    <span class="hljs-keyword">var</span> ret = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; stack.length; ++i) {
        <span class="hljs-keyword">var</span> line = stack[i];
        <span class="hljs-keyword">var</span> isTraceLine = <span class="hljs-string">"    (No stack trace)"</span> === line ||
            stackFramePattern.test(line);
        <span class="hljs-keyword">var</span> isInternalFrame = isTraceLine &amp;&amp; shouldIgnore(line);
        <span class="hljs-keyword">if</span> (isTraceLine &amp;&amp; !isInternalFrame) {
            <span class="hljs-keyword">if</span> (indentStackFrames &amp;&amp; line.charAt(<span class="hljs-number">0</span>) !== <span class="hljs-string">" "</span>) {
                line = <span class="hljs-string">"    "</span> + line;
            }
            ret.push(line);
        }
    }
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stackFramesAsArray</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-keyword">var</span> stack = error.stack.replace(<span class="hljs-regexp">/\s+$/g</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; stack.length; ++i) {
        <span class="hljs-keyword">var</span> line = stack[i];
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"    (No stack trace)"</span> === line || stackFramePattern.test(line)) {
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; error.name != <span class="hljs-string">"SyntaxError"</span>) {
        stack = stack.slice(i);
    }
    <span class="hljs-keyword">return</span> stack;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseStackAndMessage</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-keyword">var</span> stack = error.stack;
    <span class="hljs-keyword">var</span> message = error.toString();
    stack = <span class="hljs-keyword">typeof</span> stack === <span class="hljs-string">"string"</span> &amp;&amp; stack.length &gt; <span class="hljs-number">0</span>
                ? stackFramesAsArray(error) : [<span class="hljs-string">"    (No stack trace)"</span>];
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: message,
        <span class="hljs-attr">stack</span>: error.name == <span class="hljs-string">"SyntaxError"</span> ? stack : cleanStack(stack)
    };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatAndLogError</span>(<span class="hljs-params">error, title, isSoft</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">"undefined"</span>) {
        <span class="hljs-keyword">var</span> message;
        <span class="hljs-keyword">if</span> (util.isObject(error)) {
            <span class="hljs-keyword">var</span> stack = error.stack;
            message = title + formatStack(stack, error);
        } <span class="hljs-keyword">else</span> {
            message = title + <span class="hljs-built_in">String</span>(error);
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> printWarning === <span class="hljs-string">"function"</span>) {
            printWarning(message, isSoft);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span>.log === <span class="hljs-string">"function"</span> ||
            <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span>.log === <span class="hljs-string">"object"</span>) {
            <span class="hljs-built_in">console</span>.log(message);
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fireRejectionEvent</span>(<span class="hljs-params">name, localHandler, reason, promise</span>) </span>{
    <span class="hljs-keyword">var</span> localEventFired = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> localHandler === <span class="hljs-string">"function"</span>) {
            localEventFired = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"rejectionHandled"</span>) {
                localHandler(promise);
            } <span class="hljs-keyword">else</span> {
                localHandler(reason, promise);
            }
        }
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">async</span>.throwLater(e);
    }

    <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"unhandledRejection"</span>) {
        <span class="hljs-keyword">if</span> (!activeFireEvent(name, reason, promise) &amp;&amp; !localEventFired) {
            formatAndLogError(reason, <span class="hljs-string">"Unhandled rejection "</span>);
        }
    } <span class="hljs-keyword">else</span> {
        activeFireEvent(name, promise);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatNonError</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">var</span> str;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">"function"</span>) {
        str = <span class="hljs-string">"[function "</span> +
            (obj.name || <span class="hljs-string">"anonymous"</span>) +
            <span class="hljs-string">"]"</span>;
    } <span class="hljs-keyword">else</span> {
        str = obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj.toString === <span class="hljs-string">"function"</span>
            ? obj.toString() : util.toString(obj);
        <span class="hljs-keyword">var</span> ruselessToString = <span class="hljs-regexp">/\[object [a-zA-Z0-9$_]+\]/</span>;
        <span class="hljs-keyword">if</span> (ruselessToString.test(str)) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">var</span> newStr = <span class="hljs-built_in">JSON</span>.stringify(obj);
                str = newStr;
            }
            <span class="hljs-keyword">catch</span>(e) {

            }
        }
        <span class="hljs-keyword">if</span> (str.length === <span class="hljs-number">0</span>) {
            str = <span class="hljs-string">"(empty array)"</span>;
        }
    }
    <span class="hljs-keyword">return</span> (<span class="hljs-string">"(&lt;"</span> + snip(str) + <span class="hljs-string">"&gt;, no stack trace)"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">snip</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">var</span> maxChars = <span class="hljs-number">41</span>;
    <span class="hljs-keyword">if</span> (str.length &lt; maxChars) {
        <span class="hljs-keyword">return</span> str;
    }
    <span class="hljs-keyword">return</span> str.substr(<span class="hljs-number">0</span>, maxChars - <span class="hljs-number">3</span>) + <span class="hljs-string">"..."</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longStackTracesIsSupported</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> captureStackTrace === <span class="hljs-string">"function"</span>;
}

<span class="hljs-keyword">var</span> shouldIgnore = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; };
<span class="hljs-keyword">var</span> parseLineInfoRegex = <span class="hljs-regexp">/[\/&lt;\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseLineInfo</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">var</span> matches = line.match(parseLineInfoRegex);
    <span class="hljs-keyword">if</span> (matches) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">fileName</span>: matches[<span class="hljs-number">1</span>],
            <span class="hljs-attr">line</span>: <span class="hljs-built_in">parseInt</span>(matches[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>)
        };
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setBounds</span>(<span class="hljs-params">firstLineError, lastLineError</span>) </span>{
    <span class="hljs-keyword">if</span> (!longStackTracesIsSupported()) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> firstStackLines = firstLineError.stack.split(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">var</span> lastStackLines = lastLineError.stack.split(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">var</span> firstIndex = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">var</span> lastIndex = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">var</span> firstFileName;
    <span class="hljs-keyword">var</span> lastFileName;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; firstStackLines.length; ++i) {
        <span class="hljs-keyword">var</span> result = parseLineInfo(firstStackLines[i]);
        <span class="hljs-keyword">if</span> (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lastStackLines.length; ++i) {
        <span class="hljs-keyword">var</span> result = parseLineInfo(lastStackLines[i]);
        <span class="hljs-keyword">if</span> (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">if</span> (firstIndex &lt; <span class="hljs-number">0</span> || lastIndex &lt; <span class="hljs-number">0</span> || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex &gt;= lastIndex) {
        <span class="hljs-keyword">return</span>;
    }

    shouldIgnore = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">if</span> (bluebirdFramePattern.test(line)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">var</span> info = parseLineInfo(line);
        <span class="hljs-keyword">if</span> (info) {
            <span class="hljs-keyword">if</span> (info.fileName === firstFileName &amp;&amp;
                (firstIndex &lt;= info.line &amp;&amp; info.line &lt;= lastIndex)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CapturedTrace</span>(<span class="hljs-params">parent</span>) </span>{
    <span class="hljs-keyword">this</span>._parent = parent;
    <span class="hljs-keyword">this</span>._promisesCreated = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> length = <span class="hljs-keyword">this</span>._length = <span class="hljs-number">1</span> + (parent === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : parent._length);
    captureStackTrace(<span class="hljs-keyword">this</span>, CapturedTrace);
    <span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">32</span>) <span class="hljs-keyword">this</span>.uncycle();
}
util.inherits(CapturedTrace, <span class="hljs-built_in">Error</span>);
Context.CapturedTrace = CapturedTrace;

CapturedTrace.prototype.uncycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> length = <span class="hljs-keyword">this</span>._length;
    <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> nodes = [];
    <span class="hljs-keyword">var</span> stackToIndex = {};

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, node = <span class="hljs-keyword">this</span>; node !== <span class="hljs-literal">undefined</span>; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = <span class="hljs-keyword">this</span>._length = i;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
        <span class="hljs-keyword">var</span> stack = nodes[i].stack;
        <span class="hljs-keyword">if</span> (stackToIndex[stack] === <span class="hljs-literal">undefined</span>) {
            stackToIndex[stack] = i;
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
        <span class="hljs-keyword">var</span> currentStack = nodes[i].stack;
        <span class="hljs-keyword">var</span> index = stackToIndex[currentStack];
        <span class="hljs-keyword">if</span> (index !== <span class="hljs-literal">undefined</span> &amp;&amp; index !== i) {
            <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) {
                nodes[index - <span class="hljs-number">1</span>]._parent = <span class="hljs-literal">undefined</span>;
                nodes[index - <span class="hljs-number">1</span>]._length = <span class="hljs-number">1</span>;
            }
            nodes[i]._parent = <span class="hljs-literal">undefined</span>;
            nodes[i]._length = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> cycleEdgeNode = i &gt; <span class="hljs-number">0</span> ? nodes[i - <span class="hljs-number">1</span>] : <span class="hljs-keyword">this</span>;

            <span class="hljs-keyword">if</span> (index &lt; length - <span class="hljs-number">1</span>) {
                cycleEdgeNode._parent = nodes[index + <span class="hljs-number">1</span>];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                cycleEdgeNode._parent = <span class="hljs-literal">undefined</span>;
                cycleEdgeNode._length = <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">var</span> currentChildLength = cycleEdgeNode._length + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            <span class="hljs-keyword">return</span>;
        }
    }
};

CapturedTrace.prototype.attachExtraTrace = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-keyword">if</span> (error.__stackCleaned__) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.uncycle();
    <span class="hljs-keyword">var</span> parsed = parseStackAndMessage(error);
    <span class="hljs-keyword">var</span> message = parsed.message;
    <span class="hljs-keyword">var</span> stacks = [parsed.stack];

    <span class="hljs-keyword">var</span> trace = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">while</span> (trace !== <span class="hljs-literal">undefined</span>) {
        stacks.push(cleanStack(trace.stack.split(<span class="hljs-string">"\n"</span>)));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, <span class="hljs-string">"stack"</span>, reconstructStack(message, stacks));
    util.notEnumerableProp(error, <span class="hljs-string">"__stackCleaned__"</span>, <span class="hljs-literal">true</span>);
};

<span class="hljs-keyword">var</span> captureStackTrace = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stackDetection</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> v8stackFramePattern = <span class="hljs-regexp">/^\s*at\s*/</span>;
    <span class="hljs-keyword">var</span> v8stackFormatter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stack, error</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> stack === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> stack;

        <span class="hljs-keyword">if</span> (error.name !== <span class="hljs-literal">undefined</span> &amp;&amp;
            error.message !== <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">return</span> error.toString();
        }
        <span class="hljs-keyword">return</span> formatNonError(error);
    };

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Error</span>.stackTraceLimit === <span class="hljs-string">"number"</span> &amp;&amp;
        <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Error</span>.captureStackTrace === <span class="hljs-string">"function"</span>) {
        <span class="hljs-built_in">Error</span>.stackTraceLimit += <span class="hljs-number">6</span>;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        <span class="hljs-keyword">var</span> captureStackTrace = <span class="hljs-built_in">Error</span>.captureStackTrace;

        shouldIgnore = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
            <span class="hljs-keyword">return</span> bluebirdFramePattern.test(line);
        };
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">receiver, ignoreUntil</span>) </span>{
            <span class="hljs-built_in">Error</span>.stackTraceLimit += <span class="hljs-number">6</span>;
            captureStackTrace(receiver, ignoreUntil);
            <span class="hljs-built_in">Error</span>.stackTraceLimit -= <span class="hljs-number">6</span>;
        };
    }
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> err.stack === <span class="hljs-string">"string"</span> &amp;&amp;
        err.stack.split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>].indexOf(<span class="hljs-string">"stackDetection@"</span>) &gt;= <span class="hljs-number">0</span>) {
        stackFramePattern = <span class="hljs-regexp">/@/</span>;
        formatStack = v8stackFormatter;
        indentStackFrames = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">captureStackTrace</span>(<span class="hljs-params">o</span>) </span>{
            o.stack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>().stack;
        };
    }

    <span class="hljs-keyword">var</span> hasStackAfterThrow;
    <span class="hljs-keyword">try</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(); }
    <span class="hljs-keyword">catch</span>(e) {
        hasStackAfterThrow = (<span class="hljs-string">"stack"</span> <span class="hljs-keyword">in</span> e);
    }
    <span class="hljs-keyword">if</span> (!(<span class="hljs-string">"stack"</span> <span class="hljs-keyword">in</span> err) &amp;&amp; hasStackAfterThrow &amp;&amp;
        <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Error</span>.stackTraceLimit === <span class="hljs-string">"number"</span>) {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">captureStackTrace</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-built_in">Error</span>.stackTraceLimit += <span class="hljs-number">6</span>;
            <span class="hljs-keyword">try</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(); }
            <span class="hljs-keyword">catch</span>(e) { o.stack = e.stack; }
            <span class="hljs-built_in">Error</span>.stackTraceLimit -= <span class="hljs-number">6</span>;
        };
    }

    formatStack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stack, error</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> stack === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> stack;

        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> error === <span class="hljs-string">"object"</span> ||
            <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">"function"</span>) &amp;&amp;
            error.name !== <span class="hljs-literal">undefined</span> &amp;&amp;
            error.message !== <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">return</span> error.toString();
        }
        <span class="hljs-keyword">return</span> formatNonError(error);
    };

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

})([]);

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span>.warn !== <span class="hljs-string">"undefined"</span>) {
    printWarning = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
        <span class="hljs-built_in">console</span>.warn(message);
    };
    <span class="hljs-keyword">if</span> (util.isNode &amp;&amp; process.stderr.isTTY) {
        printWarning = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, isSoft</span>) </span>{
            <span class="hljs-keyword">var</span> color = isSoft ? <span class="hljs-string">"\u001b[33m"</span> : <span class="hljs-string">"\u001b[31m"</span>;
            <span class="hljs-built_in">console</span>.warn(color + message + <span class="hljs-string">"\u001b[0m\n"</span>);
        };
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!util.isNode &amp;&amp; <span class="hljs-keyword">typeof</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>().stack) === <span class="hljs-string">"string"</span>) {
        printWarning = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, isSoft</span>) </span>{
            <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">"%c"</span> + message,
                        isSoft ? <span class="hljs-string">"color: darkorange"</span> : <span class="hljs-string">"color: red"</span>);
        };
    }
}

<span class="hljs-keyword">var</span> config = {
    <span class="hljs-attr">warnings</span>: warnings,
    <span class="hljs-attr">longStackTraces</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">cancellation</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">monitoring</span>: <span class="hljs-literal">false</span>
};

<span class="hljs-keyword">if</span> (longStackTraces) <span class="hljs-built_in">Promise</span>.longStackTraces();

<span class="hljs-keyword">return</span> {
    <span class="hljs-attr">longStackTraces</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> config.longStackTraces;
    },
    <span class="hljs-attr">warnings</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> config.warnings;
    },
    <span class="hljs-attr">cancellation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> config.cancellation;
    },
    <span class="hljs-attr">monitoring</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> config.monitoring;
    },
    <span class="hljs-attr">propagateFromFunction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> propagateFromFunction;
    },
    <span class="hljs-attr">boundValueFunction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> boundValueFunction;
    },
    <span class="hljs-attr">checkForgottenReturns</span>: checkForgottenReturns,
    <span class="hljs-attr">setBounds</span>: setBounds,
    <span class="hljs-attr">warn</span>: warn,
    <span class="hljs-attr">deprecated</span>: deprecated,
    <span class="hljs-attr">CapturedTrace</span>: CapturedTrace,
    <span class="hljs-attr">fireDomEvent</span>: fireDomEvent,
    <span class="hljs-attr">fireGlobalEvent</span>: fireGlobalEvent
};
};

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
